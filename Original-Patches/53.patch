From 2c2ead353fc86ad7dd2f7f2856a98a9519081ba8 Mon Sep 17 00:00:00 2001
From: andi34 <skate4life@gmx.de>
Date: Sat, 12 Jul 2014 14:56:19 +0200
Subject: [PATCH] arch/arm/mach-omap2/dvfs.c: revert JB Update 1/3

diff --git a/arch/arm/mach-omap2/dvfs.c b/arch/arm/mach-omap2/dvfs.c
index 5431805..ad0281d 100644
--- a/arch/arm/mach-omap2/dvfs.c
+++ b/arch/arm/mach-omap2/dvfs.c
@@ -267,6 +267,43 @@ struct omap_vdd_dvfs_info *_voltdm_to_dvfs_info(struct voltagedomain *voltdm)
 	return NULL;
 }
 
+/**
+ * _volt_to_opp() - Find OPP corresponding to a given voltage
+ * @dev:	device pointer associated with the OPP list
+ * @volt:	voltage to search for in uV
+ *
+ * Searches for exact match in the OPP list and returns handle to the matching
+ * OPP if found, else return the max available OPP.
+ * If there are multiple opps with same voltage, it will return
+ * the first available entry. Return pointer should be checked against IS_ERR.
+ *
+ * NOTE: since this uses OPP functions, use under rcu_lock. This function also
+ * assumes that the cpufreq table and OPP table are in sync - any modifications
+ * to either should be synchronized.
+ */
+static struct opp *_volt_to_opp(struct device *dev, unsigned long volt)
+{
+	struct opp *opp = ERR_PTR(-ENODEV);
+	unsigned long f = 0;
+
+	do {
+		opp = opp_find_freq_ceil(dev, &f);
+		if (IS_ERR(opp)) {
+			/*
+			 * if there is no OPP for corresponding volt
+			 * then return max available instead
+			 */
+			opp = opp_find_freq_floor(dev, &f);
+			break;
+		}
+		if (opp_get_voltage(opp) >= volt)
+			break;
+		f++;
+	} while (1);
+
+	return opp;
+}
+
 /* rest of the helper functions */
 /**
  * _add_vdd_user() - Add a voltage request
@@ -449,7 +486,6 @@ static int _remove_freq_request(struct omap_vdd_dvfs_info *dvfs_info,
 		return -EINVAL;
 	}
 
-
 	list_for_each_entry(temp_dev, &dvfs_info->dev_list, node) {
 		if (temp_dev->dev == target_dev)
 			break;
@@ -504,7 +540,7 @@ static int _dep_scan_table(struct device *dev,
 	struct omap_vdd_dvfs_info *tdvfs_info;
 	struct opp *opp;
 	int i, ret;
-	unsigned long dep_volt = 0, new_dep_volt, new_freq = 0;
+	unsigned long dep_volt = 0, new_dep_volt = 0, new_freq = 0;
 
 	if (!dep_table) {
 		dev_err(dev, "%s: deptable not present for vdd%s\n",
@@ -548,24 +584,16 @@ static int _dep_scan_table(struct device *dev,
 		return -ENODEV;
 	}
 
-	new_dep_volt = dep_volt;
 	rcu_read_lock();
-
-	/*
-	 * To obey OPP dependencies a dependent domain
-	 * should be scaled to OPP which is not lower than requested.
-	 * If such OPP is not found it means OPP tables are messed-up.
-	 * Don't fall back to floor OPP, because it will violate
-	 * OPP dependency and make system unstable.
-	 * Just throw an error and return.
-	 */
-	opp = opp_find_volt_ceil(target_dev, &new_dep_volt);
-	if (!IS_ERR(opp))
+	opp = _volt_to_opp(target_dev, dep_volt);
+	if (!IS_ERR(opp)) {
+		new_dep_volt = opp_get_voltage(opp);
 		new_freq = opp_get_freq(opp);
+	}
 	rcu_read_unlock();
 
 	if (!new_dep_volt || !new_freq) {
-		dev_err(target_dev, "%s: no valid ceil OPP for voltage %lu\n",
+		dev_err(target_dev, "%s: no valid OPP for voltage %lu\n",
 				__func__, dep_volt);
 		return -ENODATA;
 	}
@@ -830,26 +858,10 @@ static int _dvfs_scale(struct device *req_dev, struct device *target_dev,
 			 * if there are none pending
 			 */
 			if (target_dev == dev) {
-				unsigned long tmp_volt = new_volt;
 				rcu_read_lock();
-				/*
-				 * At this point voltage level is already
-				 * determined and it won't change.
-				 * So we should find OPP with equal or lower
-				 * voltage. Otherwise frequency may be too high
-				 * for voltage that is already set (or going
-				 * to be set) and system will become unstable.
-				 * If there is no such OPP then OPP tables are
-				 * messed up and should be fixed.
-				 * Better throw an error and skip this device.
-				 */
-				opp = opp_find_volt_floor(dev, &tmp_volt);
+				opp = _volt_to_opp(dev, new_volt);
 				if (!IS_ERR(opp))
 					freq = opp_get_freq(opp);
-				else
-					dev_err(dev, "%s: no valid floor OPP "
-							"for voltage %lu\n",
-							__func__, tmp_volt);
 				rcu_read_unlock();
 			}
 			if (!freq)
@@ -945,7 +957,7 @@ int omap_device_scale(struct device *req_dev, struct device *target_dev,
 			unsigned long rate)
 {
 	struct opp *opp;
-	unsigned long volt, freq = rate;
+	unsigned long volt, freq = rate, new_freq = 0;
 	struct omap_vdd_dvfs_info *tdvfs_info;
 	struct platform_device *pdev;
 	struct omap_device *od;
@@ -1031,37 +1043,20 @@ int omap_device_scale(struct device *req_dev, struct device *target_dev,
 	}
 
 	if (dev != target_dev) {
-		unsigned long tmp_volt = volt, new_freq = 0;
 		rcu_read_lock();
-		/*
-		 * At this point voltage level is already
-		 * determined and requested.
-		 * So we should find OPP with equal or lower voltage.
-		 * Otherwise frequency may be too high for voltage
-		 * that is going to be set and system will become unstable.
-		 * If there is no such OPP then OPP tables are
-		 * messed up and should be fixed.
-		 * Just throw an error and abort scaling.
-		 */
-		opp = opp_find_volt_floor(dev, &tmp_volt);
+		opp = _volt_to_opp(dev, volt);
 		if (!IS_ERR(opp))
 			new_freq = opp_get_freq(opp);
-		else
-			dev_err(dev, "%s: no valid floor OPP for voltage %lu\n",
-					__func__, tmp_volt);
 		rcu_read_unlock();
-
-		if (!new_freq) {
-			ret = (IS_ERR(opp)) ? PTR_ERR(opp) : -ENODEV;
-			goto out;
-		}
-		ret = _add_freq_request(tdvfs_info, req_dev, dev,
-					new_freq);
-		if (ret) {
-			dev_err(target_dev, "%s: freqadd(%s) failed %d"
-				"[f=%ld, v=%ld]\n", __func__,
-				dev_name(req_dev), ret, freq, volt);
-			goto out;
+		if (new_freq) {
+			ret = _add_freq_request(tdvfs_info, req_dev, dev,
+						new_freq);
+			if (ret) {
+				dev_err(target_dev, "%s: freqadd(%s) failed %d"
+					"[f=%ld, v=%ld]\n", __func__,
+					dev_name(req_dev), ret, freq, volt);
+				goto out;
+			}
 		}
 	}
 
