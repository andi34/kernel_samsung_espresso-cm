From aa754d5580e211740bf063842707bd32db866306 Mon Sep 17 00:00:00 2001
From: andi34 <skate4life@gmx.de>
Date: Sat, 12 Jul 2014 16:25:18 +0200
Subject: [PATCH] arch/arm/mach-omap2/omap4-sar.c: revert JB Update 1/3

---
diff --git a/arch/arm/mach-omap2/omap4-sar.c b/arch/arm/mach-omap2/omap4-sar.c
index ae501dd..84d9929 100644
--- a/arch/arm/mach-omap2/omap4-sar.c
+++ b/arch/arm/mach-omap2/omap4-sar.c
@@ -16,6 +16,8 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 
+#include <plat/usb.h>
+
 #include <mach/omap4-common.h>
 #include <mach/ctrl_module_wkup_44xx.h>
 
@@ -34,6 +36,7 @@
 
 /* OMAP4 modulemode control */
 #define OMAP4430_MODULEMODE_SWCTRL			1
+#define OMAP4430_USBHOST_CTX_NUM			9
 
 static void __iomem *sar_ram_base;
 static void __iomem *omap4_sar_modules[MAX_SAR_MODULES];
@@ -239,6 +242,15 @@ static const u32 omap443x_sar_ram1_layout[][4] = {
 	{L3_CLK3_INDEX, 0x208, 1, 0x000002E4},
 	{L3_CLK3_INDEX, 0x210, 1, 0x000002E8},
 	{CM2_INDEX, OMAP4430_CM2_RESTORE_INST +
+		OMAP4_CM_SDMA_STATICDEP_RESTORE_OFFSET, 1, 0x00000924},
+	/* Due to errata i719 (Multiple OFF Mode Transitions Introduce
+	 * Corruption) the USB host context must only be saved if the USB host
+	 * controller has been resumed since the previous OFF mode transition.
+	 * Therefore move the USB SAR context descriptors to the end of the
+	 * array, following the sDMA context, so we can skip them if we do not
+	 * need to save the USB host context.
+	 */
+	{CM2_INDEX, OMAP4430_CM2_RESTORE_INST +
 	OMAP4_CM_L3INIT_USB_HOST_CLKCTRL_RESTORE_OFFSET, 1, 0x000002EC},
 	{CM2_INDEX, OMAP4430_CM2_RESTORE_INST +
 	OMAP4_CM_L3INIT_USB_TLL_CLKCTRL_RESTORE_OFFSET, 1, 0x000002F0},
@@ -252,8 +264,6 @@ static const u32 omap443x_sar_ram1_layout[][4] = {
 	OMAP4_CM_L3INIT_USB_HOST_CLKCTRL_RESTORE_OFFSET, 1, 0x0000091C},
 	{CM2_INDEX, OMAP4430_CM2_RESTORE_INST +
 	OMAP4_CM_L3INIT_USB_TLL_CLKCTRL_RESTORE_OFFSET, 1, 0x00000920},
-	{CM2_INDEX, OMAP4430_CM2_RESTORE_INST +
-		OMAP4_CM_SDMA_STATICDEP_RESTORE_OFFSET, 1, 0x00000924},
 };
 
 /*
@@ -610,7 +620,6 @@ static const u32 omap446x_sar_ram1_layout[][4] = {
 		OMAP4_CM_SDMA_STATICDEP_RESTORE_OFFSET, 1, 0x00000928},
 };
 
-
 /*
  * OMAP4460, OMAP4470
  * SAR_RAM2 register layout consist of SYSCTRL_PADCONF_CORE regsiters
@@ -1180,31 +1189,6 @@ static int omap4_sar_not_accessible(void)
 	u32 usbhost_state, usbtll_state;
 
 	/*
-	 * Errata i719: Multiple OFF Mode Transitions Introduce Corruption
-	 *
-	 * Workaround: Set the CM_L3INIT_HSUSBHOST_CLKCTRL[1:0] MODULEMODE
-	 * bit field to 0x2 (enabled) for 1 ms before save sequence
-	 */
-	if (cpu_is_omap443x()) {
-		u32 val;
-		val = omap4_cminst_read_inst_reg(OMAP4430_CM2_PARTITION,
-				OMAP4430_CM2_L3INIT_INST,
-				OMAP4_CM_L3INIT_USB_HOST_CLKCTRL_OFFSET);
-
-		if (!(val & BIT(OMAP4430_MODULEMODE_SWCTRL))) {
-			val |= BIT(OMAP4430_MODULEMODE_SWCTRL);
-			omap4_cminst_write_inst_reg(val, OMAP4430_CM2_PARTITION,
-				OMAP4430_CM2_L3INIT_INST,
-				OMAP4_CM_L3INIT_USB_HOST_CLKCTRL_OFFSET);
-			mdelay(1);
-			val &= ~BIT(OMAP4430_MODULEMODE_SWCTRL);
-			omap4_cminst_write_inst_reg(val, OMAP4430_CM2_PARTITION,
-				OMAP4430_CM2_L3INIT_INST,
-				OMAP4_CM_L3INIT_USB_HOST_CLKCTRL_OFFSET);
-		}
-	}
-
-	/*
 	 * Make sure that USB host and TLL modules are not
 	 * enabled before attempting to save the context
 	 * registers, otherwise this will trigger an exception.
@@ -1234,6 +1218,8 @@ static int omap4_sar_not_accessible(void)
   */
 int omap4_sar_save(void)
 {
+	unsigned uhh_save = 1;
+
 	/*
 	 * Not supported on ES1.0 silicon
 	 */
@@ -1252,9 +1238,10 @@ int omap4_sar_save(void)
 	 * SAR bits and clocks needs to be enabled
 	 */
 	clkdm_wakeup(l3init_clkdm);
-	pwrdm_enable_hdwr_sar(l3init_pwrdm);
-	clk_enable(usb_host_ck);
+	if (uhh_save)
+		pwrdm_enable_hdwr_sar(l3init_pwrdm);
 	clk_enable(usb_tll_ck);
+	clk_enable(usb_host_ck);
 
 	/* Save SAR BANK1 */
 	if (cpu_is_omap446x())
@@ -1264,12 +1251,14 @@ int omap4_sar_save(void)
 		sar_save(ARRAY_SIZE(omap447x_sar_ram1_layout), SAR_BANK1_OFFSET,
 			 omap447x_sar_ram1_layout);
 	else
-		sar_save(ARRAY_SIZE(omap443x_sar_ram1_layout), SAR_BANK1_OFFSET,
-			 omap443x_sar_ram1_layout);
+		sar_save((ARRAY_SIZE(omap443x_sar_ram1_layout) -
+			(uhh_save ? 0 : OMAP4430_USBHOST_CTX_NUM)),
+			SAR_BANK1_OFFSET, omap443x_sar_ram1_layout);
 
 	clk_disable(usb_host_ck);
 	clk_disable(usb_tll_ck);
-	pwrdm_disable_hdwr_sar(l3init_pwrdm);
+	if (uhh_save)
+		pwrdm_disable_hdwr_sar(l3init_pwrdm);
 	clkdm_allow_idle(l3init_clkdm);
 
 	/* Save SAR BANK2 */
-- 
1.9.3


