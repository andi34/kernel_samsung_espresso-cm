diff --git a/MAINTAINERS b/MAINTAINERS
index 08e6f61..b0209fb 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2491,7 +2491,7 @@ S:	Maintained
 F:	drivers/net/eexpress.*
 
 ETHERNET BRIDGE
-M:	Stephen Hemminger <stephen@networkplumber.org>
+M:	Stephen Hemminger <shemminger@linux-foundation.org>
 L:	bridge@lists.linux-foundation.org
 L:	netdev@vger.kernel.org
 W:	http://www.linuxfoundation.org/en/Net:Bridge
@@ -4327,7 +4327,7 @@ S:	Supported
 F:	drivers/infiniband/hw/nes/
 
 NETEM NETWORK EMULATOR
-M:	Stephen Hemminger <stephen@networkplumber.org>
+M:	Stephen Hemminger <shemminger@linux-foundation.org>
 L:	netem@lists.linux-foundation.org
 S:	Maintained
 F:	net/sched/sch_netem.c
@@ -5247,7 +5247,7 @@ F:	Documentation/blockdev/ramdisk.txt
 F:	drivers/block/brd.c
 
 RANDOM NUMBER DRIVER
-M:	Theodore Ts'o" <tytso@mit.edu>
+M:	Matt Mackall <mpm@selenic.com>
 S:	Maintained
 F:	drivers/char/random.c
 
@@ -5779,7 +5779,7 @@ S:	Maintained
 F:	drivers/usb/misc/sisusbvga/
 
 SKGE, SKY2 10/100/1000 GIGABIT ETHERNET DRIVERS
-M:	Stephen Hemminger <stephen@networkplumber.org>
+M:	Stephen Hemminger <shemminger@linux-foundation.org>
 L:	netdev@vger.kernel.org
 S:	Maintained
 F:	drivers/net/skge.*
@@ -6040,8 +6040,7 @@ F:	arch/alpha/kernel/srm_env.c
 STABLE BRANCH
 M:	Greg Kroah-Hartman <greg@kroah.com>
 L:	stable@vger.kernel.org
-S:	Supported
-F:	Documentation/stable_kernel_rules.txt
+S:	Maintained
 
 STAGING SUBSYSTEM
 M:	Greg Kroah-Hartman <gregkh@suse.de>
@@ -6359,6 +6358,13 @@ S:	Maintained
 F:	Documentation/filesystems/ufs.txt
 F:	fs/ufs/
 
+UHID USERSPACE HID IO DRIVER:
+M:	David Herrmann <dh.herrmann@googlemail.com>
+L:	linux-input@vger.kernel.org
+S:	Maintained
+F:	drivers/hid/uhid.c
+F:	include/linux/uhid.h
+
 ULTRA-WIDEBAND (UWB) SUBSYSTEM:
 L:	linux-usb@vger.kernel.org
 S:	Orphan
diff --git a/Makefile b/Makefile
index 2922e1f..58c208b 100644
--- a/Makefile
+++ b/Makefile
@@ -91,7 +91,6 @@ endif
 # The O= assignment takes precedence over the KBUILD_OUTPUT environment
 # variable.
 
-
 # KBUILD_SRC is set on invocation of make in OBJ directory
 # KBUILD_SRC is not intended to be used by the regular user (for now)
 ifeq ($(KBUILD_SRC),)
@@ -158,11 +157,10 @@ VPATH		:= $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))
 
 export srctree objtree VPATH
 
-
 # SUBARCH tells the usermode build what the underlying arch is.  That is set
 # first, and if a usermode build is happening, the "ARCH=um" on the command
 # line overrides the setting of ARCH below.  If a native build is happening,
-# then ARCH is assigned, getting whatever value it gets normally, and 
+# then ARCH is assigned, getting whatever value it gets normally, and
 # SUBARCH is subsequently ignored.
 
 SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
@@ -192,7 +190,7 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= arm
+ARCH		?=arm
 CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
 
 # Architecture as present in compile.h
@@ -245,8 +243,8 @@ CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
-HOSTCXXFLAGS = -O2
+HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fno-unswitch-loops -fno-inline-functions -fomit-frame-pointer
+HOSTCXXFLAGS = -O2 -fno-unswitch-loops -fno-inline-functions
 
 # Decide whether to build built-in, modular, or both.
 # Normally, just do built-in.
@@ -289,7 +287,7 @@ export KBUILD_CHECKSRC KBUILD_SRC KBUILD_EXTMOD
 #         cmd_cc_o_c       = $(CC) $(c_flags) -c -o $@ $<
 #
 # If $(quiet) is empty, the whole command will be printed.
-# If it is set to "quiet_", only the short version will be printed. 
+# If it is set to "quiet_", only the short version will be printed.
 # If it is set to "silent_", nothing will be printed at all, since
 # the variable $(silent_cmd_cc_o_c) doesn't exist.
 #
@@ -318,7 +316,6 @@ endif
 
 export quiet Q KBUILD_VERBOSE
 
-
 # Look for make include files relative to root of kernel src
 MAKEFLAGS += --include-dir=$(srctree)
 
@@ -345,16 +342,26 @@ KALLSYMS	= scripts/kallsyms
 PERL		= perl
 CHECK		= sparse
 
-CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
-		  -Wbitwise -Wno-return-void $(CF)
-CFLAGS_MODULE   =
-AFLAGS_MODULE   =
-LDFLAGS_MODULE  =
-CFLAGS_KERNEL	=
+CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__  -Wbitwise -Wno-return-void $(CF)
+MODFLAGS        = -DMODULE \
+                  -march=armv7-a \
+                  -mfpu=neon \
+                  -mtune=cortex-a9 \
+                  -O2 \
+                  -fno-unswitch-loops \
+                  -fno-inline-functions
+
+CFLAGS_MODULE   = $(MODFLAGS)
+AFLAGS_MODULE   = $(MODFLAGS)
+LDFLAGS_MODULE  = -T $(srctree)/scripts/module-common.lds
+CFLAGS_KERNEL  =  -march=armv7-a \
+                  -mfpu=neon \
+                  -mtune=cortex-a9 \
+                  -O2
+
 AFLAGS_KERNEL	=
 CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage
 
-
 # Use LINUXINCLUDE when you must reference the include/ directory.
 # Needed to be compatible with the O= option
 LINUXINCLUDE    := -I$(srctree)/arch/$(hdr-arch)/include \
@@ -363,15 +370,15 @@ LINUXINCLUDE    := -I$(srctree)/arch/$(hdr-arch)/include \
                    -include include/generated/autoconf.h
 
 KBUILD_CPPFLAGS := -D__KERNEL__
-
 KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
 		   -fno-strict-aliasing -fno-common \
 		   -Werror-implicit-function-declaration \
 		   -Wno-format-security \
 		   -fno-delete-null-pointer-checks
-KBUILD_AFLAGS_KERNEL :=
-KBUILD_CFLAGS_KERNEL :=
-KBUILD_AFLAGS   := -D__ASSEMBLY__
+
+KBUILD_AFLAGS_KERNEL  :=
+KBUILD_CFLAGS_KERNEL  :=
+KBUILD_AFLAGS         := -D__ASSEMBLY__
 KBUILD_AFLAGS_MODULE  := -DMODULE
 KBUILD_CFLAGS_MODULE  := -DMODULE
 KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
@@ -561,9 +568,18 @@ all: vmlinux
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 KBUILD_CFLAGS	+= -Os
 else
-KBUILD_CFLAGS	+= -O2
+KBUILD_CFLAGS	+= -O2 -fno-unswitch-loops -fno-inline-functions
 endif
 
+KBUILD_CFLAGS += -Wno-maybe-uninitialized \
+		 -Wno-enum-compare \
+		 -Wno-address \
+		 -Wno-unused-variable \
+		 -Wno-unused-value \
+		 -Wno-format \
+		 -Wno-declaration-after-statement \
+		 -Wno-deprecated-declarations
+
 include $(srctree)/arch/$(SRCARCH)/Makefile
 
 ifneq ($(CONFIG_FRAME_WARN),0)
diff --git a/arch/Kconfig b/arch/Kconfig
index 228d761..26b0e23 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -124,9 +124,6 @@ config HAVE_ARCH_TRACEHOOK
 config HAVE_DMA_ATTRS
 	bool
 
-config HAVE_DMA_CONTIGUOUS
-	bool
-
 config USE_GENERIC_SMP_HELPERS
 	bool
 
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 1b7b8f0..5ac6780 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -21,7 +20,6 @@ config ARM
 	select HAVE_KERNEL_GZIP
 	select HAVE_KERNEL_LZO
 	select HAVE_KERNEL_LZMA
-	select HAVE_IRQ_WORK
 	select HAVE_PERF_EVENTS
 	select PERF_USE_VMALLOC
 	select HAVE_REGS_AND_STACK_ACCESS_API
@@ -141,10 +136,10 @@ config GENERIC_LOCKBREAK
 
 config RWSEM_GENERIC_SPINLOCK
 	bool
-	default y
 
 config RWSEM_XCHGADD_ALGORITHM
 	bool
+	def_bool y
 
 config ARCH_HAS_ILOG2_U32
 	bool
@@ -1247,42 +1242,6 @@ config ARM_ERRATA_754327
 	  This workaround defines cpu_relax() as smp_mb(), preventing correctly
 	  written polling loops from denying visibility of updates to memory.
 
-config ARM_ERRATA_764369
-	bool "ARM errata: Data cache line maintenance operation by MVA may not succeed"
-	depends on CPU_V7 && SMP
-	help
-	  This option enables the workaround for erratum 764369
-	  affecting Cortex-A9 MPCore with two or more processors (all
-	  current revisions). Under certain timing circumstances, a data
-	  cache line maintenance operation by MVA targeting an Inner
-	  Shareable memory region may fail to proceed up to either the
-	  Point of Coherency or to the Point of Unification of the
-	  system. This workaround adds a DSB instruction before the
-	  relevant cache maintenance functions and sets a specific bit
-	  in the diagnostic control register of the SCU.
-
-config PL310_ERRATA_769419
-	bool "PL310 errata: no automatic Store Buffer drain"
-	depends on CACHE_L2X0
-	help
-	  On revisions of the PL310 prior to r3p2, the Store Buffer does
-	  not automatically drain. This can cause normal, non-cacheable
-	  writes to be retained when the memory system is idle, leading
-	  to suboptimal I/O performance for drivers using coherent DMA.
-	  This option adds a write barrier to the cpu_idle loop so that,
-	  on systems with an outer cache, the store buffer is drained
-	  explicitly.
-
-config ARM_ERRATA_775420
-       bool "ARM errata: A data cache maintenance operation which aborts, might lead to deadlock"
-       depends on CPU_V7
-       help
-	 This option enables the workaround for the 775420 Cortex-A9 (r2p2,
-	 r2p6,r2p8,r2p10,r3p0) erratum. In case a date cache maintenance
-	 operation aborts with MMU exception, it might cause the processor
-	 to deadlock. This workaround puts DSB before executing ISB if
-	 an abort may occur on cache maintenance.
-
 endmenu
 
 source "arch/arm/common/Kconfig"
@@ -1347,6 +1306,32 @@ source "drivers/pci/Kconfig"
 
 source "drivers/pcmcia/Kconfig"
 
+config ARM_ERRATA_764369
+	bool "ARM errata: Data cache line maintenance operation by MVA may not succeed"
+	depends on CPU_V7 && SMP
+	help
+	  This option enables the workaround for erratum 764369
+	  affecting Cortex-A9 MPCore with two or more processors (all
+	  current revisions). Under certain timing circumstances, a data
+	  cache line maintenance operation by MVA targeting an Inner
+	  Shareable memory region may fail to proceed up to either the
+	  Point of Coherency or to the Point of Unification of the
+	  system. This workaround adds a DSB instruction before the
+	  relevant cache maintenance functions and sets a specific bit
+	  in the diagnostic control register of the SCU.
+
+config PL310_ERRATA_769419
+	bool "PL310 errata: no automatic Store Buffer drain"
+	depends on CACHE_L2X0
+	help
+	  On revisions of the PL310 prior to r3p2, the Store Buffer does
+	  not automatically drain. This can cause normal, non-cacheable
+	  writes to be retained when the memory system is idle, leading
+	  to suboptimal I/O performance for drivers using coherent DMA.
+	  This option adds a write barrier to the cpu_idle loop so that,
+	  on systems with an outer cache, the store buffer is drained
+	  explicitly.
+
 endmenu
 
 menu "Kernel Features"
@@ -1917,7 +1902,6 @@ source "drivers/cpufreq/Kconfig"
 config CPU_FREQ_IMX
 	tristate "CPUfreq driver for i.MX CPUs"
 	depends on ARCH_MXC && CPU_FREQ
-	select CPU_FREQ_TABLE
 	help
 	  This enables the CPUfreq driver for i.MX CPUs.
 
diff --git a/arch/arm/boot/compressed/Makefile b/arch/arm/boot/compressed/Makefile
index 23aad07..0a96721 100644
--- a/arch/arm/boot/compressed/Makefile
+++ b/arch/arm/boot/compressed/Makefile
@@ -5,6 +5,7 @@
 #
 
 OBJS		=
+plus_sec := $(call as-instr,.arch_extension sec,+sec)
 
 # Ensure that mmcif loader code appears early in the image
 # to minimise that number of bocks that have to be read in
@@ -15,9 +16,13 @@ OBJS		+= mmcif-sh7372.o
 endif
 endif
 
-AFLAGS_head.o += -DTEXT_OFFSET=$(TEXT_OFFSET)
-HEAD	= head.o
-OBJS	+= misc.o decompress.o
+AFLAGS_head.o := -DTEXT_OFFSET=$(TEXT_OFFSET)
+AFLAGS_head.o += -Wa,-march=armv7-a$(plus_sec)
+HEAD = head.o
+AFLAGS_misc.o +=-Wa,-march=armv7-a$(plus_sec)
+MISC = misc.o
+AFLAGS_decompress.o += -Wa,-march=armv7-a$(plus_sec)
+DECOMPRESS = decompress.o
 FONTC	= $(srctree)/drivers/video/console/font_acorn_8x8.c
 
 #
@@ -83,9 +88,9 @@ suffix_$(CONFIG_KERNEL_GZIP) = gzip
 suffix_$(CONFIG_KERNEL_LZO)  = lzo
 suffix_$(CONFIG_KERNEL_LZMA) = lzma
 
-targets       := vmlinux vmlinux.lds \
-		 piggy.$(suffix_y) piggy.$(suffix_y).o \
-		 font.o font.c head.o misc.o $(OBJS)
+targets 	:= vmlinux vmlinux.lds \
+		piggy.$(suffix_y) piggy.$(suffix_y).o \
+		font.o font.c head.o misc.o decompress.o $(OBJS)
 
 # Make sure files are removed during clean
 extra-y       += piggy.gzip piggy.lzo piggy.lzma lib1funcs.S
@@ -115,6 +120,7 @@ LDFLAGS_vmlinux += -X
 LDFLAGS_vmlinux += -T
 
 # For __aeabi_uidivmod
+AFLAGS_lib1funcs.o +=-Wa,-march=armv7-a$(plus_sec)
 lib1funcs = $(obj)/lib1funcs.o
 
 $(obj)/lib1funcs.S: $(srctree)/arch/$(SRCARCH)/lib/lib1funcs.S FORCE
@@ -133,14 +139,15 @@ bad_syms=$$($(CROSS_COMPILE)nm $@ | sed -n 's/^.\{8\} [bc] \(.*\)/\1/p') && \
   ( echo "following symbols must have non local/private scope:" >&2; \
     echo "$$bad_syms" >&2; rm -f $@; false )
 
-$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.$(suffix_y).o \
-	 	$(addprefix $(obj)/, $(OBJS)) $(lib1funcs) FORCE
+$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/$(MISC) $(obj)/$(DECOMPRESS) $(obj)/piggy.$(suffix_y).o \
+ 	$(addprefix $(obj)/, $(OBJS)) $(lib1funcs) FORCE
 	$(call if_changed,ld)
 	@$(check_for_bad_syms)
 
 $(obj)/piggy.$(suffix_y): $(obj)/../Image FORCE
 	$(call if_changed,$(suffix_y))
 
+AFLAGS_piggy.$(suffix_y).o += -Wa,-march=armv7-a$(plus_sec)
 $(obj)/piggy.$(suffix_y).o:  $(obj)/piggy.$(suffix_y) FORCE
 
 CFLAGS_font.o := -Dstatic=
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index caddb9d..191a7ee 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -539,7 +539,6 @@ __armv7_mmu_cache_on:
 		mcrne	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
 #endif
 		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
-		bic	r0, r0, #1 << 28	@ clear SCTLR.TRE
 		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
 		orr	r0, r0, #0x003c		@ write buffer
 #ifdef CONFIG_MMU
diff --git a/arch/arm/include/asm/pgtable.h b/arch/arm/include/asm/pgtable.h
index a558978..3572ee5 100644
--- a/arch/arm/include/asm/pgtable.h
+++ b/arch/arm/include/asm/pgtable.h
@@ -283,7 +283,6 @@ extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
 extern struct page *empty_zero_page;
 #define ZERO_PAGE(vaddr)	(empty_zero_page)
 
-
 extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 
 /* to find an entry in a page-table-directory */
@@ -306,7 +305,6 @@ extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 #define set_pgd(pgd,pgdp)	do { } while (0)
 #define set_pud(pud,pudp)	do { } while (0)
 
-
 /* Find an entry in the second-level page table.. */
 #define pmd_offset(dir, addr)	((pmd_t *)(dir))
 
@@ -338,7 +336,6 @@ static inline pte_t *pmd_page_vaddr(pmd_t pmd)
 /* we don't need complex calculations here as the pmd is folded into the pgd */
 #define pmd_addr_end(addr,end)	(end)
 
-
 #ifndef CONFIG_HIGHPTE
 #define __pte_map(pmd)		pmd_page_vaddr(*(pmd))
 #define __pte_unmap(pte)	do { } while (0)
@@ -363,18 +360,6 @@ static inline pte_t *pmd_page_vaddr(pmd_t pmd)
 #define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,pte,ext)
 #define pte_clear(mm,addr,ptep)	set_pte_ext(ptep, __pte(0), 0)
 
-#define pte_none(pte)		(!pte_val(pte))
-#define pte_present(pte)	(pte_val(pte) & L_PTE_PRESENT)
-#define pte_write(pte)		(!(pte_val(pte) & L_PTE_RDONLY))
-#define pte_dirty(pte)		(pte_val(pte) & L_PTE_DIRTY)
-#define pte_young(pte)		(pte_val(pte) & L_PTE_YOUNG)
-#define pte_exec(pte)		(!(pte_val(pte) & L_PTE_XN))
-#define pte_special(pte)	(0)
-
-#define pte_present_user(pte) \
-	((pte_val(pte) & (L_PTE_PRESENT | L_PTE_USER)) == \
-	 (L_PTE_PRESENT | L_PTE_USER))
-
 #if __LINUX_ARM_ARCH__ < 6
 static inline void __sync_icache_dcache(pte_t pteval)
 {
@@ -386,16 +371,26 @@ extern void __sync_icache_dcache(pte_t pteval);
 static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
 			      pte_t *ptep, pte_t pteval)
 {
-	unsigned long ext = 0;
-
-	if (addr < TASK_SIZE && pte_present_user(pteval)) {
+	if (addr >= TASK_SIZE)
+		set_pte_ext(ptep, pteval, 0);
+	else {
 		__sync_icache_dcache(pteval);
-		ext |= PTE_EXT_NG;
+		set_pte_ext(ptep, pteval, PTE_EXT_NG);
 	}
-
-	set_pte_ext(ptep, pteval, ext);
 }
 
+#define pte_none(pte)		(!pte_val(pte))
+#define pte_present(pte)	(pte_val(pte) & L_PTE_PRESENT)
+#define pte_write(pte)		(!(pte_val(pte) & L_PTE_RDONLY))
+#define pte_dirty(pte)		(pte_val(pte) & L_PTE_DIRTY)
+#define pte_young(pte)		(pte_val(pte) & L_PTE_YOUNG)
+#define pte_exec(pte)		(!(pte_val(pte) & L_PTE_XN))
+#define pte_special(pte)	(0)
+
+#define pte_present_user(pte) \
+	((pte_val(pte) & (L_PTE_PRESENT | L_PTE_USER)) == \
+	 (L_PTE_PRESENT | L_PTE_USER))
+
 #define PTE_BIT_FUNC(fn,op) \
 static inline pte_t pte_##fn(pte_t pte) { pte_val(pte) op; return pte; }
 
@@ -421,13 +416,13 @@ static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
  *
  *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
  *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
- *   <--------------- offset ----------------------> < type -> 0 0 0
+ *   <--------------- offset --------------------> <- type --> 0 0 0
  *
- * This gives us up to 31 swap files and 64GB per swap file.  Note that
+ * This gives us up to 63 swap files and 32GB per swap file.  Note that
  * the offset field is always non-zero.
  */
 #define __SWP_TYPE_SHIFT	3
-#define __SWP_TYPE_BITS		5
+#define __SWP_TYPE_BITS		6
 #define __SWP_TYPE_MASK		((1 << __SWP_TYPE_BITS) - 1)
 #define __SWP_OFFSET_SHIFT	(__SWP_TYPE_BITS + __SWP_TYPE_SHIFT)
 
diff --git a/arch/arm/include/asm/signal.h b/arch/arm/include/asm/signal.h
index 559ee24..bd3a402 100644
--- a/arch/arm/include/asm/signal.h
+++ b/arch/arm/include/asm/signal.h
@@ -78,7 +78,7 @@ typedef unsigned long sigset_t;
  * SA_NOCLDSTOP		flag to turn off SIGCHLD when children stop.
  * SA_NOCLDWAIT		flag on SIGCHLD to inhibit zombies.
  * SA_SIGINFO		deliver the signal with SIGINFO structs
- * SA_THIRTYTWO		delivers the signal in 32-bit mode, even if the task 
+ * SA_THIRTYTWO		delivers the signal in 32-bit mode, even if the task
  *			is running in 26-bit.
  * SA_ONSTACK		allows alternate signal stacks (see sigaltstack(2)).
  * SA_RESTART		flag to get restarting signals (which were the default long ago)
@@ -101,8 +101,7 @@ typedef unsigned long sigset_t;
 #define SA_NOMASK	SA_NODEFER
 #define SA_ONESHOT	SA_RESETHAND
 
-
-/* 
+/*
  * sigaltstack controls
  */
 #define SS_ONSTACK	1
@@ -127,7 +126,6 @@ struct sigaction {
 	__sigrestore_t sa_restorer;
 	sigset_t sa_mask;		/* mask last for extensibility */
 };
-#define __ARCH_HAS_SA_RESTORER
 
 struct k_sigaction {
 	struct sigaction sa;
diff --git a/arch/arm/include/asm/tlb.h b/arch/arm/include/asm/tlb.h
index 0504364..92d8e7d 100644
--- a/arch/arm/include/asm/tlb.h
+++ b/arch/arm/include/asm/tlb.h
@@ -33,18 +33,6 @@
 #include <asm/pgalloc.h>
 #include <asm/tlbflush.h>
 
-/*
- * We need to delay page freeing for SMP as other CPUs can access pages
- * which have been removed but not yet had their TLB entries invalidated.
- * Also, as ARMv7 speculative prefetch can drag new entries into the TLB,
- * we need to apply this same delaying tactic to ensure correct operation.
- */
-#if defined(CONFIG_SMP) || defined(CONFIG_CPU_32v7)
-#define tlb_fast_mode(tlb)	0
-#else
-#define tlb_fast_mode(tlb)	1
-#endif
-
 #define MMU_GATHER_BUNDLE	8
 
 /*
@@ -112,12 +100,10 @@ static inline void __tlb_alloc_page(struct mmu_gather *tlb)
 static inline void tlb_flush_mmu(struct mmu_gather *tlb)
 {
 	tlb_flush(tlb);
-	if (!tlb_fast_mode(tlb)) {
-		free_pages_and_swap_cache(tlb->pages, tlb->nr);
-		tlb->nr = 0;
-		if (tlb->pages == tlb->local)
-			__tlb_alloc_page(tlb);
-	}
+	free_pages_and_swap_cache(tlb->pages, tlb->nr);
+	tlb->nr = 0;
+	if (tlb->pages == tlb->local)
+		__tlb_alloc_page(tlb);
 }
 
 static inline void
@@ -178,11 +164,6 @@ tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)
 
 static inline int __tlb_remove_page(struct mmu_gather *tlb, struct page *page)
 {
-	if (tlb_fast_mode(tlb)) {
-		free_page_and_swap_cache(page);
-		return 1; /* avoid calling tlb_flush_mmu */
-	}
-
 	tlb->pages[tlb->nr++] = page;
 	VM_BUG_ON(tlb->nr > tlb->max);
 	return tlb->max - tlb->nr;
diff --git a/arch/arm/kernel/armksyms.c b/arch/arm/kernel/armksyms.c
index acca35a..ac96ebf 100644
--- a/arch/arm/kernel/armksyms.c
+++ b/arch/arm/kernel/armksyms.c
@@ -49,7 +49,6 @@ extern void __aeabi_ulcmp(void);
 
 extern void fpundefinstr(void);
 
-
 EXPORT_SYMBOL(__backtrace);
 
 	/* platform dependent support */
@@ -112,9 +111,6 @@ EXPORT_SYMBOL(__put_user_4);
 EXPORT_SYMBOL(__put_user_8);
 #endif
 
-	/* crypto hash */
-EXPORT_SYMBOL(sha_transform);
-
 	/* gcc lib functions */
 EXPORT_SYMBOL(__ashldi3);
 EXPORT_SYMBOL(__ashrdi3);
diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index 75373a9..a08032f 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -740,8 +740,6 @@ perf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)
 {
 	struct frame_tail __user *tail;
 
-
-	perf_callchain_store(entry, regs->ARM_pc);
 	tail = (struct frame_tail __user *)regs->ARM_fp - 1;
 
 	while ((entry->nr < PERF_MAX_STACK_DEPTH) &&
diff --git a/arch/arm/kernel/swp_emulate.c b/arch/arm/kernel/swp_emulate.c
index 0951a32..40ee7e5 100644
--- a/arch/arm/kernel/swp_emulate.c
+++ b/arch/arm/kernel/swp_emulate.c
@@ -108,12 +108,10 @@ static void set_segfault(struct pt_regs *regs, unsigned long addr)
 {
 	siginfo_t info;
 
-	down_read(&current->mm->mmap_sem);
 	if (find_vma(current->mm, addr) == NULL)
 		info.si_code = SEGV_MAPERR;
 	else
 		info.si_code = SEGV_ACCERR;
-	up_read(&current->mm->mmap_sem);
 
 	info.si_signo = SIGSEGV;
 	info.si_errno = 0;
diff --git a/arch/arm/mach-dove/include/mach/pm.h b/arch/arm/mach-dove/include/mach/pm.h
index 11799c3..3ad9f94 100644
--- a/arch/arm/mach-dove/include/mach/pm.h
+++ b/arch/arm/mach-dove/include/mach/pm.h
@@ -45,7 +45,7 @@ static inline int pmu_to_irq(int pin)
 
 static inline int irq_to_pmu(int irq)
 {
-	if (IRQ_DOVE_PMU_START <= irq && irq < NR_IRQS)
+	if (IRQ_DOVE_PMU_START < irq && irq < NR_IRQS)
 		return irq - IRQ_DOVE_PMU_START;
 
 	return -EINVAL;
diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 9f2fd10..f07fd16 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -61,20 +61,8 @@ static void pmu_irq_ack(struct irq_data *d)
 	int pin = irq_to_pmu(d->irq);
 	u32 u;
 
-	/*
-	 * The PMU mask register is not RW0C: it is RW.  This means that
-	 * the bits take whatever value is written to them; if you write
-	 * a '1', you will set the interrupt.
-	 *
-	 * Unfortunately this means there is NO race free way to clear
-	 * these interrupts.
-	 *
-	 * So, let's structure the code so that the window is as small as
-	 * possible.
-	 */
 	u = ~(1 << (pin & 31));
-	u &= readl_relaxed(PMU_INTERRUPT_CAUSE);
-	writel_relaxed(u, PMU_INTERRUPT_CAUSE);
+	writel(u, PMU_INTERRUPT_CAUSE);
 }
 
 static struct irq_chip pmu_irq_chip = {
diff --git a/arch/arm/mach-kirkwood/ts219-setup.c b/arch/arm/mach-kirkwood/ts219-setup.c
index eb1a7ba..68f32f2 100644
--- a/arch/arm/mach-kirkwood/ts219-setup.c
+++ b/arch/arm/mach-kirkwood/ts219-setup.c
@@ -124,7 +124,7 @@ static void __init qnap_ts219_init(void)
 static int __init ts219_pci_init(void)
 {
 	if (machine_is_ts219())
-		kirkwood_pcie_init(KW_PCIE1 | KW_PCIE0);
+		kirkwood_pcie_init(KW_PCIE0);
 
 	return 0;
 }
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 629382b..8a83a3a 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -67,7 +67,6 @@ obj-$(CONFIG_ARCH_OMAP4)		+= mux44xx.o
 
 # SMS/SDRC
 obj-$(CONFIG_ARCH_OMAP2)		+= sdrc2xxx.o
-# obj-$(CONFIG_ARCH_OMAP3)		+= sdrc3xxx.o
 
 # OPP table initialization
 ifeq ($(CONFIG_PM_OPP),y)
diff --git a/arch/arm/mach-omap2/board-omap4panda.c b/arch/arm/mach-omap2/board-omap4panda.c
index e8452f6..674f658 100644
--- a/arch/arm/mach-omap2/board-omap4panda.c
+++ b/arch/arm/mach-omap2/board-omap4panda.c
@@ -670,6 +670,7 @@ static void omap4_panda_hdmi_mux_init(void)
 			OMAP_PIN_INPUT_PULLUP);
 	/* PAD0_HDMI_DDC_SCL_PAD1_HDMI_DDC_SDA */
 	omap_mux_init_signal("hdmi_ddc_scl.hdmi_ddc_scl",
+>>>>>>> refs/remotes/Cyanogenmod_P3100/cm-10.2
 			OMAP_PIN_INPUT_PULLUP);
 	omap_mux_init_signal("hdmi_ddc_sda.hdmi_ddc_sda",
 			OMAP_PIN_INPUT_PULLUP);
@@ -688,6 +689,10 @@ static void omap4_panda_hdmi_mux_init(void)
 		pr_err("%s: Cannot request HDMI GPIOs %x \n", __func__, status);
 }
 
+static struct omap_dss_hdmi_data omap4_panda_hdmi_data = {
+	.hpd_gpio = HDMI_GPIO_HPD,
+};
+
 static struct omap_dss_device  omap4_panda_hdmi_device = {
 	.name = "hdmi",
 	.driver_name = "hdmi_panel",
@@ -703,6 +708,7 @@ static struct omap_dss_device  omap4_panda_hdmi_device = {
 	},
 	.hpd_gpio = HDMI_GPIO_HPD,
 	.channel = OMAP_DSS_CHANNEL_DIGIT,
+	.data = &omap4_panda_hdmi_data,
 };
 
 static struct omap_dss_device *omap4_panda_dss_devices[] = {
@@ -743,6 +749,10 @@ void omap4_panda_display_init(void)
 
 	omap4_panda_hdmi_mux_init();
 	omap_display_init(&omap4_panda_dss_data);
+
+	omap_mux_init_gpio(HDMI_GPIO_LS_OE, OMAP_PIN_OUTPUT);
+	omap_mux_init_gpio(HDMI_GPIO_CT_CP_HPD, OMAP_PIN_OUTPUT);
+	omap_mux_init_gpio(HDMI_GPIO_HPD, OMAP_PIN_INPUT_PULLDOWN);
 }
 
 
diff --git a/arch/arm/mach-omap2/board-rx51-peripherals.c b/arch/arm/mach-omap2/board-rx51-peripherals.c
index cbc67a3..c7761ce 100644
--- a/arch/arm/mach-omap2/board-rx51-peripherals.c
+++ b/arch/arm/mach-omap2/board-rx51-peripherals.c
@@ -56,7 +56,7 @@
 
 #define RX51_USB_TRANSCEIVER_RST_GPIO	67
 
-/* List all SPI devices here. Note that the list/probe order seems to matter! */
+/* list all spi devices here */
 enum {
 	RX51_SPI_WL1251,
 	RX51_SPI_MIPID,		/* LCD panel */
diff --git a/arch/arm/mach-omap2/clock.c b/arch/arm/mach-omap2/clock.c
index ed5089b..2311d17 100644
--- a/arch/arm/mach-omap2/clock.c
+++ b/arch/arm/mach-omap2/clock.c
@@ -98,12 +98,7 @@ void omap2_init_clk_clkdm(struct clk *clk)
 
 	clkdm = clkdm_lookup(clk->clkdm_name);
 	if (clkdm) {
-		pr_debug("clock: associated clk %s to clkdm %s\n",
-			 clk->name, clk->clkdm_name);
 		clk->clkdm = clkdm;
-	} else {
-		pr_debug("clock: could not associate clk %s to "
-			 "clkdm %s\n", clk->name, clk->clkdm_name);
 	}
 }
 
@@ -281,15 +276,11 @@ void omap2_clk_disable(struct clk *clk)
 		return;
 	}
 
-	pr_debug("clock: %s: decrementing usecount\n", clk->name);
-
 	clk->usecount--;
 
 	if (clk->usecount > 0)
 		return;
 
-	pr_debug("clock: %s: disabling in hardware\n", clk->name);
-
 	if (clk->ops && clk->ops->disable) {
 		trace_clock_disable(clk->name, 0, smp_processor_id());
 		clk->ops->disable(clk);
@@ -317,24 +308,16 @@ int omap2_clk_enable(struct clk *clk)
 {
 	int ret;
 
-	pr_debug("clock: %s: incrementing usecount\n", clk->name);
-
 	/* Sometimes, it fails to enable dss interface clock,
 	 * due to usecount mismatch, and it causes l3 bus error
 	 * because kernel tries to access dss register without interface clock.
 	 * Until fix the issue, adds below log to debug.
 	 */
-	if (!strncmp(clk->name, "dss_fck", 7))
-		pr_info("%s: dss interface clock usecount = %d\n",
-						__func__, clk->usecount);
-
 	clk->usecount++;
 
 	if (clk->usecount > 1)
 		return 0;
 
-	pr_debug("clock: %s: enabling in hardware\n", clk->name);
-
 	if (clk->parent) {
 		ret = omap2_clk_enable(clk->parent);
 		if (ret) {
@@ -357,8 +340,7 @@ int omap2_clk_enable(struct clk *clk)
 		trace_clock_enable(clk->name, 1, smp_processor_id());
 		ret = clk->ops->enable(clk);
 		if (ret) {
-			WARN(1, "clock: %s: could not enable: %d\n",
-			     clk->name, ret);
+			WARN(1, "clock: %s: could not enable: %d\n", clk->name, ret);
 			goto oce_err3;
 		}
 	}
@@ -417,8 +399,6 @@ int omap2_clk_set_rate(struct clk *clk, unsigned long rate)
 {
 	int ret = -EINVAL;
 
-	pr_debug("clock: set_rate for clock %s to rate %ld\n", clk->name, rate);
-
 	/* dpll_ck, core_ck, virt_prcm_set; plus all clksel clocks */
 	if (clk->set_rate) {
 		trace_clock_set_rate(clk->name, rate, smp_processor_id());
@@ -472,7 +452,6 @@ void omap2_clk_disable_unused(struct clk *clk)
 	if ((regval32 & (1 << clk->enable_bit)) == v)
 		return;
 
-	pr_debug("Disabling unused clock \"%s\"\n", clk->name);
 	if (cpu_is_omap34xx()) {
 		omap2_clk_enable(clk);
 		omap2_clk_disable(clk);
@@ -559,12 +538,6 @@ void __init omap2_clk_print_new_rates(const char *hfclkin_ck_name,
 
 	hfclkin_rate = clk_get_rate(hfclkin_ck);
 
-	pr_info("Switched to new clocking rate (Crystal/Core/MPU): "
-		"%ld.%01ld/%ld/%ld MHz\n",
-		(hfclkin_rate / 1000000),
-		((hfclkin_rate / 100000) % 10),
-		(clk_get_rate(core_ck) / 1000000),
-		(clk_get_rate(mpu_ck) / 1000000));
 }
 
 /* Common data */
@@ -583,4 +556,3 @@ struct clk_functions omap2_clk_functions = {
 	.clk_exit_cpufreq_table	= omap2_clk_exit_cpufreq_table,
 #endif
 };
-
diff --git a/arch/arm/mach-omap2/control.h b/arch/arm/mach-omap2/control.h
index f688010..23937f0 100644
--- a/arch/arm/mach-omap2/control.h
+++ b/arch/arm/mach-omap2/control.h
@@ -195,6 +195,7 @@
 #define OMAP44XX_CONTROL_FUSE_MPU_OPPTURBO	0x246
 #define OMAP44XX_CONTROL_FUSE_MPU_OPPNITRO	0x249
 #define OMAP44XX_CONTROL_FUSE_MPU_OPPNITROSB	0x24C
+#define OMAP44XX_CONTROL_FUSE_MPU_OPPSUPERSB	0x24F
 #define OMAP44XX_CONTROL_FUSE_CORE_OPP50	0x254
 #define OMAP44XX_CONTROL_FUSE_CORE_OPP100	0x257
 #define OMAP44XX_CONTROL_FUSE_CORE_OPP100OV	0x25A
@@ -374,7 +375,6 @@
 #define		FEAT_NEON		0
 #define		FEAT_NEON_NONE		1
 
-
 #ifndef __ASSEMBLY__
 #ifdef CONFIG_ARCH_OMAP2PLUS
 extern void __iomem *omap_ctrl_base_get(void);
@@ -432,4 +432,3 @@ extern int omap3_ctrl_save_padconf(void);
 #endif	/* __ASSEMBLY__ */
 
 #endif /* __ARCH_ARM_MACH_OMAP2_CONTROL_H */
-
diff --git a/arch/arm/mach-omap2/dpll44xx.c b/arch/arm/mach-omap2/dpll44xx.c
index 96896d1..583cd6e 100644
--- a/arch/arm/mach-omap2/dpll44xx.c
+++ b/arch/arm/mach-omap2/dpll44xx.c
@@ -230,6 +230,7 @@ int omap4_prcm_freq_update(void)
 /* Use a very high retry count - we should not hit this condition */
 #define MAX_DPLL_WAIT_TRIES	1000000
 
+#define OMAP_1_9GHz	1900000000
 #define OMAP_1_5GHz	1500000000
 #define OMAP_1_2GHz	1200000000
 #define OMAP_1GHz	1000000000
diff --git a/arch/arm/mach-omap2/omap4-common.c b/arch/arm/mach-omap2/omap4-common.c
index dc55dfb..f102fff 100644
--- a/arch/arm/mach-omap2/omap4-common.c
+++ b/arch/arm/mach-omap2/omap4-common.c
@@ -162,41 +162,33 @@ static int __init omap_l2_cache_init(void)
 	u32 lockdown = 0;
 	bool mpu_prefetch_disable_errata = false;
 
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
-
 	/*
 	 * To avoid code running on other OMAPs in
 	 * multi-omap builds
 	 */
 	if (!cpu_is_omap44xx())
 		return -ENODEV;
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 #ifdef CONFIG_OMAP_ALLOW_OSWR
 	if (omap_rev() == OMAP4460_REV_ES1_0)
 		mpu_prefetch_disable_errata = true;
 #endif
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	/* Static mapping, never released */
 	l2cache_base = ioremap(OMAP44XX_L2CACHE_BASE, SZ_4K);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 	if (WARN_ON(!l2cache_base))
 		return -ENODEV;
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 	/*
 	 * 16-way associativity, parity disabled
 	 * Way size - 32KB (es1.0)
 	 * Way size - 64KB (es2.0 +)
 	 */
 	aux_ctrl = readl_relaxed(l2cache_base + L2X0_AUX_CTRL);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	if (omap_rev() == OMAP4430_REV_ES1_0) {
 		aux_ctrl |= 0x2 << L2X0_AUX_CTRL_WAY_SIZE_SHIFT;
 		goto skip_aux_por_api;
 	}
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	/*
 	 * Drop instruction prefetch hint since it degrades the
@@ -205,18 +197,14 @@ static int __init omap_l2_cache_init(void)
 	aux_ctrl |= ((0x3 << L2X0_AUX_CTRL_WAY_SIZE_SHIFT) |
 		(1 << L2X0_AUX_CTRL_SHARE_OVERRIDE_SHIFT) |
 		(1 << L2X0_AUX_CTRL_EARLY_BRESP_SHIFT));
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	if (!mpu_prefetch_disable_errata)
 		aux_ctrl |= (1 << L2X0_AUX_CTRL_DATA_PREFETCH_SHIFT);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	omap_smc1(0x109, aux_ctrl);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	/* Setup POR Control register */
 	por_ctrl = readl_relaxed(l2cache_base + L2X0_PREFETCH_CTRL);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	/*
 	 * Double linefill is available only on OMAP4460 L2X0.
@@ -224,12 +212,10 @@ static int __init omap_l2_cache_init(void)
 	 * on all devices
 	 */
 	por_ctrl &= ~(1 << L2X0_PREFETCH_DOUBLE_LINEFILL_SHIFT);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 	if (!mpu_prefetch_disable_errata) {
 		por_ctrl &= ~L2X0_POR_OFFSET_MASK;
 		por_ctrl |= L2X0_POR_OFFSET_VALUE;
 	}
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	/* Set POR through PPA service only in EMU/HS devices */
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP)
@@ -237,8 +223,6 @@ static int __init omap_l2_cache_init(void)
 				por_ctrl, 0, 0, 0);
 	else if (omap_rev() >= OMAP4430_REV_ES2_2)
 		omap_smc1(0x113, por_ctrl);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
-
 
 	/*
 	 * FIXME: Temporary WA for OMAP4460 stability issue.
@@ -248,22 +232,16 @@ static int __init omap_l2_cache_init(void)
 	if (omap_rev() == OMAP4460_REV_ES1_0) {
 		lockdown = 0xa5a5;
 		writel_relaxed(lockdown, l2cache_base + L2X0_LOCKDOWN_WAY_D0);
-		printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 		writel_relaxed(lockdown, l2cache_base + L2X0_LOCKDOWN_WAY_D1);
-		printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 		writel_relaxed(lockdown, l2cache_base + L2X0_LOCKDOWN_WAY_I0);
-		printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 		writel_relaxed(lockdown, l2cache_base + L2X0_LOCKDOWN_WAY_I1);
 	}
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 skip_aux_por_api:
 	/* Enable PL310 L2 Cache controller */
 	omap_smc1(0x102, 0x1);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	l2x0_init(l2cache_base, aux_ctrl, L2X0_AUX_CTRL_MASK);
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	/*
 	 * Override default outer_cache.disable with a OMAP4
@@ -271,7 +249,6 @@ skip_aux_por_api:
 	*/
 	outer_cache.disable = omap4_l2x0_disable;
 	outer_cache.set_debug = omap4_l2x0_set_debug;
-	printk(KERN_INFO "===[%s(%d)]===\n", __func__, __LINE__);
 
 	return 0;
 }
diff --git a/arch/arm/mach-omap2/omap4_trim_quirks.c b/arch/arm/mach-omap2/omap4_trim_quirks.c
index 8ee3df6..e93892c 100644
--- a/arch/arm/mach-omap2/omap4_trim_quirks.c
+++ b/arch/arm/mach-omap2/omap4_trim_quirks.c
@@ -77,7 +77,7 @@ int omap4_ldo_trim_configure(void)
 			OMAP4_CTRL_MODULE_PAD_CORE_CONTROL_EFUSE_2);
 	}
 
-	/* Required for DPLL_MPU to lock at 2.4 GHz */
+	/* Required for DPLL_MPU to lock */
 	if (dpll_trim_override)
 		omap_ctrl_writel(0x29, OMAP4_CTRL_MODULE_CORE_DPLL_NWELL_TRIM_0);
 
diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 144a27a..cc6e720 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -551,10 +551,6 @@ static int _init_main_clk(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
-	if (!oh->_clk->clkdm)
-		pr_warning("omap_hwmod: %s: missing clockdomain for %s.\n",
-			   oh->main_clk, oh->_clk->name);
-
 	return ret;
 }
 
@@ -1217,12 +1213,6 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 				   & SYSC_TYPE2_SOFTRESET_MASK),
 				  MAX_MODULE_SOFTRESET_WAIT, c);
 
-	if (c == MAX_MODULE_SOFTRESET_WAIT)
-		pr_warning("omap_hwmod: %s: softreset failed (waited %d usec)\n",
-			   oh->name, MAX_MODULE_SOFTRESET_WAIT);
-	else
-		pr_debug("omap_hwmod: %s: softreset in %d usec\n", oh->name, c);
-
 	/*
 	 * XXX add _HWMOD_STATE_WEDGED for modules that don't come back from
 	 * _wait_target_ready() or _reset()
@@ -1646,6 +1636,9 @@ void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)
  */
 int omap_hwmod_softreset(struct omap_hwmod *oh)
 {
+	u32 v;
+	int ret;
+
 	if (!oh || !(oh->_sysc_cache))
 		return -EINVAL;
 
@@ -1777,9 +1770,6 @@ static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
 		return 0;
 
 	oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
-	if (!oh->_mpu_rt_va)
-		pr_warning("omap_hwmod: %s found no _mpu_rt_va for %s\n",
-				__func__, oh->name);
 
 	return 0;
 }
@@ -1798,8 +1788,6 @@ int __init omap_hwmod_setup_one(const char *oh_name)
 	struct omap_hwmod *oh;
 	int r;
 
-	pr_debug("omap_hwmod: %s: %s\n", oh_name, __func__);
-
 	if (!mpu_oh) {
 		pr_err("omap_hwmod: %s: cannot setup_one: MPU initiator hwmod %s not yet registered\n",
 		       oh_name, MPU_INITIATOR_NAME);
diff --git a/arch/arm/mach-omap2/omap_hwmod_44xx_data.c b/arch/arm/mach-omap2/omap_hwmod_44xx_data.c
index 396d0da..b498744 100644
--- a/arch/arm/mach-omap2/omap_hwmod_44xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_44xx_data.c
@@ -4940,13 +4940,10 @@ static struct omap_hwmod_class omap44xx_timer_hwmod_class = {
 	.rev	= OMAP_TIMER_IP_VERSION_2,
 };
 
-/* commenting because we r not using it currenly */
-#if 0
 /* secure timer can assign this to .dev_attr field */
 static struct omap_secure_timer_dev_attr secure_timer_dev_attr = {
 	.is_secure_timer        = true,
 };
-#endif
 
 /* timer1 */
 static struct omap_hwmod omap44xx_timer1_hwmod;
diff --git a/arch/arm/mach-omap2/omap_phy_tune.c b/arch/arm/mach-omap2/omap_phy_tune.c
index 74f75bd..9de74db 100644
--- a/arch/arm/mach-omap2/omap_phy_tune.c
+++ b/arch/arm/mach-omap2/omap_phy_tune.c
@@ -28,275 +28,45 @@
 #include <plat/usb.h>
 #include "control.h"
 
-#define OCP2SCP_TIMING_OFFSET 0xAB018
-#define USB2PHYCM_TRIM_OFFSET 0xAB0B8
-#define TREMINATIOM_CONTROL 0xAB080
-#define USBPHY_ANA_CONFIG2 0xAB0D4
-#define USBPHY_RX_CALIB 0xAB084
-
-#define swcap_trim_check_offset			(1<<0)
-#define bg_trim_check_offset				(1<<1)
-#define rterm_rmx_check_offset			(1<<2)
-#define rterm_cal_check_offset			(1<<3)
-#define sq_off_code_dac3_check_offset	(1<<4)
-
-struct omap_phy_tune {
-	u32		swcap_trim_cal;
-	u32		bg_trim_cal;
-	u32		rterm_rmx_cal;
-	u32		rterm_cal;
-	u32		sq_off_code_dac3;
-	u32		cal_check;
-};
-
 static void __iomem *ctrl_base;
 static struct otg_transceiver *transceiver;
-static struct omap_phy_tune phy_tune;
-
-/* commenting unused functions */
-#if 0
-static void omap4430_phy_init_for_eyediagram_ref_gen_test(u32 ref_gen_test)
-{
-	u32 read_val = 0;
-	u32 out_val = 0;
-
-	transceiver = otg_get_transceiver();
-
-	/* If clock is disabled, enable clock */
-	if (!otg_is_active(transceiver))
-		otg_set_suspend(transceiver, 0);
-
-	ctrl_base = ioremap(OMAP443X_SCM_BASE, SZ_1M);
-
-	/* USBPHY_ANA_CONFIG2 setting */
-	read_val = __raw_readl(ctrl_base + USBPHY_ANA_CONFIG2);
-	out_val = read_val;
-	out_val &= ~(0x7<<24);
-	out_val |= (ref_gen_test<<24);
-	__raw_writel(out_val, ctrl_base + USBPHY_ANA_CONFIG2);
-	pr_info("%s, USBPHY_ANA_CONFIG2 = 0x%x , 0x%x\n",
-		__func__,
-		read_val,
-		__raw_readl(ctrl_base + USBPHY_ANA_CONFIG2));
-
-
-#ifndef CONFIG_USB_SWITCH_FSA9480
-	iounmap(ctrl_base);
-#endif	/* CONFIG_USB_SWITCH_FSA9480 */
-}
-#endif
-
-static void omap4460_phy_tuning_for_eyediagram(
-	int rterm_cal_offset, int sq_off_code_dac3_offset, u32 hs_code_sel)
-{
-	u32 read_val = 0;
-	u32 rterm_cal = 0;
-	u32 sq_off_code_dac3 = 0;
-
-	pr_info("%s, rterm_cal=%d sq_off_code_dac3=%d hs_code_sel=%d\n",
-			__func__, rterm_cal_offset,
-				sq_off_code_dac3_offset, hs_code_sel);
-
-	transceiver = otg_get_transceiver();
-
-	/* If clock is disabled, enable clock */
-	if (!otg_is_active(transceiver))
-		otg_set_suspend(transceiver, 0);
-
-	ctrl_base = ioremap(OMAP443X_SCM_BASE, SZ_1M);
-
-	if (__raw_readl(ctrl_base + OCP2SCP_TIMING_OFFSET) != 0x0000000F)
-		__raw_writel(0x00000000F, ctrl_base + OCP2SCP_TIMING_OFFSET);
-
-	read_val = __raw_readl(ctrl_base + TREMINATIOM_CONTROL);
-	pr_info("%s, prev TREMINATIOM_CONTROL=0x%x\n", __func__, read_val);
-
-	if (!(phy_tune.cal_check & rterm_cal_check_offset)) {
-		phy_tune.rterm_rmx_cal = (read_val & 0x7F);
-		phy_tune.cal_check |= rterm_cal_check_offset;
-	}
-
-	if (rterm_cal_offset) {
-
-		if ((int)(phy_tune.rterm_rmx_cal + rterm_cal_offset) < 0)
-			rterm_cal = 0;
-		else if ((int)(phy_tune.rterm_rmx_cal
-				+ rterm_cal_offset) > 0x7F)
-			rterm_cal = 0x7F;
-		else
-			rterm_cal = phy_tune.rterm_rmx_cal + rterm_cal_offset;
 
-		read_val &= ~(0x7F);
-		read_val |= rterm_cal;
-		read_val |= (0x1<<7); /* USE_RTERM_CAL_REG = 1 */
-		read_val |= (0x1<<29); /* ALWAYS_UPDATE = 1 */
-		read_val |= (0x1<<9); /* RESTART_RTERM_CAL = 1 */
-	} else {
-		read_val &= ~(0x1<<7); /* USE_RTERM_RMX_REG = 0 */
-		read_val &= ~(0x1<<29); /* ALWAYS_UPDATE = 0 */
-		read_val &= ~(0x1<<9); /* RESTART_RTERM_CAL = 0 */
-	}
-
-	read_val &= ~(0x7<<11);
-
-	if (hs_code_sel > 0x7)
-		hs_code_sel = 0x7;
-	else if (hs_code_sel < 0)
-		hs_code_sel = 0;
-
-	read_val |= (hs_code_sel<<11);
-
-	__raw_writel(read_val, ctrl_base + TREMINATIOM_CONTROL);
-
-	read_val = __raw_readl(ctrl_base + USBPHY_RX_CALIB);
-	pr_info("%s, prev USBPHY_RX_CALIB=0x%x\n", __func__, read_val);
-
-	if (!(phy_tune.cal_check & sq_off_code_dac3_check_offset)) {
-		phy_tune.sq_off_code_dac3 = (read_val & (0x1F<<3))>>3;
-		phy_tune.cal_check |= sq_off_code_dac3_check_offset;
-	}
-
-	if (sq_off_code_dac3_offset) {
-
-		if ((int)(phy_tune.sq_off_code_dac3
-				+ sq_off_code_dac3_offset) < 0)
-			sq_off_code_dac3 = 0;
-		else if ((int)(phy_tune.sq_off_code_dac3
-				+ sq_off_code_dac3_offset) > 0x1F)
-			sq_off_code_dac3 = 0x1F;
-		else
-			sq_off_code_dac3 =
-				phy_tune.sq_off_code_dac3
-					+ sq_off_code_dac3_offset;
-
-		read_val &= ~(0x1F<<3);
-		read_val |= (sq_off_code_dac3<<3);
-		read_val |= (0x1<<8); /* USE_SQ_OFF_DAC3 = 1 */
-	} else
-		read_val &= ~(0x1<<8); /* USE_SQ_OFF_DAC3 = 0 */
-
-	__raw_writel(read_val, ctrl_base + USBPHY_RX_CALIB);
-
-	read_val = __raw_readl(ctrl_base + TREMINATIOM_CONTROL);
-	pr_info("%s, TREMINATIOM_CONTROL=0x%x\n", __func__, read_val);
-	read_val = __raw_readl(ctrl_base + USBPHY_RX_CALIB);
-	pr_info("%s, USBPHY_RX_CALIB=0x%x\n", __func__, read_val);
-
-	iounmap(ctrl_base);
-}
+#define OCP2SCP_TIMING_OFFSET 0xAB018
+#define USB2PHYCM_TRIM_OFFSET 0xAB0B8
 
-static void omap4430_phy_init_for_eyediagram(
-	int swcap_trim_offset, int bg_trim_offset, int rterm_rmx_offset)
+static void omap4430_phy_init_for_eyediagram(u32 swcap_trim_offset)
 {
 	u32 read_val = 0;
 	u32 swcap_trim = 0;
-	u32 bg_trim = 0;
-	u32 rterm_rmx = 0;
-
 	transceiver = otg_get_transceiver();
 
 	/* If clock is disabled, enable clock */
 	if (!otg_is_active(transceiver))
 		otg_set_suspend(transceiver, 0);
 
-	pr_info("%s, swcap_trim=%d bg_trim=%d rterm_rmx=%d\n",
-		__func__, swcap_trim_offset, bg_trim_offset, rterm_rmx_offset);
-
 	ctrl_base = ioremap(OMAP443X_SCM_BASE, SZ_1M);
 
 	if (__raw_readl(ctrl_base + OCP2SCP_TIMING_OFFSET) != 0x0000000F)
 		__raw_writel(0x00000000F, ctrl_base + OCP2SCP_TIMING_OFFSET);
 
 	read_val = __raw_readl(ctrl_base + USB2PHYCM_TRIM_OFFSET);
-	pr_info("%s, prev USB2PHYCM_TRIM=0x%x\n", __func__, read_val);
-
 	swcap_trim = (read_val & 0x00007F00) >> 8;
 
-	if (!(phy_tune.cal_check & swcap_trim_check_offset)) {
-		phy_tune.swcap_trim_cal = swcap_trim;
-		phy_tune.cal_check |= swcap_trim_check_offset;
-	}
-
-	if (swcap_trim_offset) {
-		if ((int)(phy_tune.swcap_trim_cal + swcap_trim_offset) < 0)
-			swcap_trim = 0;
-		else if ((int)(phy_tune.swcap_trim_cal
-			+ swcap_trim_offset) > 0x7f)
-			swcap_trim = 0x7f;
-		else
-			swcap_trim = phy_tune.swcap_trim_cal +
-			swcap_trim_offset;
+	/* 0x4E(default) + 0x22(SWCAP_TRIM_OFFSET) = 0xF0*/
+	if (swcap_trim != (0x4E + swcap_trim_offset)) {
+		swcap_trim = 0x4E + swcap_trim_offset;
 
 		read_val &= ~0x00007F00;
 		read_val |= swcap_trim << 8;
 		read_val |= 0x00008000; /* USE_SW_TRIM = 1 */
-	} else
-		read_val &= ~0x00008000; /* USE_SW_TRIM = 0 */
-
-
 
-	if (!(phy_tune.cal_check & bg_trim_check_offset)) {
-		phy_tune.bg_trim_cal = (read_val & (0x7FFF<<16))>>16;
-		phy_tune.cal_check |= bg_trim_check_offset;
+		__raw_writel(read_val, ctrl_base + USB2PHYCM_TRIM_OFFSET);
 	}
-
-	if (bg_trim_offset) {
-
-		if ((int)(phy_tune.bg_trim_cal + bg_trim_offset) < 0)
-			bg_trim = 0;
-		else if ((int)(phy_tune.bg_trim_cal + bg_trim_offset) > 0x7FFF)
-			bg_trim = 0x7FFF;
-		else
-			bg_trim = phy_tune.bg_trim_cal + bg_trim_offset;
-
-		read_val &= ~(0xFFFF<<16);
-		read_val |= bg_trim<<16;
-		read_val |= (1<<31);  /* USE_BG_TRIM = 1 */
-	} else
-		read_val &= ~(1<<31);  /* USE_BG_TRIM = 0 */
-
-	__raw_writel(read_val, ctrl_base + USB2PHYCM_TRIM_OFFSET);
-
-	read_val = __raw_readl(ctrl_base + TREMINATIOM_CONTROL);
-	pr_info("%s, prev TREMINATIOM_CONTROL=0x%x\n", __func__, read_val);
-
-	if (!(phy_tune.cal_check & rterm_rmx_check_offset)) {
-		phy_tune.rterm_rmx_cal = (read_val & (0x7F<<14))>>14;
-		phy_tune.cal_check |= rterm_rmx_check_offset;
-	}
-
-	if (rterm_rmx_offset) {
-
-		if ((int)(phy_tune.rterm_rmx_cal + rterm_rmx_offset) < 0)
-			rterm_rmx = 0;
-		else if ((int)(phy_tune.rterm_rmx_cal
-				+ rterm_rmx_offset) > 0x7F)
-			rterm_rmx = 0x7F;
-		else
-			rterm_rmx = phy_tune.rterm_rmx_cal + rterm_rmx_offset;
-
-		read_val &= ~(0x7F<<14);
-		read_val |= rterm_rmx<<14;
-		read_val |= (0x1<<21); /* USE_RTERM_RMX_REG = 1 */
-	} else
-		read_val &= ~(0x1<<21); /* USE_RTERM_RMX_REG = 0 */
-
-	__raw_writel(read_val, ctrl_base + TREMINATIOM_CONTROL);
-
-	read_val = __raw_readl(ctrl_base + USB2PHYCM_TRIM_OFFSET);
-	pr_info("%s, USB2PHYCM_TRIM=0x%x\n", __func__, read_val);
-	read_val = __raw_readl(ctrl_base + TREMINATIOM_CONTROL);
-	pr_info("%s, TREMINATIOM_CONTROL=0x%x\n", __func__, read_val);
-
+	pr_info("%s, usb swcap_trim_offset = 0x%x, USB2PHYCM_TRIM = 0x%x\n",
+		__func__,
+		swcap_trim_offset,
+		__raw_readl(ctrl_base + USB2PHYCM_TRIM_OFFSET));
 #ifndef CONFIG_USB_SWITCH_FSA9480
 	iounmap(ctrl_base);
 #endif	/* CONFIG_USB_SWITCH_FSA9480 */
 }
-
-/* commenting unused function */
-#if 0
-static void omap4430_phy_remove_for_eyediagram(void)
-{
-	iounmap(ctrl_base);
-}
-#endif
diff --git a/arch/arm/mach-omap2/omap_twl.c b/arch/arm/mach-omap2/omap_twl.c
index 836b80e..0efef77 100644
--- a/arch/arm/mach-omap2/omap_twl.c
+++ b/arch/arm/mach-omap2/omap_twl.c
@@ -75,6 +75,14 @@
 							 0x01 << 0)
 #define TWL6030_REG_VCOREx_CFG_TRANS_MODE_DESC "OFF=OFF SLEEP=OFF ACT=AUTO"
 
+#define TWL6030_REG_VCORE1_CFG_GRP			0x52
+#define TWL6030_REG_VCORE1_CFG_TRANS			0x53
+#define TWL6030_REG_VCORE2_CFG_GRP			0x58
+#define TWL6030_REG_VCORE2_CFG_TRANS			0x59
+#define TWL6030_REG_VCORE3_CFG_GRP			0x5e
+#define TWL6030_REG_VCORE3_CFG_TRANS			0x5f
+#define TWL6030_BIT_APE_GRP				BIT(0)
+
 /* Pull down control */
 #define TWL6030_REG_CFG_SMPS_PD		0xF6
 static bool is_offset_valid;
@@ -679,7 +687,6 @@ int __init omap_twl_init(void)
 		omap446x_core_pmic.cmd_reg_addr =
 			TWL6032_SMPS2_SR_CMD_REG;
 
-
 		omap443x_446x_iva_pmic.volt_reg_addr
 			= TWL6032_SMPS5_SR_VOLT_REG;
 		omap443x_446x_iva_pmic.cmd_reg_addr
diff --git a/arch/arm/mach-omap2/opp4xxx_data.c b/arch/arm/mach-omap2/opp4xxx_data.c
index 8124bae..97aa183 100644
--- a/arch/arm/mach-omap2/opp4xxx_data.c
+++ b/arch/arm/mach-omap2/opp4xxx_data.c
@@ -768,7 +768,6 @@ static struct omap_opp_def __initdata omap447x_opp_high_def_list[] = {
 	/* L3 OPP1 - OPP50 */
 	OPP_INITIALIZER("l3_main_1", "virt_l3_ck", "core", true,
 			116000000, OMAP4470_VDD_CORE_OPP50_UV),
-	/* L3 OPP2 - OPP100 is absent*/
 	/* L3 OPP2 - OPP100 */
 	OPP_INITIALIZER("l3_main_1", "virt_l3_ck", "core", true,
 			116000000, OMAP4470_VDD_CORE_OPP100H_UV),
@@ -975,15 +974,6 @@ int __init omap4_opp_init(void)
 	if (omap4_has_iva_500mhz())
 		omap4_opp_enable("iva", 500000000);
 
-	/* Enable Nitro and NitroSB MPU OPPs */
-	/*
-	if (omap4_has_mpu_1_2ghz())
-		omap4_opp_enable("mpu", 1200000000);
-	if (!trimmed)
-		pr_info("This is DPLL un-trimmed SOM. OPP is limited at 1.2 GHz\n");
-	if (omap4_has_mpu_1_5ghz() && trimmed)
-		omap4_opp_enable("mpu", 1500000000);
-	*/
 out:
 	return r;
 }
diff --git a/arch/arm/mach-omap2/pm44xx.c b/arch/arm/mach-omap2/pm44xx.c
index 7cb2a86..02cec01 100644
--- a/arch/arm/mach-omap2/pm44xx.c
+++ b/arch/arm/mach-omap2/pm44xx.c
@@ -1423,8 +1423,7 @@ static void __init omap4_pm_setup_errata(void)
 static int __init omap4_pm_init(void)
 {
 	int ret = 0;
-	struct clockdomain *l3_1_clkdm, *l4wkup, *sdma_clkdm, *l3_init_clkdm, \
-								*l3_gfx_clkdm;
+	struct clockdomain *l3_1_clkdm, *l4wkup;
 	struct clockdomain *ducati_clkdm, *l3_2_clkdm;
 	struct clockdomain *l4_per, *l4_cfg, *ivahd_clkdm;
 
@@ -1492,14 +1491,8 @@ static int __init omap4_pm_init(void)
 	l4wkup = clkdm_lookup("l4_wkup_clkdm");
 	ivahd_clkdm = clkdm_lookup("ivahd_clkdm");
 
-	sdma_clkdm = clkdm_lookup("l3_dma_clkdm");
-	l3_init_clkdm = clkdm_lookup("l3_init_clkdm");
-
-	l3_gfx_clkdm = clkdm_lookup("l3_gfx_clkdm");
-
 	if ((!mpuss_clkdm) || (!emif_clkdm) || (!l3_1_clkdm) || (!l4wkup) ||
-		(!l3_2_clkdm) || (!ducati_clkdm) || (!l4_per) || \
-						(!l4_cfg) || (!l3_gfx_clkdm))
+		(!l3_2_clkdm) || (!ducati_clkdm) || (!l4_per) || (!l4_cfg))
 		goto err2;
 
 	/* if we cannot ever enable static dependency. */
@@ -1518,7 +1511,6 @@ static int __init omap4_pm_init(void)
 		ret |= clkdm_add_wkdep(ducati_clkdm, emif_clkdm);
 		ret |= clkdm_add_wkdep(ivahd_clkdm, emif_clkdm);
 		ret |= clkdm_add_wkdep(mpuss_clkdm, l4wkup);
-		ret |= clkdm_add_wkdep(l3_gfx_clkdm, emif_clkdm);
 
 		if (ret) {
 			pr_err("Failed to add MPUSS -> L3/EMIF, DUCATI -> L3"
@@ -1551,16 +1543,6 @@ static int __init omap4_pm_init(void)
 		ret |= clkdm_add_wkdep(ducati_clkdm, l4_per);
 		ret |= clkdm_add_wkdep(ducati_clkdm, l4_cfg);
 
-		/* Adding all SDMA static dependencies and keeping
-		   only L3_2, before we clear.
-		*/
-		ret |=  clkdm_add_wkdep(sdma_clkdm, emif_clkdm);
-		ret |=  clkdm_add_wkdep(sdma_clkdm, l3_1_clkdm);
-		ret |=  clkdm_add_wkdep(sdma_clkdm, l3_init_clkdm);
-		ret |=  clkdm_add_wkdep(sdma_clkdm, l4wkup);
-		ret |=  clkdm_add_wkdep(sdma_clkdm, l4_per);
-		ret |=  clkdm_add_wkdep(sdma_clkdm, l4_cfg);
-
 		if (ret) {
 			pr_err("Failed to add MPUSS and DUCATI -> "
 			       "L4* and L3_1 wakeup dependency\n");
@@ -1568,18 +1550,6 @@ static int __init omap4_pm_init(void)
 		}
 		pr_info("OMAP4 PM: Static dependency added between"
 			" MPUSS and DUCATI <-> L4_PER/CFG and L3_1.\n");
-		/* clearing all SDMA static dependencies and keeping
-		   only L3_2.
-		*/
-		ret  =  clkdm_del_wkdep(sdma_clkdm, emif_clkdm);
-		ret |=  clkdm_del_wkdep(sdma_clkdm, l3_1_clkdm);
-		ret |=  clkdm_del_wkdep(sdma_clkdm, l3_init_clkdm);
-		ret |=  clkdm_del_wkdep(sdma_clkdm, l4wkup);
-		ret |=  clkdm_del_wkdep(sdma_clkdm, l4_per);
-		ret |=  clkdm_del_wkdep(sdma_clkdm, l4_cfg);
-
-		if (ret)
-			pr_err("Failed to Remove wkdep For SDMA\n");
 	}
 
 	(void) clkdm_for_each(clkdms_setup, NULL);
diff --git a/arch/arm/mach-omap2/remoteproc.c b/arch/arm/mach-omap2/remoteproc.c
index 8ce1425..25a2761 100644
--- a/arch/arm/mach-omap2/remoteproc.c
+++ b/arch/arm/mach-omap2/remoteproc.c
@@ -44,11 +44,11 @@ static void dump_ipu_registers(struct rproc *rproc)
 	char buf[64];
 	struct pt_regs regs;
 
-	if (!rproc->cdump1.buf)
+	if (!rproc->cdump_buf1)
 		return;
 
 	remoteproc_fill_pt_regs(&regs,
-			(struct exc_regs *)rproc->cdump1.buf);
+			(struct exc_regs *)rproc->cdump_buf1);
 
 	pr_info("REGISTER DUMP FOR REMOTEPROC %s\n", rproc->name);
 	pr_info("PC is at %08lx\n", instruction_pointer(&regs));
@@ -83,7 +83,7 @@ static void dump_dsp_registers(struct rproc *rproc)
 {
 	struct exc_dspRegs *regs;
 
-	regs = (struct exc_dspRegs *)rproc->cdump0.buf;
+	regs = (struct exc_dspRegs *)rproc->cdump_buf0;
 
 	pr_info("REGISTER DUMP FOR REMOTEPROC %s\n", rproc->name);
 	pr_info("PC is at %08x\n", regs->IRP);
@@ -183,17 +183,6 @@ static struct rproc_mem_pool *omap_rproc_get_pool(const char *name)
 	} else
 		return pool;
 
-	if (!paddr1 && !paddr2) {
-		pr_err("%s - no carveout memory is available at all\n", name);
-		return pool;
-	}
-	if (!paddr1 || !len1)
-		pr_warn("%s - static memory is unavailable: 0x%x, 0x%x\n",
-			name, paddr1, len1);
-	if (!paddr2 || !len2)
-		pr_warn("%s - carveout memory is unavailable: 0x%x, 0x%x\n",
-			name, paddr2, len2);
-
 	pool = kzalloc(sizeof(*pool), GFP_KERNEL);
 	if (pool) {
 		pool->st_base = paddr1;
diff --git a/arch/arm/mach-omap2/sec_log_buf.c b/arch/arm/mach-omap2/sec_log_buf.c
index 32ca50d..32e1a5a 100644
--- a/arch/arm/mach-omap2/sec_log_buf.c
+++ b/arch/arm/mach-omap2/sec_log_buf.c
@@ -22,7 +22,6 @@
 #include <linux/platform_device.h>
 #include <linux/proc_fs.h>
 #include <linux/uaccess.h>
-#include <linux/vmalloc.h>
 
 #include <mach/hardware.h>
 
@@ -83,13 +82,16 @@ static const unsigned int sec_log_buf_magic = 0x404C4F47;	/* @LOG */
 static char *last_log_buf;
 static unsigned int last_log_buf_size;
 
+static void __init sec_last_log_buf_reserve(void)
+{
+	last_log_buf = (char *)alloc_bootmem(s_log_buf_msk + 1);
+}
+
 static void __init sec_last_log_buf_setup(void)
 {
 	unsigned int max_size = s_log_buf_msk + 1;
 	unsigned int head;
 
-	last_log_buf = vmalloc(s_log_buf_msk + 1);
-
 	if (*s_log_buf.count > max_size) {
 		head = *s_log_buf.count & s_log_buf_msk;
 		memcpy(last_log_buf,
@@ -156,10 +158,11 @@ static int __init sec_last_log_buf_init(void)
 late_initcall(sec_last_log_buf_init);
 
 #else /* CONFIG_SAMSUNG_USE_LAST_SEC_LOG_BUF */
+#define sec_last_log_buf_reserve()
 #define sec_last_log_buf_setup()
 #endif /* CONFIG_SAMSUNG_USE_LAST_SEC_LOG_BUF */
 
-static int __init sec_log_buf_setup_early(char *str)
+static int __init sec_log_buf_setup(char *str)
 {
 	unsigned long res;
 
@@ -171,28 +174,18 @@ static int __init sec_log_buf_setup_early(char *str)
 		if (kstrtoul(++str, 16, &res))
 			goto __err;
 		sec_log_buf_start = res;
+		/* call reserve_bootmem to prevent the area accessed by
+		 * others */
+		if (reserve_bootmem
+		    (sec_log_buf_start, sec_log_buf_size, BOOTMEM_EXCLUSIVE)) {
+			pr_err("(%s): failed to reserve size %d@0x%X\n",
+			       __func__, sec_log_buf_size / 1024,
+			       sec_log_buf_start);
+			goto __err;
+		}
 	}
 
-	return 0;
-
-__err:
-	sec_log_buf_start = 0;
-	sec_log_buf_size = 0;
-	return 0;
-}
-
-/* 1st handler for 'sec_log' command-line option */
-early_param("sec_log", sec_log_buf_setup_early);
-
-void  __init sec_log_buf_reserve(void)
-{
-	if (unlikely(!sec_log_buf_start || !sec_log_buf_size))
-		return;
-
-	/* if sec_log_buf is located in lowmem area */
-	if ((sec_log_buf_start + sec_log_buf_size) <= arm_lowmem_limit)
-		return;
-
+	/* call memblock_remove to use ioremap */
 	if (memblock_remove(sec_log_buf_start, sec_log_buf_size)) {
 		pr_err("(%s): failed to remove size %d@0x%x\n",
 		       __func__, sec_log_buf_size / 1024, sec_log_buf_start);
@@ -200,52 +193,16 @@ void  __init sec_log_buf_reserve(void)
 	}
 	s_log_buf_msk = sec_log_buf_size - sec_log_buf_flag_size - 1;
 
-	return;
+	sec_last_log_buf_reserve();
+	return 1;
 
 __err:
 	sec_log_buf_start = 0;
 	sec_log_buf_size = 0;
-}
-
-static int __init sec_log_buf_reserve_late(char* str)
-{
-	/* TODO: we don't need to parse 'str' variable because it is already
-	 * translated in early_param */
-	if (unlikely(!sec_log_buf_start || !sec_log_buf_size))
-		return 0;
-
-	/* this is a safe operation because, initcall is always called later
-	 * than mdesc->reserve() call-back. */
-	if ((sec_log_buf_start + sec_log_buf_size) > arm_lowmem_limit)
-		return 0;
-
-	if (reserve_bootmem(sec_log_buf_start, sec_log_buf_size,
-			    BOOTMEM_EXCLUSIVE)) {
-		pr_err("(%s): failed to reserve size %d@0x%x\n",
-		       __func__, sec_log_buf_size / 1024, sec_log_buf_start);
-		goto __err_reserve_bootmem;
-	}
-
-	/* call memblock_remove to use ioremap */
-	if (memblock_remove(sec_log_buf_start, sec_log_buf_size)) {
-		pr_err("(%s): failed to remove size %d@0x%x\n",
-		       __func__, sec_log_buf_size / 1024, sec_log_buf_start);
-		goto __err_memblock_remove;
-	}
-	s_log_buf_msk = sec_log_buf_size - sec_log_buf_flag_size - 1;
-
-	return 0;
-
-__err_memblock_remove:
-	free_bootmem(sec_log_buf_start, sec_log_buf_size);
-__err_reserve_bootmem:
-	sec_log_buf_start = 0;
-	sec_log_buf_size = 0;
 	return 0;
 }
 
-/* 2nd handler for 'sec_log' command-line option */
-__setup("sec_log=", sec_log_buf_reserve_late);
+__setup("sec_log=", sec_log_buf_setup);
 
 static void __init sec_log_buf_create_sysfs(void)
 {
@@ -304,7 +261,6 @@ int __init sec_log_buf_init(void)
 	s_log_buf.flag = (unsigned int *)start;
 	s_log_buf.count = (unsigned int *)(start + 4);
 	s_log_buf.data = (char *)(start + sec_log_buf_flag_size);
-	s_log_buf.phys_data = sec_log_buf_start + sec_log_buf_flag_size;
 
 	sec_last_log_buf_setup();
 
diff --git a/arch/arm/mach-omap2/sec_log_buf.h b/arch/arm/mach-omap2/sec_log_buf.h
index a301f22..68dfcf1 100644
--- a/arch/arm/mach-omap2/sec_log_buf.h
+++ b/arch/arm/mach-omap2/sec_log_buf.h
@@ -19,16 +19,7 @@ struct sec_log_buf {
 	unsigned int *flag;
 	unsigned int *count;
 	char *data;
-	phys_addr_t phys_data;
 	bool enable;
 };
 
-#ifdef CONFIG_SAMSUNG_USE_SEC_LOG_BUF
-void sec_log_buf_reserve(void);
-#else
-#define sec_log_buf_reserve()
-#endif
-
-extern phys_addr_t arm_lowmem_limit;
-
 #endif /* __SEC_LOG_BUF_H__ */
diff --git a/arch/arm/mach-omap2/sec_logger.c b/arch/arm/mach-omap2/sec_logger.c
index 98db33a..0e2e29c 100644
--- a/arch/arm/mach-omap2/sec_logger.c
+++ b/arch/arm/mach-omap2/sec_logger.c
@@ -208,14 +208,12 @@ void sec_logger_update_buffer(const char *log_str, int count)
 		sec_klog_buf[len] = '\0';
 	}
 }
-EXPORT_SYMBOL(sec_logger_update_buffer);
 
 void sec_logger_print_buffer(void)
 {
 	if (sec_klog_buf[0])
 		pr_info("%s\n", sec_klog_buf);
 }
-EXPORT_SYMBOL(sec_logger_print_buffer);
 
 static void __init sec_logger_message_init(void)
 {
diff --git a/arch/arm/mach-omap2/usb-musb.c b/arch/arm/mach-omap2/usb-musb.c
index 8c74f23..7f6f678 100644
--- a/arch/arm/mach-omap2/usb-musb.c
+++ b/arch/arm/mach-omap2/usb-musb.c
@@ -82,47 +82,6 @@ static struct omap_device_pm_latency omap_musb_latency[] = {
 	},
 };
 
-/* Commenting to avoid warning during compilation */
-/*
-static void usb_musb_mux_init(struct omap_musb_board_data *board_data)
-{
-	switch (board_data->interface_type) {
-	case MUSB_INTERFACE_UTMI:
-		omap_mux_init_signal("usba0_otg_dp", OMAP_PIN_INPUT);
-		omap_mux_init_signal("usba0_otg_dm", OMAP_PIN_INPUT);
-		break;
-	case MUSB_INTERFACE_ULPI:
-		omap_mux_init_signal("usba0_ulpiphy_clk",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_stp",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dir",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_nxt",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dat0",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dat1",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dat2",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dat3",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dat4",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dat5",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dat6",
-						OMAP_PIN_INPUT_PULLDOWN);
-		omap_mux_init_signal("usba0_ulpiphy_dat7",
-						OMAP_PIN_INPUT_PULLDOWN);
-		break;
-	default:
-		break;
-	}
-}
-*/
-
 static struct omap_musb_board_data musb_default_board_data = {
 	.interface_type		= MUSB_INTERFACE_ULPI,
 	.mode			= MUSB_OTG,
diff --git a/arch/arm/mach-pxa/include/mach/smemc.h b/arch/arm/mach-pxa/include/mach/smemc.h
index 301bf0e..654adc9 100644
--- a/arch/arm/mach-pxa/include/mach/smemc.h
+++ b/arch/arm/mach-pxa/include/mach/smemc.h
@@ -37,7 +37,6 @@
 #define CSADRCFG1	(SMEMC_VIRT + 0x84)  /* Address Configuration Register for CS1 */
 #define CSADRCFG2	(SMEMC_VIRT + 0x88)  /* Address Configuration Register for CS2 */
 #define CSADRCFG3	(SMEMC_VIRT + 0x8C)  /* Address Configuration Register for CS3 */
-#define CSMSADRCFG	(SMEMC_VIRT + 0xA0)  /* Chip Select Configuration Register */
 
 /*
  * More handy macros for PCMCIA
diff --git a/arch/arm/mach-pxa/smemc.c b/arch/arm/mach-pxa/smemc.c
index f38aa89..7992305 100644
--- a/arch/arm/mach-pxa/smemc.c
+++ b/arch/arm/mach-pxa/smemc.c
@@ -40,8 +40,6 @@ static void pxa3xx_smemc_resume(void)
 	__raw_writel(csadrcfg[1], CSADRCFG1);
 	__raw_writel(csadrcfg[2], CSADRCFG2);
 	__raw_writel(csadrcfg[3], CSADRCFG3);
-	/* CSMSADRCFG wakes up in its default state (0), so we need to set it */
-	__raw_writel(0x2, CSMSADRCFG);
 }
 
 static struct syscore_ops smemc_syscore_ops = {
@@ -51,19 +49,8 @@ static struct syscore_ops smemc_syscore_ops = {
 
 static int __init smemc_init(void)
 {
-	if (cpu_is_pxa3xx()) {
-		/*
-		 * The only documentation we have on the
-		 * Chip Select Configuration Register (CSMSADRCFG) is that
-		 * it must be programmed to 0x2.
-		 * Moreover, in the bit definitions, the second bit
-		 * (CSMSADRCFG[1]) is called "SETALWAYS".
-		 * Other bits are reserved in this register.
-		 */
-		__raw_writel(0x2, CSMSADRCFG);
-
+	if (cpu_is_pxa3xx())
 		register_syscore_ops(&smemc_syscore_ops);
-	}
 
 	return 0;
 }
diff --git a/arch/arm/mach-versatile/pci.c b/arch/arm/mach-versatile/pci.c
index 3f47259..dbc398f 100644
--- a/arch/arm/mach-versatile/pci.c
+++ b/arch/arm/mach-versatile/pci.c
@@ -43,9 +43,9 @@
 #define PCI_IMAP0		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x0)
 #define PCI_IMAP1		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x4)
 #define PCI_IMAP2		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x8)
-#define PCI_SMAP0		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x14)
-#define PCI_SMAP1		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x18)
-#define PCI_SMAP2		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x1c)
+#define PCI_SMAP0		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x10)
+#define PCI_SMAP1		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x14)
+#define PCI_SMAP2		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0x18)
 #define PCI_SELFID		__IO_ADDRESS(VERSATILE_PCI_CORE_BASE+0xc)
 
 #define DEVICE_ID_OFFSET		0x00
@@ -74,7 +74,6 @@ static int __init versatile_pci_slot_ignore(char *str)
 
 __setup("pci_slot_ignore=", versatile_pci_slot_ignore);
 
-
 static void __iomem *__pci_addr(struct pci_bus *bus,
 				unsigned int devfn, int offset)
 {
@@ -303,7 +302,6 @@ int __init pci_versatile_setup(int nr, struct pci_sys_data *sys)
 	return ret;
 }
 
-
 struct pci_bus * __init pci_versatile_scan_bus(int nr, struct pci_sys_data *sys)
 {
 	return pci_scan_bus(sys->busnr, &pci_versatile_ops, sys);
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index 1aa3a70..bae5ba1 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -670,7 +670,6 @@ do_alignment_t32_to_handler(unsigned long *pinstr, struct pt_regs *regs,
 	unsigned long instr = *pinstr;
 	u16 tinst1 = (instr >> 16) & 0xffff;
 	u16 tinst2 = instr & 0xffff;
-	poffset->un = 0;
 
 	switch (tinst1 & 0xffe0) {
 	/* A6.3.5 Load/Store multiple */
@@ -760,6 +762,7 @@ do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
  fixup:
 
 	regs->ARM_pc += isize;
+	offset.un = 0;
 
 	switch (CODING_BITS(instr)) {
 	case 0x00000000:	/* 3.13.4 load/store instruction extensions */
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index 428b243..1ed1fd3 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -211,9 +211,6 @@ ENTRY(v7_coherent_user_range)
  * isn't mapped, just try the next page.
  */
 9001:
-#ifdef CONFIG_ARM_ERRATA_775420
-	dsb
-#endif
 	mov	r12, r12, lsr #12
 	mov	r12, r12, lsl #12
 	add	r12, r12, #4096
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index a763366..1a765c8 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -17,22 +17,13 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/dma-mapping.h>
-#include <linux/dma-contiguous.h>
 #include <linux/highmem.h>
-#include <linux/memblock.h>
-#include <linux/slab.h>
-#include <linux/kconfig.h>
 
 #include <asm/memory.h>
 #include <asm/highmem.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 #include <asm/sizes.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/dma-contiguous.h>
-
-#include "mm.h"
 
 static u64 get_coherent_dma_mask(struct device *dev)
 {
@@ -61,19 +52,6 @@ static u64 get_coherent_dma_mask(struct device *dev)
 	return mask;
 }
 
-static void __dma_clear_buffer(struct page *page, size_t size)
-{
-	void *ptr;
-	/*
-	 * Ensure that the allocated pages are zeroed, and that any data
-	 * lurking in the kernel direct-mapped region is invalidated.
-	 */
-	ptr = page_address(page);
-	memset(ptr, 0, size);
-	dmac_flush_range(ptr, ptr + size);
-	outer_flush_range(__pa(ptr), __pa(ptr) + size);
-}
-
 /*
  * Allocate a DMA buffer for 'dev' of size 'size' using the
  * specified gfp mask.  Note that 'size' must be page aligned.
@@ -82,6 +60,23 @@ static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gf
 {
 	unsigned long order = get_order(size);
 	struct page *page, *p, *e;
+	void *ptr;
+	u64 mask = get_coherent_dma_mask(dev);
+
+#ifdef CONFIG_DMA_API_DEBUG
+	u64 limit = (mask + 1) & ~mask;
+	if (limit && size >= limit) {
+		dev_warn(dev, "coherent allocation too big (requested %#x mask %#llx)\n",
+			size, mask);
+		return NULL;
+	}
+#endif
+
+	if (!mask)
+		return NULL;
+
+	if (mask < 0xffffffffULL)
+		gfp |= GFP_DMA;
 
 	page = alloc_pages(gfp, order);
 	if (!page)
@@ -94,7 +89,14 @@ static struct page *__dma_alloc_buffer(struct device *dev, size_t size, gfp_t gf
 	for (p = page + (size >> PAGE_SHIFT), e = page + (1 << order); p < e; p++)
 		__free_page(p);
 
-	__dma_clear_buffer(page, size);
+	/*
+	 * Ensure that the allocated pages are zeroed, and that any data
+	 * lurking in the kernel direct-mapped region is invalidated.
+	 */
+	ptr = page_address(page);
+	memset(ptr, 0, size);
+	dmac_flush_range(ptr, ptr + size);
+	outer_flush_range(__pa(ptr), __pa(ptr) + size);
 
 	return page;
 }
@@ -153,9 +155,6 @@ static int __init consistent_init(void)
 	int i = 0;
 	u32 base = CONSISTENT_BASE;
 
-	if (IS_ENABLED(CONFIG_CMA))
-		return 0;
-
 	do {
 		pgd = pgd_offset(&init_mm, base);
 
@@ -187,100 +186,8 @@ static int __init consistent_init(void)
 
 	return ret;
 }
-core_initcall(consistent_init);
-
-static void *__alloc_from_contiguous(struct device *dev, size_t size,
-				     pgprot_t prot, struct page **ret_page);
-
-static struct arm_vmregion_head coherent_head = {
-	.vm_lock	= __SPIN_LOCK_UNLOCKED(&coherent_head.vm_lock),
-	.vm_list	= LIST_HEAD_INIT(coherent_head.vm_list),
-};
-
-size_t coherent_pool_size = CONSISTENT_DMA_SIZE / 8;
-
-static int __init early_coherent_pool(char *p)
-{
-	coherent_pool_size = memparse(p, &p);
-	return 0;
-}
-early_param("coherent_pool", early_coherent_pool);
-
-/*
- * Initialise the coherent pool for atomic allocations.
- */
-static int __init coherent_init(void)
-{
-	pgprot_t prot = pgprot_dmacoherent(pgprot_kernel);
-	size_t size = coherent_pool_size;
-	struct page *page;
-	void *ptr;
-
-	if (!IS_ENABLED(CONFIG_CMA))
-		return 0;
-
-	ptr = __alloc_from_contiguous(NULL, size, prot, &page);
-	if (ptr) {
-		coherent_head.vm_start = (unsigned long) ptr;
-		coherent_head.vm_end = (unsigned long) ptr + size;
-		printk(KERN_INFO "DMA: preallocated %u KiB pool for atomic coherent allocations\n",
-		       (unsigned)size / 1024);
-		return 0;
-	}
-	printk(KERN_ERR "DMA: failed to allocate %u KiB pool for atomic coherent allocation\n",
-	       (unsigned)size / 1024);
-	return -ENOMEM;
-}
-/*
- * CMA is activated by core_initcall, so we must be called after it.
- */
-postcore_initcall(coherent_init);
-
-struct dma_contig_early_reserve {
-	phys_addr_t base;
-	unsigned long size;
-};
-
-static struct dma_contig_early_reserve dma_mmu_remap[MAX_CMA_AREAS] __initdata;
-
-static int dma_mmu_remap_num __initdata;
-
-void __init dma_contiguous_early_fixup(phys_addr_t base, unsigned long size)
-{
-	dma_mmu_remap[dma_mmu_remap_num].base = base;
-	dma_mmu_remap[dma_mmu_remap_num].size = size;
-	dma_mmu_remap_num++;
-}
 
-void __init dma_contiguous_remap(void)
-{
-	int i;
-	for (i = 0; i < dma_mmu_remap_num; i++) {
-		phys_addr_t start = dma_mmu_remap[i].base;
-		phys_addr_t end = start + dma_mmu_remap[i].size;
-		struct map_desc map;
-		unsigned long addr;
-
-		if (end > arm_lowmem_limit)
-			end = arm_lowmem_limit;
-		if (start >= end)
-			return;
-
-		map.pfn = __phys_to_pfn(start);
-		map.virtual = __phys_to_virt(start);
-		map.length = end - start;
-		map.type = MT_MEMORY_DMA_READY;
-
-		/*
-		 * Clear previous low-memory mapping
-		 */
-		for (addr = __phys_to_virt(start); addr < __phys_to_virt(end);
-		     addr += PGDIR_SIZE)
-			pmd_clear(pmd_off_k(addr));
-
-		iotable_init(&map, 1);
-	}
-}
+core_initcall(consistent_init);
 
 static void *
 __dma_alloc_remap(struct page *page, size_t size, gfp_t gfp, pgprot_t prot)
@@ -387,195 +294,36 @@ static void __dma_free_remap(void *cpu_addr, size_t size)
 	arm_vmregion_free(&consistent_head, c);
 }
 
-static int __dma_update_pte(pte_t *pte, pgtable_t token, unsigned long addr,
-			    void *data)
-{
-	struct page *page = virt_to_page(addr);
-	pgprot_t prot = *(pgprot_t *)data;
-
-	set_pte_ext(pte, mk_pte(page, prot), 0);
-	return 0;
-}
-
-static void __dma_remap(struct page *page, size_t size, pgprot_t prot)
-{
-	unsigned long start = (unsigned long) page_address(page);
-	unsigned end = start + size;
-
-	apply_to_page_range(&init_mm, start, size, __dma_update_pte, &prot);
-	dsb();
-	flush_tlb_kernel_range(start, end);
-}
-
-static void *__alloc_remap_buffer(struct device *dev, size_t size, gfp_t gfp,
-				 pgprot_t prot, struct page **ret_page)
-{
-	struct page *page;
-	void *ptr;
-	page = __dma_alloc_buffer(dev, size, gfp);
-	if (!page)
-		return NULL;
-
-	ptr = __dma_alloc_remap(page, size, gfp, prot);
-	if (!ptr) {
-		__dma_free_buffer(page, size);
-		return NULL;
-	}
-
-	*ret_page = page;
-	return ptr;
-}
-
-static void *__alloc_from_pool(struct device *dev, size_t size,
-			       struct page **ret_page)
-{
-	struct arm_vmregion *c;
-	size_t align;
-
-	if (!coherent_head.vm_start) {
-		printk(KERN_ERR "%s: coherent pool not initialised!\n",
-		       __func__);
-		dump_stack();
-		return NULL;
-	}
-
-	/*
-	 * Align the region allocation - allocations from pool are rather
-	 * small, so align them to their order in pages, minimum is a page
-	 * size. This helps reduce fragmentation of the DMA space.
-	 */
-	align = PAGE_SIZE << get_order(size);
-	c = arm_vmregion_alloc(&coherent_head, align, size, 0);
-	if (c) {
-		void *ptr = (void *)c->vm_start;
-		struct page *page = virt_to_page(ptr);
-		*ret_page = page;
-		return ptr;
-	}
-	return NULL;
-}
-
-static int __free_from_pool(void *cpu_addr, size_t size)
-{
-	unsigned long start = (unsigned long)cpu_addr;
-	unsigned long end = start + size;
-	struct arm_vmregion *c;
-
-	if (start < coherent_head.vm_start || end > coherent_head.vm_end)
-		return 0;
-
-	c = arm_vmregion_find_remove(&coherent_head, (unsigned long)start);
-
-	if ((c->vm_end - c->vm_start) != size) {
-		printk(KERN_ERR "%s: freeing wrong coherent size (%ld != %d)\n",
-		       __func__, c->vm_end - c->vm_start, size);
-		dump_stack();
-		size = c->vm_end - c->vm_start;
-	}
-
-	arm_vmregion_free(&coherent_head, c);
-	return 1;
-}
-
-static void *__alloc_from_contiguous(struct device *dev, size_t size,
-				     pgprot_t prot, struct page **ret_page)
-{
-	unsigned long order = get_order(size);
-	size_t count = size >> PAGE_SHIFT;
-	struct page *page;
-
-	page = dma_alloc_from_contiguous(dev, count, order);
-	if (!page)
-		return NULL;
-
-	__dma_clear_buffer(page, size);
-	__dma_remap(page, size, prot);
-
-	*ret_page = page;
-	return page_address(page);
-}
-
-static void __free_from_contiguous(struct device *dev, struct page *page,
-				   size_t size)
-{
-	__dma_remap(page, size, pgprot_kernel);
-	dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT);
-}
-
-#define nommu() 0
-
 #else	/* !CONFIG_MMU */
 
-#define nommu() 1
-
-#define __alloc_remap_buffer(dev, size, gfp, prot, ret)	NULL
-#define __alloc_from_pool(dev, size, ret_page)		NULL
-#define __alloc_from_contiguous(dev, size, prot, ret)	NULL
-#define __free_from_pool(cpu_addr, size)		0
-#define __free_from_contiguous(dev, page, size)		do { } while (0)
-#define __dma_free_remap(cpu_addr, size)		do { } while (0)
+#define __dma_alloc_remap(page, size, gfp, prot)	page_address(page)
+#define __dma_free_remap(addr, size)			do { } while (0)
 
 #endif	/* CONFIG_MMU */
 
-static void *__alloc_simple_buffer(struct device *dev, size_t size, gfp_t gfp,
-				   struct page **ret_page)
-{
-	struct page *page;
-	page = __dma_alloc_buffer(dev, size, gfp);
-	if (!page)
-		return NULL;
-
-	*ret_page = page;
-	return page_address(page);
-}
-
-
-
-static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
-			 gfp_t gfp, pgprot_t prot)
+static void *
+__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
+	    pgprot_t prot)
 {
-	u64 mask = get_coherent_dma_mask(dev);
 	struct page *page;
 	void *addr;
 
-#ifdef CONFIG_DMA_API_DEBUG
-	u64 limit = (mask + 1) & ~mask;
-	if (limit && size >= limit) {
-		dev_warn(dev, "coherent allocation too big (requested %#x mask %#llx)\n",
-			size, mask);
-		return NULL;
-	}
-#endif
-
-	if (!mask)
-		return NULL;
-
-	if (mask < 0xffffffffULL)
-		gfp |= GFP_DMA;
-
-	/*
-	 * Following is a work-around (a.k.a. hack) to prevent pages
-	 * with __GFP_COMP being passed to split_page() which cannot
-	 * handle them.  The real problem is that this flag probably
-	 * should be 0 on ARM as it is not supported on this
-	 * platform; see CONFIG_HUGETLBFS.
-	 */
-	gfp &= ~(__GFP_COMP);
-
 	*handle = ~0;
 	size = PAGE_ALIGN(size);
 
-	if (arch_is_coherent() || nommu())
-		addr = __alloc_simple_buffer(dev, size, gfp, &page);
-	else if (!IS_ENABLED(CONFIG_CMA))
-		addr = __alloc_remap_buffer(dev, size, gfp, prot, &page);
-	else if (gfp & GFP_ATOMIC)
-		addr = __alloc_from_pool(dev, size, &page);
+	page = __dma_alloc_buffer(dev, size, gfp);
+	if (!page)
+		return NULL;
+
+	if (!arch_is_coherent())
+		addr = __dma_alloc_remap(page, size, gfp, prot);
 	else
-		addr = __alloc_from_contiguous(dev, size, prot, &page);
+		addr = page_address(page);
 
 	if (addr)
 		*handle = pfn_to_dma(dev, page_to_pfn(page));
+	else
+		__dma_free_buffer(page, size);
 
 	return addr;
 }
@@ -584,8 +332,8 @@ static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
  * Allocate DMA-coherent memory space and return both the kernel remapped
  * virtual and bus address for that space.
  */
-void *dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle,
-			 gfp_t gfp)
+void *
+dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
 {
 	void *memory;
 
@@ -616,13 +364,8 @@ EXPORT_SYMBOL(dma_alloc_writecombine);
 void *dma_alloc_stronglyordered(struct device *dev, size_t size,
 				dma_addr_t *handle, gfp_t gfp)
 {
-#ifdef CONFIG_CMA
-	struct page *page;
-	return __alloc_simple_buffer(dev, size, gfp, &page);
-#else
 	return __dma_alloc(dev, size, handle, gfp,
 			   pgprot_stronglyordered(pgprot_kernel));
-#endif
 }
 EXPORT_SYMBOL(dma_alloc_stronglyordered);
 
@@ -631,11 +374,25 @@ static int dma_mmap(struct device *dev, struct vm_area_struct *vma,
 {
 	int ret = -ENXIO;
 #ifdef CONFIG_MMU
-	unsigned long pfn = dma_to_pfn(dev, dma_addr);
-	ret = remap_pfn_range(vma, vma->vm_start,
-			      pfn + vma->vm_pgoff,
-			      vma->vm_end - vma->vm_start,
-			      vma->vm_page_prot);
+	unsigned long user_size, kern_size;
+	struct arm_vmregion *c;
+
+	user_size = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+
+	c = arm_vmregion_find(&consistent_head, (unsigned long)cpu_addr);
+	if (c) {
+		unsigned long off = vma->vm_pgoff;
+
+		kern_size = (c->vm_end - c->vm_start) >> PAGE_SHIFT;
+
+		if (off < kern_size &&
+		    user_size <= (kern_size - off)) {
+			ret = remap_pfn_range(vma, vma->vm_start,
+					      page_to_pfn(c->vm_pages) + off,
+					      user_size << PAGE_SHIFT,
+					      vma->vm_page_prot);
+		}
+	}
 #endif	/* CONFIG_MMU */
 
 	return ret;
@@ -657,33 +414,23 @@ int dma_mmap_writecombine(struct device *dev, struct vm_area_struct *vma,
 }
 EXPORT_SYMBOL(dma_mmap_writecombine);
 
-
 /*
- * Free a buffer as defined by the above mapping.
+ * free a page as defined by the above mapping.
+ * Must not be called with IRQs disabled.
  */
 void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle)
 {
-	struct page *page = pfn_to_page(dma_to_pfn(dev, handle));
+	WARN_ON(irqs_disabled());
 
 	if (dma_release_from_coherent(dev, get_order(size), cpu_addr))
 		return;
 
 	size = PAGE_ALIGN(size);
 
-	if (arch_is_coherent() || nommu()) {
-		__dma_free_buffer(page, size);
-	} else if (!IS_ENABLED(CONFIG_CMA)) {
+	if (!arch_is_coherent())
 		__dma_free_remap(cpu_addr, size);
-		__dma_free_buffer(page, size);
-	} else {
-		if (__free_from_pool(cpu_addr, size))
-			return;
-		/*
-		 * Non-atomic allocations cannot be freed with IRQs disabled
-		 */
-		WARN_ON(irqs_disabled());
-		__free_from_contiguous(dev, page, size);
-	}
+
+	__dma_free_buffer(pfn_to_page(dma_to_pfn(dev, handle)), size);
 }
 EXPORT_SYMBOL(dma_free_coherent);
 
@@ -732,27 +479,25 @@ static void dma_cache_maint_page(struct page *page, unsigned long offset,
 	size_t size, enum dma_data_direction dir,
 	void (*op)(const void *, size_t, int))
 {
-	unsigned long pfn;
-	size_t left = size;
-
-	pfn = page_to_pfn(page) + offset / PAGE_SIZE;
-	offset %= PAGE_SIZE;
-
 	/*
 	 * A single sg entry may refer to multiple physically contiguous
 	 * pages.  But we still need to process highmem pages individually.
 	 * If highmem is not configured then the bulk of this loop gets
 	 * optimized out.
 	 */
+	size_t left = size;
 	do {
 		size_t len = left;
 		void *vaddr;
 
-		page = pfn_to_page(pfn);
-
 		if (PageHighMem(page)) {
-			if (len + offset > PAGE_SIZE)
+			if (len + offset > PAGE_SIZE) {
+				if (offset >= PAGE_SIZE) {
+					page += offset / PAGE_SIZE;
+					offset %= PAGE_SIZE;
+				}
 				len = PAGE_SIZE - offset;
+			}
 			vaddr = kmap_high_get(page);
 			if (vaddr) {
 				vaddr += offset;
@@ -769,7 +514,7 @@ static void dma_cache_maint_page(struct page *page, unsigned long offset,
 			op(vaddr, len, dir);
 		}
 		offset = 0;
-		pfn++;
+		page++;
 		left -= len;
 	} while (left);
 }
@@ -926,13 +671,6 @@ void dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
 }
 EXPORT_SYMBOL(dma_sync_sg_for_device);
 
-/*
- * Return whether the given device DMA address mask can be supported
- * properly.  For example, if your device can only drive the low 24-bits
- * during bus mastering, then you would pass 0x00ffffff as the mask
- * to this function.
- */
-
 #define PREALLOC_DMA_DEBUG_ENTRIES	4096
 
 static int __init dma_debug_do_init(void)
diff --git a/arch/arm/mm/flush.c b/arch/arm/mm/flush.c
index 8fda9f7..1a8d4aa 100644
--- a/arch/arm/mm/flush.c
+++ b/arch/arm/mm/flush.c
@@ -236,6 +236,8 @@ void __sync_icache_dcache(pte_t pteval)
 	struct page *page;
 	struct address_space *mapping;
 
+	if (!pte_present_user(pteval))
+		return;
 	if (cache_is_vipt_nonaliasing() && !pte_exec(pteval))
 		/* only flush non-aliasing VIPT caches for exec mappings */
 		return;
diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index 13f3b40..4a4eba5 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -20,7 +20,6 @@
 #include <linux/gfp.h>
 #include <linux/memblock.h>
 #include <linux/sort.h>
-#include <linux/dma-contiguous.h>
 
 #include <asm/mach-types.h>
 #include <asm/prom.h>
@@ -213,18 +212,6 @@ static void __init arm_bootmem_init(unsigned long start_pfn,
 }
 
 #ifdef CONFIG_ZONE_DMA
-
-unsigned long arm_dma_zone_size __read_mostly;
-EXPORT_SYMBOL(arm_dma_zone_size);
-
-/*
- * The DMA mask corresponding to the maximum bus address allocatable
- * using GFP_DMA.  The default here places no restriction on DMA
- * allocations.  This must be the smallest DMA mask in the system,
- * so a successful GFP_DMA allocation will always satisfy this.
- */
-phys_addr_t arm_dma_limit;
-
 static void __init arm_adjust_dma_zone(unsigned long *size, unsigned long *hole,
 	unsigned long dma_size)
 {
@@ -238,17 +225,6 @@ static void __init arm_adjust_dma_zone(unsigned long *size, unsigned long *hole,
 }
 #endif
 
-void __init setup_dma_zone(struct machine_desc *mdesc)
-{
-#ifdef CONFIG_ZONE_DMA
-	if (mdesc->dma_zone_size) {
-		arm_dma_zone_size = mdesc->dma_zone_size;
-		arm_dma_limit = PHYS_OFFSET + arm_dma_zone_size - 1;
-	} else
-		arm_dma_limit = 0xffffffff;
-#endif
-}
-
 static void __init arm_bootmem_free(unsigned long min, unsigned long max_low,
 	unsigned long max_high)
 {
@@ -291,14 +267,17 @@ static void __init arm_bootmem_free(unsigned long min, unsigned long max_low,
 #endif
 	}
 
-#ifdef CONFIG_ZONE_DMA
+#ifdef ARM_DMA_ZONE_SIZE
+#ifndef CONFIG_ZONE_DMA
+#error ARM_DMA_ZONE_SIZE set but no DMA zone to limit allocations
+#endif
+
 	/*
 	 * Adjust the sizes according to any special requirements for
 	 * this machine type.
 	 */
-	if (arm_dma_zone_size)
-		arm_adjust_dma_zone(zone_size, zhole_size,
-			arm_dma_zone_size >> PAGE_SHIFT);
+	arm_adjust_dma_zone(zone_size, zhole_size,
+		ARM_DMA_ZONE_SIZE >> PAGE_SHIFT);
 #endif
 
 	free_area_init_node(0, zone_size, min, zhole_size);
@@ -379,12 +358,6 @@ void __init arm_memblock_init(struct meminfo *mi, struct machine_desc *mdesc)
 	if (mdesc->reserve)
 		mdesc->reserve();
 
-	/*
-	 * reserve memory for DMA contigouos allocations,
-	 * must come from DMA area inside low memory
-	 */
-	dma_contiguous_reserve(min(arm_dma_limit, arm_lowmem_limit));
-
 	memblock_analyze();
 	memblock_dump_all();
 }
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index f59f274..e15bf1d 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -281,19 +281,6 @@ static struct mem_type mem_types[] = {
 				PMD_SECT_UNCACHED | PMD_SECT_XN,
 		.domain    = DOMAIN_KERNEL,
 	},
-	[MT_MEMORY_SO] = {
-		.prot_pte  = L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_DIRTY |
-				L_PTE_MT_UNCACHED,
-		.prot_l1   = PMD_TYPE_TABLE,
-		.prot_sect = PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_S |
-				PMD_SECT_UNCACHED | PMD_SECT_XN,
-		.domain    = DOMAIN_KERNEL,
-	},
-	[MT_MEMORY_DMA_READY] = {
-		.prot_pte  = L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_DIRTY,
-		.prot_l1   = PMD_TYPE_TABLE,
-		.domain    = DOMAIN_KERNEL,
-	},
 };
 
 const struct mem_type *get_mem_type(unsigned int type)
@@ -435,7 +422,6 @@ static void __init build_mem_type_table(void)
 	if (arch_is_coherent() && cpu_is_xsc3()) {
 		mem_types[MT_MEMORY].prot_sect |= PMD_SECT_S;
 		mem_types[MT_MEMORY].prot_pte |= L_PTE_SHARED;
-		mem_types[MT_MEMORY_DMA_READY].prot_pte |= L_PTE_SHARED;
 		mem_types[MT_MEMORY_NONCACHED].prot_sect |= PMD_SECT_S;
 		mem_types[MT_MEMORY_NONCACHED].prot_pte |= L_PTE_SHARED;
 	}
@@ -465,7 +451,6 @@ static void __init build_mem_type_table(void)
 			mem_types[MT_DEVICE_CACHED].prot_pte |= L_PTE_SHARED;
 			mem_types[MT_MEMORY].prot_sect |= PMD_SECT_S;
 			mem_types[MT_MEMORY].prot_pte |= L_PTE_SHARED;
-			mem_types[MT_MEMORY_DMA_READY].prot_pte |= L_PTE_SHARED;
 			mem_types[MT_MEMORY_NONCACHED].prot_sect |= PMD_SECT_S;
 			mem_types[MT_MEMORY_NONCACHED].prot_pte |= L_PTE_SHARED;
 		}
@@ -490,7 +475,7 @@ static void __init build_mem_type_table(void)
 	}
 
 	for (i = 0; i < 16; i++) {
-		pteval_t v = pgprot_val(protection_map[i]);
+		unsigned long v = pgprot_val(protection_map[i]);
 		protection_map[i] = __pgprot(v | user_pgprot);
 	}
 
@@ -505,7 +490,6 @@ static void __init build_mem_type_table(void)
 	mem_types[MT_HIGH_VECTORS].prot_l1 |= ecc_mask;
 	mem_types[MT_MEMORY].prot_sect |= ecc_mask | cp->pmd;
 	mem_types[MT_MEMORY].prot_pte |= kern_pgprot;
-	mem_types[MT_MEMORY_DMA_READY].prot_pte |= kern_pgprot;
 	mem_types[MT_MEMORY_NONCACHED].prot_sect |= ecc_mask;
 	mem_types[MT_ROM].prot_sect |= cp->pmd;
 
@@ -518,8 +502,6 @@ static void __init build_mem_type_table(void)
 		mem_types[MT_CACHECLEAN].prot_sect |= PMD_SECT_WB;
 		break;
 	}
-	printk("Memory policy: ECC %sabled, Data cache %s\n",
-		ecc_mask ? "en" : "dis", cp->policy);
 
 	for (i = 0; i < ARRAY_SIZE(mem_types); i++) {
 		struct mem_type *t = &mem_types[i];
@@ -585,7 +567,7 @@ static void __init alloc_init_section(pud_t *pud, unsigned long addr,
 	 * L1 entries, whereas PGDs refer to a group of L1 entries making
 	 * up one logical pointer to an L2 table.
 	 */
-	if (type->prot_sect && ((addr | end | phys) & ~SECTION_MASK) == 0) {
+	if (((addr | end | phys) & ~SECTION_MASK) == 0) {
 		pmd_t *p = pmd;
 
 		if (addr & SECTION_SIZE)
@@ -781,7 +763,7 @@ static int __init early_vmalloc(char *arg)
 }
 early_param("vmalloc", early_vmalloc);
 
-phys_addr_t arm_lowmem_limit __initdata = 0;
+static phys_addr_t lowmem_limit __initdata = 0;
 
 void __init sanity_check_meminfo(void)
 {
@@ -850,8 +832,8 @@ void __init sanity_check_meminfo(void)
 			bank->size = newsize;
 		}
 #endif
-		if (!bank->highmem && bank->start + bank->size > arm_lowmem_limit)
-			arm_lowmem_limit = bank->start + bank->size;
+		if (!bank->highmem && bank->start + bank->size > lowmem_limit)
+			lowmem_limit = bank->start + bank->size;
 
 		j++;
 	}
@@ -876,7 +858,7 @@ void __init sanity_check_meminfo(void)
 	}
 #endif
 	meminfo.nr_banks = j;
-	memblock_set_current_limit(arm_lowmem_limit);
+	memblock_set_current_limit(lowmem_limit);
 }
 
 static inline void prepare_page_table(void)
@@ -901,8 +883,8 @@ static inline void prepare_page_table(void)
 	 * Find the end of the first block of lowmem.
 	 */
 	end = memblock.memory.regions[0].base + memblock.memory.regions[0].size;
-	if (end >= arm_lowmem_limit)
-		end = arm_lowmem_limit;
+	if (end >= lowmem_limit)
+		end = lowmem_limit;
 
 	/*
 	 * Clear out all the kernel space mappings, except for the first
@@ -1034,8 +1016,8 @@ static void __init map_lowmem(void)
 		phys_addr_t end = start + reg->size;
 		struct map_desc map;
 
-		if (end > arm_lowmem_limit)
-			end = arm_lowmem_limit;
+		if (end > lowmem_limit)
+			end = lowmem_limit;
 		if (start >= end)
 			break;
 
@@ -1056,12 +1038,11 @@ void __init paging_init(struct machine_desc *mdesc)
 {
 	void *zero_page;
 
-	memblock_set_current_limit(arm_lowmem_limit);
+	memblock_set_current_limit(lowmem_limit);
 
 	build_mem_type_table();
 	prepare_page_table();
 	map_lowmem();
-	dma_contiguous_remap();
 	devicemaps_init(mdesc);
 	kmap_init();
 
diff --git a/arch/arm/plat-omap/android-display.c b/arch/arm/plat-omap/android-display.c
index 70f931a..503ef4b 100644
--- a/arch/arm/plat-omap/android-display.c
+++ b/arch/arm/plat-omap/android-display.c
@@ -76,9 +76,22 @@ static int __init get_hdmi_options(char *str)
 }
 early_param("omapdss.hdmi_options", get_hdmi_options);
 
-static void get_display_size(struct omap_dss_device *device,
+static void get_display_size(struct omap_dss_board_info *info,
 			     struct omap_android_display_data *mem)
 {
+	struct omap_dss_device *device = NULL;
+	int i;
+
+	if (!info)
+		goto done;
+
+	device = info->default_device;
+	for (i = 0; i < info->num_devices; i++) {
+		if (!strcmp(default_display, info->devices[i]->name)) {
+			device = info->devices[i];
+			break;
+		}
+	}
 
 	if (!device)
 		goto done;
@@ -94,8 +107,8 @@ static void get_display_size(struct omap_dss_device *device,
 	if (device->ctrl.pixel_size)
 		mem->bpp = ALIGN(device->ctrl.pixel_size, 16) >> 3;
 
-	pr_info("android_display: setting %s resolution to %u*%u, bpp=%u\n",
-		device->name, mem->width, mem->height, mem->bpp);
+	pr_info("android_display: setting default resolution %u*%u, bpp=%u\n",
+					mem->width, mem->height, mem->bpp);
 done:
 	return;
 }
@@ -144,25 +157,50 @@ static u32 vram_size(struct omap_android_display_data *mem)
 }
 
 static void set_vram_sizes(struct sgx_omaplfb_config *sgx_config,
-		struct omapfb_mem_region *region,
-		struct omap_android_display_data *mem,
-		unsigned fbnum)
+			   struct omapfb_platform_data *fb,
+			   struct omap_android_display_data *mem)
 {
-	u32 num_vram_buffers;
+	u32 num_vram_buffers = 0;
 	u32 vram = 0;
+	int i;
 
-	if (!sgx_config || !region || !mem)
-		return;
+	if (fb && fb->mem_desc.region_cnt >= 1) {
+		/* Need at least 1 VRAM buffer for fb0 */
+		num_vram_buffers = 1;
+	}
 
-	/* Need at least 1 VRAM buffer for fb0 */
-	num_vram_buffers = max(sgx_config->vram_buffers, 1u);
-	vram += sgx_config->vram_reserve;
+	if (sgx_config) {
+#if defined(CONFIG_GCBV)
+		/* Add 2 extra VRAM buffers for gc320 composition - 4470 only*/
+		/* TODO: cpu_is_omap447x() is not returning the proper value
+			at this stage. Need to fix it */
+		if (1/*cpu_is_omap447x()*/)
+			sgx_config->vram_buffers += 2;
+#endif
+
+		vram += sgx_config->vram_reserve;
+		num_vram_buffers = max(sgx_config->vram_buffers,
+				       num_vram_buffers);
+	}
 
 	vram += num_vram_buffers * vram_size(mem);
-	/* set fb vram needs */
-	region->size = vram;
-	pr_info("android_display: setting fb%u.vram to %u\n", fbnum, vram);
 
+	if (fb) {
+		/* set fb0 vram needs */
+		if (fb->mem_desc.region_cnt >= 1) {
+			fb->mem_desc.region[0].size = vram;
+			pr_info("android_display: setting fb0.vram to %u\n",
+									vram);
+		}
+
+		/* set global vram needs incl. additional regions specified */
+		for (i = 1; i < fb->mem_desc.region_cnt; i++)
+			if (!fb->mem_desc.region[i].paddr)
+				vram += fb->mem_desc.region[i].size;
+	}
+
+	pr_info("android_display: setting vram to %u\n", vram);
+	omap_vram_set_sdram_vram(vram, 0);
 }
 
 static void set_ion_carveouts(struct sgx_omaplfb_config *sgx_config,
@@ -178,7 +216,6 @@ static void set_ion_carveouts(struct sgx_omaplfb_config *sgx_config,
 	if (sgx_config)
 		num_buffers = sgx_config->tiler2d_buffers;
 
-
 	/* width must be aligned to 128 bytes */
 	width = ALIGN(mem->width, 128 / mem->bpp);
 	fmt = mem->bpp <= 2 ? TILFMT_16BIT : TILFMT_32BIT;
@@ -211,15 +248,13 @@ static void set_ion_carveouts(struct sgx_omaplfb_config *sgx_config,
 }
 
 /* coordinate between sgx, omapdss, dsscomp and ion needs */
-int omap_android_display_setup(struct omap_dss_board_info *dss,
+void omap_android_display_setup(struct omap_dss_board_info *dss,
 			       struct dsscomp_platform_data *dsscomp,
 			       struct sgx_omaplfb_platform_data *sgx,
 			       struct omapfb_platform_data *fb,
 			       struct omap_ion_platform_data *ion)
 {
 	struct sgx_omaplfb_config *p_sgx_config = NULL;
-	int i;
-	u32 omapfb_vram = 0;
 
 	struct omap_android_display_data mem = {
 		.bpp = 4,
@@ -227,34 +262,16 @@ int omap_android_display_setup(struct omap_dss_board_info *dss,
 		.height = 1080,
 	};
 
-	if (!sgx || !sgx->num_configs)
-		return -ENODEV;
-	for (i = 0; i < sgx->num_configs; ++i) {
-		p_sgx_config = &(sgx->configs[i]);
-
-		if (i < dss->num_devices)
-			get_display_size(dss->devices[i], &mem);
-
-		if (ion)
-			set_ion_carveouts(p_sgx_config, ion, &mem);
-		set_tiler1d_slot_size(dsscomp, &mem);
-		/* skip region if no sgx_config associated with it
-		 * or it has size pre-set by board configuration
-		 */
-		if (i < fb->mem_desc.region_cnt &&
-				!fb->mem_desc.region[i].size)
-			set_vram_sizes(p_sgx_config, &fb->mem_desc.region[i],
-								&mem, i);
-
-		sgx_omaplfb_set(i, p_sgx_config);
-	}
-	/* set global vram needs incl. additional regions specified */
-	for (i = 0; i < fb->mem_desc.region_cnt; i++)
-		if (!fb->mem_desc.region[i].paddr)
-			omapfb_vram += fb->mem_desc.region[i].size;
+	if (!sgx || !sgx->configs)
+		p_sgx_config = sgx_omaplfb_get(0);
+	else
+		p_sgx_config = &(sgx->configs[0]);
 
-	pr_info("android_display: setting vram to %u\n", omapfb_vram);
-	omap_vram_set_sdram_vram(omapfb_vram, 0);
+	get_display_size(dss, &mem);
+	set_tiler1d_slot_size(dsscomp, &mem);
+	set_vram_sizes(p_sgx_config, fb, &mem);
+	if (ion)
+		set_ion_carveouts(p_sgx_config, ion, &mem);
 
-	return 0;
+	sgx_omaplfb_set(0, p_sgx_config);
 }

diff --git a/arch/arm/plat-omap/dma.c b/arch/arm/plat-omap/dma.c
index 90ae3ec..1ce12ff 100644
--- a/arch/arm/plat-omap/dma.c
+++ b/arch/arm/plat-omap/dma.c
@@ -998,7 +998,6 @@ int omap_set_dma_callback(int lch,
 
 	spin_lock_irqsave(&dma_chan_lock, flags);
 	if (dma_chan[lch].dev_id == -1) {
-		printk(KERN_ERR "DMA callback for not set for free channel\n");
 		spin_unlock_irqrestore(&dma_chan_lock, flags);
 		return -EINVAL;
 	}
@@ -1112,8 +1111,7 @@ void omap_dma_link_lch(int lch_head, int lch_queue)
 {
 	if (omap_dma_in_1510_mode()) {
 		if (lch_head == lch_queue) {
-			p->dma_write(p->dma_read(CCR, lch_head) | (3 << 8),
-								CCR, lch_head);
+			p->dma_write(p->dma_read(CCR, lch_head) | (3 << 8), CCR, lch_head);
 			return;
 		}
 		printk(KERN_ERR "DMA linking is not supported in 1510 mode\n");
@@ -1123,8 +1121,7 @@ void omap_dma_link_lch(int lch_head, int lch_queue)
 
 	if ((dma_chan[lch_head].dev_id == -1) ||
 	    (dma_chan[lch_queue].dev_id == -1)) {
-		printk(KERN_ERR "omap_dma: trying to link "
-		       "non requested channels\n");
+		printk(KERN_ERR "omap_dma: trying to link non requested channels\n");
 		dump_stack();
 	}
 
@@ -1150,15 +1147,13 @@ void omap_dma_unlink_lch(int lch_head, int lch_queue)
 
 	if (dma_chan[lch_head].next_lch != lch_queue ||
 	    dma_chan[lch_head].next_lch == -1) {
-		printk(KERN_ERR "omap_dma: trying to unlink "
-		       "non linked channels\n");
+		printk(KERN_ERR "omap_dma: trying to unlink non linked channels\n");
 		dump_stack();
 	}
 
 	if ((dma_chan[lch_head].flags & OMAP_DMA_ACTIVE) ||
 	    (dma_chan[lch_queue].flags & OMAP_DMA_ACTIVE)) {
-		printk(KERN_ERR "omap_dma: You need to stop the DMA channels "
-		       "before unlinking\n");
+		printk(KERN_ERR "omap_dma: You need to stop the DMA channels before unlinking\n");
 		dump_stack();
 	}
 
@@ -1178,10 +1173,8 @@ static void create_dma_lch_chain(int lch_head, int lch_queue)
 		dma_chan[lch_head].prev_linked_ch = lch_queue;
 		dma_chan[lch_queue].next_linked_ch = lch_head;
 		dma_chan[lch_queue].prev_linked_ch = lch_head;
-	}
-
-	/* a link exists, link the new channel in circular chain */
-	else {
+	} else {
+		/* a link exists, link the new channel in circular chain */
 		dma_chan[lch_queue].next_linked_ch =
 					dma_chan[lch_head].next_linked_ch;
 		dma_chan[lch_queue].prev_linked_ch = lch_head;
@@ -1217,8 +1210,7 @@ static void create_dma_lch_chain(int lch_head, int lch_queue)
  * 	     Failure: -EINVAL/-ENOMEM
  */
 int omap_request_dma_chain(int dev_id, const char *dev_name,
-			   void (*callback) (int lch, u16 ch_status,
-					     void *data),
+			   void (*callback) (int lch, u16 ch_status, void *data),
 			   int *chain_id, int no_of_chans, int chain_mode,
 			   struct omap_dma_channel_params params)
 {
@@ -1403,8 +1395,6 @@ int omap_dma_chain_status(int chain_id)
 		printk(KERN_ERR "Chain doesn't exists\n");
 		return -EINVAL;
 	}
-	pr_debug("CHAINID=%d, qcnt=%d\n", chain_id,
-			dma_linked_lch[chain_id].q_count);
 
 	if (OMAP_DMA_CHAIN_QEMPTY(chain_id))
 		return OMAP_DMA_CHAIN_INACTIVE;
@@ -1517,7 +1507,6 @@ int omap_dma_chain_a_transfer(int chain_id, int src_start, int dest_start,
 					CCR, dma_chan[lch].prev_linked_ch))) {
 					disable_lnk(dma_chan[lch].
 						    prev_linked_ch);
-					pr_debug("\n prev ch is stopped\n");
 					start_dma = 1;
 				}
 			}
@@ -1540,7 +1529,6 @@ int omap_dma_chain_a_transfer(int chain_id, int src_start, int dest_start,
 				if (0 == (l & (1 << 7))) {
 					l |= (1 << 7);
 					dma_chan[lch].state = DMA_CH_STARTED;
-					pr_debug("starting %d\n", lch);
 					p->dma_write(l, CCR, lch);
 				} else
 					start_dma = 0;
@@ -1849,8 +1837,7 @@ static int omap2_dma_handle_ch(int ch)
 
 	if (!status) {
 		if (printk_ratelimit())
-			printk(KERN_WARNING "Spurious DMA IRQ for lch %d\n",
-				ch);
+			printk(KERN_WARNING "Spurious DMA IRQ for lch %d\n", ch);
 		p->dma_write(1 << ch, IRQSTATUS_L0, ch);
 		return 0;
 	}
diff --git a/arch/arm/plat-omap/include/plat/android-display.h b/arch/arm/plat-omap/include/plat/android-display.h
index 038ab20..349514b 100644
--- a/arch/arm/plat-omap/include/plat/android-display.h
+++ b/arch/arm/plat-omap/include/plat/android-display.h
@@ -20,7 +20,7 @@
 
 #define NUM_ANDROID_TILER1D_SLOTS 2
 
-int omap_android_display_setup(struct omap_dss_board_info *dss,
+void omap_android_display_setup(struct omap_dss_board_info *dss,
 				struct dsscomp_platform_data *dsscomp,
 				struct sgx_omaplfb_platform_data *sgx,
 				struct omapfb_platform_data *fb,
diff --git a/arch/arm/plat-omap/include/plat/cpu.h b/arch/arm/plat-omap/include/plat/cpu.h
index a34b157..f0bfec9 100644
--- a/arch/arm/plat-omap/include/plat/cpu.h
+++ b/arch/arm/plat-omap/include/plat/cpu.h
@@ -377,8 +377,8 @@ IS_OMAP_TYPE(3517, 0x3517)
 /* Macros to detect if we have OMAP1 or OMAP2 */
 #define cpu_class_is_omap1()	(cpu_is_omap7xx() || cpu_is_omap15xx() || \
 				cpu_is_omap16xx())
-#define cpu_class_is_omap2()	(cpu_is_omap24xx() || cpu_is_omap34xx() || \
-				cpu_is_omap44xx())
+#define cpu_class_is_omap2()	(cpu_is_omap44xx() || cpu_is_omap34xx() || \
+				cpu_is_omap24xx())
 
 /* Various silicon revisions for omap2 */
 #define OMAP242X_CLASS		0x24200024
diff --git a/arch/arm/plat-omap/include/plat/rpres.h b/arch/arm/plat-omap/include/plat/rpres.h
index 0dfb781..08ca599 100644
--- a/arch/arm/plat-omap/include/plat/rpres.h
+++ b/arch/arm/plat-omap/include/plat/rpres.h
@@ -54,4 +54,6 @@ struct rpres {
 struct rpres *rpres_get(const char *);
 void rpres_put(struct rpres *);
 int rpres_set_constraints(struct rpres *, enum rpres_constraint type, long val);
+unsigned long rpres_get_max_freq(struct rpres *obj);
+
 #endif /* _PLAT_OMAP_RPRES_H */
diff --git a/arch/arm/plat-omap/include/plat/usb.h b/arch/arm/plat-omap/include/plat/usb.h
index 42e299d..f3796d2 100644
--- a/arch/arm/plat-omap/include/plat/usb.h
+++ b/arch/arm/plat-omap/include/plat/usb.h
@@ -58,11 +58,13 @@ struct ehci_hcd_omap_platform_data {
 	 * for low power mode entry
 	 */
 	struct clk			*transceiver_clk[OMAP3_HS_USB_PORTS];
+	int				*usbhs_update_sar;
 };
 
 struct ohci_hcd_omap_platform_data {
 	enum usbhs_omap_port_mode	port_mode[OMAP3_HS_USB_PORTS];
 	unsigned			es2_compatibility:1;
+	int				*usbhs_update_sar;
 };
 
 struct usbhs_omap_platform_data {
@@ -115,6 +117,7 @@ extern int omap4430_phy_set_clk(struct device *dev, int on);
 extern int omap4430_phy_init(struct device *dev);
 extern int omap4430_phy_exit(struct device *dev);
 extern int omap4430_phy_suspend(struct device *dev, int suspend);
+extern int omap4430_usbhs_update_sar(void);
 extern int omap4430_phy_is_active(struct device *dev);
 #endif
 
diff --git a/arch/arm/plat-omap/iommu.c b/arch/arm/plat-omap/iommu.c
index 99a3661..5cd738f 100644
--- a/arch/arm/plat-omap/iommu.c
+++ b/arch/arm/plat-omap/iommu.c
@@ -261,7 +261,6 @@ int load_iotlb_entry(struct iommu *obj, struct iotlb_entry *e)
 				break;
 
 		if (i == obj->nr_tlb_entries) {
-			dev_dbg(obj->dev, "%s: full: no entry\n", __func__);
 			err = -EBUSY;
 			goto out;
 		}
@@ -319,15 +318,10 @@ void flush_iotlb_page(struct iommu *obj, u32 da)
 		bytes = iopgsz_to_bytes(cr.cam & 3);
 
 		if ((start <= da) && (da < start + bytes)) {
-			dev_dbg(obj->dev, "%s: %08x<=%08x(%x)\n",
-				__func__, start, da, bytes);
 			iotlb_load_cr(obj, &cr);
 			iommu_write_reg(obj, 1, MMU_FLUSH_ENTRY);
 		}
 	}
-
-	if (i == obj->nr_tlb_entries)
-		dev_dbg(obj->dev, "%s: no page for %08x\n", __func__, da);
 }
 EXPORT_SYMBOL_GPL(flush_iotlb_page);
 
@@ -460,7 +454,6 @@ static void flush_iopgd_range(u32 *first, u32 *last)
 	outer_flush_range(virt_to_phys(first), virt_to_phys(last));
 }
 
-
 static void flush_iopte_range(u32 *first, u32 *last)
 {
 	dmac_flush_range(first, last);
@@ -494,8 +487,6 @@ static u32 *iopte_alloc(struct iommu *obj, u32 *iopgd, u32 da)
 
 		*iopgd = virt_to_phys(iopte) | IOPGD_TABLE;
 		flush_iopgd_range(iopgd, iopgd + 1);
-
-		dev_vdbg(obj->dev, "%s: a new pte:%p\n", __func__, iopte);
 	} else {
 		/* We raced, free the reduniovant table */
 		iopte_free(iopte);
@@ -504,10 +495,6 @@ static u32 *iopte_alloc(struct iommu *obj, u32 *iopgd, u32 da)
 pte_ready:
 	iopte = iopte_offset(iopgd, da);
 
-	dev_vdbg(obj->dev,
-		 "%s: da:%08x pgd:%p *pgd:%08x pte:%p *pte:%08x\n",
-		 __func__, da, iopgd, *iopgd, iopte, *iopte);
-
 	return iopte;
 }
 
@@ -554,9 +541,6 @@ static int iopte_alloc_page(struct iommu *obj, u32 da, u32 pa, u32 prot)
 	*iopte = (pa & IOPAGE_MASK) | prot | IOPTE_SMALL;
 	flush_iopte_range(iopte, iopte + 1);
 
-	dev_vdbg(obj->dev, "%s: da:%08x pa:%08x pte:%p *pte:%08x\n",
-		 __func__, da, pa, iopte, *iopte);
-
 	return 0;
 }
 
diff --git a/arch/arm/plat-omap/mailbox.c b/arch/arm/plat-omap/mailbox.c
index e26277d..c006751 100644
--- a/arch/arm/plat-omap/mailbox.c
+++ b/arch/arm/plat-omap/mailbox.c
@@ -313,10 +313,10 @@ static void omap_mbox_fini(struct omap_mbox *mbox)
 {
 	mutex_lock(&mbox_configured_lock);
 
-	flush_work_sync(&mbox->rxq->work);
 	if (!--mbox->use_count) {
 		free_irq(mbox->irq, mbox);
 		tasklet_kill(&mbox->txq->tasklet);
+		flush_work_sync(&mbox->rxq->work);
 		mbox_queue_free(mbox->txq);
 		mbox_queue_free(mbox->rxq);
 	}
@@ -364,9 +364,9 @@ EXPORT_SYMBOL(omap_mbox_get);
 
 void omap_mbox_put(struct omap_mbox *mbox, struct notifier_block *nb)
 {
-	omap_mbox_fini(mbox);
 	if (nb)
 		blocking_notifier_chain_unregister(&mbox->notifier, nb);
+	omap_mbox_fini(mbox);
 }
 EXPORT_SYMBOL(omap_mbox_put);
 
diff --git a/arch/arm/plat-omap/mcbsp.c b/arch/arm/plat-omap/mcbsp.c
index 1f7a799..1be15a8 100644
--- a/arch/arm/plat-omap/mcbsp.c
+++ b/arch/arm/plat-omap/mcbsp.c
@@ -549,7 +549,6 @@ int omap_st_is_enabled(unsigned int id)
 	if (!st_data)
 		return -ENODEV;
 
-
 	return st_data->enabled;
 }
 EXPORT_SYMBOL(omap_st_is_enabled);
@@ -1778,7 +1777,7 @@ static inline void __devinit omap34xx_device_init(struct omap_mcbsp *mcbsp)
 		 */
 		mcbsp->max_tx_thres = max_thres(mcbsp) - 0x10;
 		mcbsp->max_rx_thres = max_thres(mcbsp) - 0x10;
-#ifdef CONFIG_SND_OPEN_SOC_SOURCE
+#ifdef CONFIG_SND_OMAP_SOC_WM8994
 		mcbsp->dma_op_mode = MCBSP_DMA_MODE_THRESHOLD;
 #endif
 		/*
diff --git a/arch/arm/plat-omap/omap-pm-helper.c b/arch/arm/plat-omap/omap-pm-helper.c
index 2fdd7af..8e343f9 100644
--- a/arch/arm/plat-omap/omap-pm-helper.c
+++ b/arch/arm/plat-omap/omap-pm-helper.c
@@ -237,8 +237,6 @@ static unsigned long remove_req_tput(struct device *dev)
 		}
 	}
 	if (!found) {
-		/* No such user exists */
-		pr_err("Invalid Device Structure\n");
 		ret = 0;
 		goto unlock;
 	}
diff --git a/arch/arm/plat-omap/omap_rpmsg.c b/arch/arm/plat-omap/omap_rpmsg.c
index 9debd70..dc98eab 100644
--- a/arch/arm/plat-omap/omap_rpmsg.c
+++ b/arch/arm/plat-omap/omap_rpmsg.c
@@ -158,7 +158,6 @@ static void omap_rpmsg_notify(struct virtqueue *vq)
 	int ret;
 	int count = 15;
 
-	pr_debug("sending mailbox msg: %d\n", rpvq->vq_id);
 	do {
 		rproc_last_busy(rpvq->rpdev->rproc);
 		mutex_lock(&rpvq->rpdev->lock);
@@ -187,15 +186,12 @@ static int omap_rpmsg_mbox_callback(struct notifier_block *this,
 
 	rpdev = container_of(this, struct omap_rpmsg_vproc, nb);
 
-	pr_debug("mbox msg: 0x%x\n", msg);
-
 	switch (msg) {
 	case RP_MBOX_CRASH:
 		pr_err("%s has just crashed !\n", rpdev->rproc_name);
 		rproc_error_notify(rpdev->rproc);
 		break;
 	case RP_MBOX_ECHO_REPLY:
-		pr_info("received echo reply from %s !\n", rpdev->rproc_name);
 		break;
 	case RP_MSG_BOOTINIT_DONE:
 		if (rpdev->bootcstr_set) {
@@ -319,9 +315,6 @@ static int rpmsg_rproc_preload(struct omap_rpmsg_vproc *rpdev)
 	if (rpdev->bootcstr_freq) {
 		rpdev->bootcstr_set = !rproc_set_constraints(rpdev->rproc,
 				rpdev->bootcstr_type, rpdev->bootcstr_freq);
-		if (!rpdev->bootcstr_set)
-			pr_debug("bumping the frequency for rproc %s failed\n",
-							rpdev->rproc_name);
 	}
 	mutex_unlock(&rpdev->lock);
 	return NOTIFY_DONE;
@@ -376,9 +369,6 @@ static struct virtqueue *rp_find_vq(struct virtio_device *vdev,
 
 	memset(rpvq->addr, 0, RPMSG_RING_SIZE);
 
-	pr_debug("vring%d: phys 0x%x, virt 0x%x\n", index, rpdev->vring[index],
-					(unsigned int) rpvq->addr);
-
 	vq = vring_new_virtqueue(RPMSG_NUM_BUFS / 2, RPMSG_VRING_ALIGN, vdev,
 				rpvq->addr, omap_rpmsg_notify, callback, name);
 	if (!vq) {
@@ -476,9 +466,6 @@ static int omap_rpmsg_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 		goto unmap_buf;
 	}
 
-	pr_debug("buf: phys 0x%x, virt 0x%x\n", rpdev->buf_addr,
-					(unsigned int) rpdev->buf_mapped);
-
 	/* tell the M3 we're ready. hmm. do we really need this msg */
 	err = omap_mbox_msg_send(rpdev->mbox, RP_MBOX_READY);
 	if (err) {
@@ -703,9 +690,6 @@ static int __init omap_rpmsg_ini(void)
 		paddr += RPMSG_IPC_MEM;
 		psize -= RPMSG_IPC_MEM;
 
-		pr_debug("rpdev%d: buf 0x%x, vring0 0x%x, vring1 0x%x\n", i,
-			rpdev->buf_addr, rpdev->vring[0], rpdev->vring[1]);
-
 		rpdev->vdev.dev.release = omap_rpmsg_vproc_release;
 
 		ret = register_virtio_device(&rpdev->vdev);
diff --git a/arch/arm/plat-omap/sgx_omaplfb.c b/arch/arm/plat-omap/sgx_omaplfb.c
index 5f726f3..569f3c8 100644
--- a/arch/arm/plat-omap/sgx_omaplfb.c
+++ b/arch/arm/plat-omap/sgx_omaplfb.c
@@ -33,7 +33,12 @@
 #define OMAPLFB_NUM_DEV 1
 #endif
 
-static struct sgx_omaplfb_config omaplfb_config[OMAPLFB_NUM_DEV];
+static struct sgx_omaplfb_config omaplfb_config[OMAPLFB_NUM_DEV] = {
+	{
+	.tiler2d_buffers = 2,
+	.swap_chain_length = 2,
+	}
+};
 
 static struct sgx_omaplfb_platform_data omaplfb_plat_data = {
 	.num_configs = OMAPLFB_NUM_DEV,
diff --git a/arch/arm/plat-omap/sram.c b/arch/arm/plat-omap/sram.c
index 7c3d3d7..5ca7bf9 100644
--- a/arch/arm/plat-omap/sram.c
+++ b/arch/arm/plat-omap/sram.c
@@ -250,14 +250,8 @@ static void __init omap_map_sram(void)
 		}
 	}
 
-
 	iotable_init(omap_sram_io_desc, nr_desc);
 
-	pr_info("SRAM: Mapped pa 0x%08llx to va 0x%08lx size: 0x%lx\n",
-		(long long) __pfn_to_phys(omap_sram_io_desc[0].pfn),
-		omap_sram_io_desc[0].virtual,
-		omap_sram_io_desc[0].length);
-
 	/*
 	 * Normally devicemaps_init() would flush caches and tlb after
 	 * mdesc->map_io(), but since we're called from map_io(), we
@@ -399,7 +393,7 @@ static u32 (*_omap3_sram_configure_core_dpll)(
 			u32 sdrc_rfr_ctrl_1, u32 sdrc_actim_ctrl_a_1,
 			u32 sdrc_actim_ctrl_b_1, u32 sdrc_mr_1);
 
-u32 omap3_configure_core_dpll(u32 m2, u32 unlock_dll, u32 f, u32 inc,
+	u32 omap3_configure_core_dpll(u32 m2, u32 unlock_dll, u32 f, u32 inc,
 			u32 sdrc_rfr_ctrl_0, u32 sdrc_actim_ctrl_a_0,
 			u32 sdrc_actim_ctrl_b_0, u32 sdrc_mr_0,
 			u32 sdrc_rfr_ctrl_1, u32 sdrc_actim_ctrl_a_1,
diff --git a/arch/arm/plat-omap/usb.c b/arch/arm/plat-omap/usb.c
index f357088..4a73fbe 100644
--- a/arch/arm/plat-omap/usb.c
+++ b/arch/arm/plat-omap/usb.c
@@ -41,10 +41,6 @@ omap_otg_init(struct omap_usb_config *config)
 	/* NOTE:  no bus or clock setup (yet?) */
 
 	syscon = omap_readl(OTG_SYSCON_1) & 0xffff;
-	if (!(syscon & OTG_RESET_DONE))
-		pr_debug("USB resets not complete?\n");
-
-	//omap_writew(0, OTG_IRQ_EN);
 
 	/* pin muxing and transceiver pinouts */
 	if (config->pins[0] > 2)	/* alt pingroup 2 */
@@ -52,7 +48,6 @@ omap_otg_init(struct omap_usb_config *config)
 	syscon |= config->usb0_init(config->pins[0], is_usb0_device(config));
 	syscon |= config->usb1_init(config->pins[1]);
 	syscon |= config->usb2_init(config->pins[2], alt_pingroup);
-	pr_debug("OTG_SYSCON_1 = %08x\n", omap_readl(OTG_SYSCON_1));
 	omap_writel(syscon, OTG_SYSCON_1);
 
 	syscon = config->hmc_mode;
@@ -61,10 +56,6 @@ omap_otg_init(struct omap_usb_config *config)
 	if (config->otg)
 		syscon |= OTG_EN;
 #endif
-	if (cpu_class_is_omap1())
-		pr_debug("USB_TRANSCEIVER_CTRL = %03x\n",
-			 omap_readl(USB_TRANSCEIVER_CTRL));
-	pr_debug("OTG_SYSCON_2 = %08x\n", omap_readl(OTG_SYSCON_2));
 	omap_writel(syscon, OTG_SYSCON_2);
 
 	printk("USB: hmc %d", config->hmc_mode);
@@ -73,6 +64,7 @@ omap_otg_init(struct omap_usb_config *config)
 	else if (config->pins[0])
 		printk(", usb0 %d wires%s", config->pins[0],
 			is_usb0_device(config) ? " (dev)" : "");
+
 	if (config->pins[1])
 		printk(", usb1 %d wires", config->pins[1]);
 	if (!alt_pingroup && config->pins[2])
@@ -104,8 +96,6 @@ omap_otg_init(struct omap_usb_config *config)
 		syscon &= ~DEV_IDLE_EN;
 		udc_device->dev.platform_data = config;
 		status = platform_device_register(udc_device);
-		if (status)
-			pr_debug("can't register UDC device, %d\n", status);
 	}
 #endif
 
@@ -116,8 +106,6 @@ omap_otg_init(struct omap_usb_config *config)
 		syscon &= ~HST_IDLE_EN;
 		ohci_device->dev.platform_data = config;
 		status = platform_device_register(ohci_device);
-		if (status)
-			pr_debug("can't register OHCI device, %d\n", status);
 	}
 #endif
 
@@ -128,13 +116,9 @@ omap_otg_init(struct omap_usb_config *config)
 		syscon &= ~OTG_IDLE_EN;
 		otg_device->dev.platform_data = config;
 		status = platform_device_register(otg_device);
-		if (status)
-			pr_debug("can't register OTG device, %d\n", status);
 	}
 #endif
-	pr_debug("OTG_SYSCON_1 = %08x\n", omap_readl(OTG_SYSCON_1));
 	omap_writel(syscon, OTG_SYSCON_1);
-
 	status = 0;
 }
 
diff --git a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c
index 214b002..b817db1 100644
--- a/arch/arm/plat-orion/common.c
+++ b/arch/arm/plat-orion/common.c
@@ -343,7 +343,7 @@ static struct resource orion_ge10_shared_resources[] = {
 
 static struct platform_device orion_ge10_shared = {
 	.name		= MV643XX_ETH_SHARED_NAME,
-	.id		= 2,
+	.id		= 1,
 	.dev		= {
 		.platform_data	= &orion_ge10_shared_data,
 	},
@@ -358,8 +358,8 @@ static struct resource orion_ge10_resources[] = {
 
 static struct platform_device orion_ge10 = {
 	.name		= MV643XX_ETH_NAME,
-	.id		= 2,
-	.num_resources	= 1,
+	.id		= 1,
+	.num_resources	= 2,
 	.resource	= orion_ge10_resources,
 	.dev		= {
 		.coherent_dma_mask	= DMA_BIT_MASK(32),
@@ -397,7 +397,7 @@ static struct resource orion_ge11_shared_resources[] = {
 
 static struct platform_device orion_ge11_shared = {
 	.name		= MV643XX_ETH_SHARED_NAME,
-	.id		= 3,
+	.id		= 1,
 	.dev		= {
 		.platform_data	= &orion_ge11_shared_data,
 	},
@@ -412,8 +412,8 @@ static struct resource orion_ge11_resources[] = {
 
 static struct platform_device orion_ge11 = {
 	.name		= MV643XX_ETH_NAME,
-	.id		= 3,
-	.num_resources	= 1,
+	.id		= 1,
+	.num_resources	= 2,
 	.resource	= orion_ge11_resources,
 	.dev		= {
 		.coherent_dma_mask	= DMA_BIT_MASK(32),
@@ -809,7 +809,6 @@ void __init orion_xor1_init(unsigned long mapbase_low,
 static struct orion_ehci_data orion_ehci_data;
 static u64 ehci_dmamask = DMA_BIT_MASK(32);
 
-
 /*****************************************************************************
  * EHCI0
  ****************************************************************************/

diff --git a/arch/um/include/asm/pgtable.h b/arch/um/include/asm/pgtable.h
index 7896c5a..bd05162 100644
--- a/arch/um/include/asm/pgtable.h
+++ b/arch/um/include/asm/pgtable.h
@@ -69,8 +69,6 @@ extern unsigned long end_iomem;
 #define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED)
 #define PAGE_KERNEL_EXEC	__pgprot(__PAGE_KERNEL_EXEC)
 
-#define io_remap_pfn_range	remap_pfn_range
-
 /*
  * The i386 can't do page protection for execute, and considers that the same
  * are read.
@@ -137,7 +135,7 @@ static inline int pte_none(pte_t pte)
  * Undefined behaviour if not..
  */
 static inline int pte_read(pte_t pte)
-{ 
+{
 	return((pte_get_bits(pte, _PAGE_USER)) &&
 	       !(pte_get_bits(pte, _PAGE_PROTNONE)));
 }
@@ -177,7 +175,7 @@ static inline int pte_newpage(pte_t pte)
 }
 
 static inline int pte_newprot(pte_t pte)
-{ 
+{
 	return(pte_present(pte) && (pte_get_bits(pte, _PAGE_NEWPROT)));
 }
 
@@ -204,26 +202,26 @@ static inline pte_t pte_mkclean(pte_t pte)
 	return(pte);
 }
 
-static inline pte_t pte_mkold(pte_t pte)	
-{ 
+static inline pte_t pte_mkold(pte_t pte)
+{
 	pte_clear_bits(pte, _PAGE_ACCESSED);
 	return(pte);
 }
 
 static inline pte_t pte_wrprotect(pte_t pte)
-{ 
+{
 	pte_clear_bits(pte, _PAGE_RW);
-	return(pte_mknewprot(pte)); 
+	return(pte_mknewprot(pte));
 }
 
 static inline pte_t pte_mkread(pte_t pte)
-{ 
+{
 	pte_set_bits(pte, _PAGE_USER);
-	return(pte_mknewprot(pte)); 
+	return(pte_mknewprot(pte));
 }
 
 static inline pte_t pte_mkdirty(pte_t pte)
-{ 
+{
 	pte_set_bits(pte, _PAGE_DIRTY);
 	return(pte);
 }
@@ -234,18 +232,18 @@ static inline pte_t pte_mkyoung(pte_t pte)
 	return(pte);
 }
 
-static inline pte_t pte_mkwrite(pte_t pte)	
+static inline pte_t pte_mkwrite(pte_t pte)
 {
 	pte_set_bits(pte, _PAGE_RW);
-	return(pte_mknewprot(pte)); 
+	return(pte_mknewprot(pte));
 }
 
-static inline pte_t pte_mkuptodate(pte_t pte)	
+static inline pte_t pte_mkuptodate(pte_t pte)
 {
 	pte_clear_bits(pte, _PAGE_NEWPAGE);
 	if(pte_present(pte))
 		pte_clear_bits(pte, _PAGE_NEWPROT);
-	return(pte); 
+	return(pte);
 }
 
 static inline pte_t pte_mknewpage(pte_t pte)
@@ -300,7 +298,7 @@ static inline int pte_same(pte_t pte_a, pte_t pte_b)
 static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 {
 	pte_set_val(pte, (pte_val(pte) & _PAGE_CHG_MASK), newprot);
-	return pte; 
+	return pte;
 }
 
 /*
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index bb79ae1..46dd572 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -389,8 +389,8 @@ struct kvm_vcpu_arch {
 	gpa_t time;
 	struct pvclock_vcpu_time_info hv_clock;
 	unsigned int hw_tsc_khz;
-	struct gfn_to_hva_cache pv_time;
-	bool pv_time_enabled;
+	unsigned int time_offset;
+	struct page *time_page;
 	u64 last_guest_tsc;
 	u64 last_kernel_ns;
 	u64 last_tsc_nsec;
diff --git a/arch/x86/include/asm/mmzone_32.h b/arch/x86/include/asm/mmzone_32.h
index a6a6414..ffa037f 100644
--- a/arch/x86/include/asm/mmzone_32.h
+++ b/arch/x86/include/asm/mmzone_32.h
@@ -14,6 +14,12 @@ extern struct pglist_data *node_data[];
 
 #include <asm/numaq.h>
 
+extern void resume_map_numa_kva(pgd_t *pgd);
+
+#else /* !CONFIG_NUMA */
+
+static inline void resume_map_numa_kva(pgd_t *pgd) {}
+
 #endif /* CONFIG_NUMA */
 
 #ifdef CONFIG_DISCONTIGMEM
diff --git a/arch/x86/include/asm/paravirt.h b/arch/x86/include/asm/paravirt.h
index 2fdfe31..a93715b 100644
--- a/arch/x86/include/asm/paravirt.h
+++ b/arch/x86/include/asm/paravirt.h
@@ -731,10 +731,7 @@ static inline void arch_leave_lazy_mmu_mode(void)
 	PVOP_VCALL0(pv_mmu_ops.lazy_mode.leave);
 }
 
-static inline void arch_flush_lazy_mmu_mode(void)
-{
-	PVOP_VCALL0(pv_mmu_ops.lazy_mode.flush);
-}
+void arch_flush_lazy_mmu_mode(void);
 
 static inline void __set_fixmap(unsigned /* enum fixed_addresses */ idx,
 				phys_addr_t phys, pgprot_t flags)
diff --git a/arch/x86/include/asm/paravirt_types.h b/arch/x86/include/asm/paravirt_types.h
index 4b67ec9..166bc80 100644
--- a/arch/x86/include/asm/paravirt_types.h
+++ b/arch/x86/include/asm/paravirt_types.h
@@ -80,12 +80,10 @@ struct pv_init_ops {
 			  unsigned long addr, unsigned len);
 };
 
-
 struct pv_lazy_ops {
 	/* Set deferred update mode, used for batching operations. */
 	void (*enter)(void);
 	void (*leave)(void);
-	void (*flush)(void);
 };
 
 struct pv_time_ops {
@@ -237,7 +235,6 @@ struct pv_mmu_ops {
 			 struct mm_struct *mm);
 	void (*exit_mmap)(struct mm_struct *mm);
 
-
 	/* TLB operations */
 	void (*flush_tlb_user)(void);
 	void (*flush_tlb_kernel)(void);
@@ -567,7 +564,6 @@ int paravirt_disable_iospace(void);
 		      PVOP_CALLEE_CLOBBERS, ,				\
 		      pre, post, ##__VA_ARGS__)
 
-
 #define ____PVOP_VCALL(op, clbr, call_clbr, extra_clbr, pre, post, ...)	\
 	({								\
 		PVOP_VCALL_ARGS;					\
@@ -592,8 +588,6 @@ int paravirt_disable_iospace(void);
 		      PVOP_VCALLEE_CLOBBERS, ,				\
 		      pre, post, ##__VA_ARGS__)
 
-
-
 #define PVOP_CALL0(rettype, op)						\
 	__PVOP_CALL(rettype, op, "", "")
 #define PVOP_VCALL0(op)							\
@@ -604,7 +598,6 @@ int paravirt_disable_iospace(void);
 #define PVOP_VCALLEE0(op)						\
 	__PVOP_VCALLEESAVE(op, "", "")
 
-
 #define PVOP_CALL1(rettype, op, arg1)					\
 	__PVOP_CALL(rettype, op, "", "", PVOP_CALL_ARG1(arg1))
 #define PVOP_VCALL1(op, arg1)						\
@@ -615,7 +608,6 @@ int paravirt_disable_iospace(void);
 #define PVOP_VCALLEE1(op, arg1)						\
 	__PVOP_VCALLEESAVE(op, "", "", PVOP_CALL_ARG1(arg1))
 
-
 #define PVOP_CALL2(rettype, op, arg1, arg2)				\
 	__PVOP_CALL(rettype, op, "", "", PVOP_CALL_ARG1(arg1),		\
 		    PVOP_CALL_ARG2(arg2))
@@ -630,7 +622,6 @@ int paravirt_disable_iospace(void);
 	__PVOP_VCALLEESAVE(op, "", "", PVOP_CALL_ARG1(arg1),		\
 			   PVOP_CALL_ARG2(arg2))
 
-
 #define PVOP_CALL3(rettype, op, arg1, arg2, arg3)			\
 	__PVOP_CALL(rettype, op, "", "", PVOP_CALL_ARG1(arg1),		\
 		    PVOP_CALL_ARG2(arg2), PVOP_CALL_ARG3(arg3))
@@ -674,7 +665,6 @@ void paravirt_end_context_switch(struct task_struct *next);
 
 void paravirt_enter_lazy_mmu(void);
 void paravirt_leave_lazy_mmu(void);
-void paravirt_flush_lazy_mmu(void);
 
 void _paravirt_nop(void);
 u32 _paravirt_ident_32(u32);
diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
index 6be9909..729dffb 100644
--- a/arch/x86/include/asm/pgtable.h
+++ b/arch/x86/include/asm/pgtable.h
@@ -142,16 +142,12 @@ static inline unsigned long pmd_pfn(pmd_t pmd)
 	return (pmd_val(pmd) & PTE_PFN_MASK) >> PAGE_SHIFT;
 }
 
-static inline unsigned long pud_pfn(pud_t pud)
-{
-	return (pud_val(pud) & PTE_PFN_MASK) >> PAGE_SHIFT;
-}
-
 #define pte_page(pte)	pfn_to_page(pte_pfn(pte))
 
 static inline int pmd_large(pmd_t pte)
 {
-	return pmd_flags(pte) & _PAGE_PSE;
+	return (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==
+		(_PAGE_PSE | _PAGE_PRESENT);
 }
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
@@ -419,13 +415,7 @@ static inline int pte_hidden(pte_t pte)
 
 static inline int pmd_present(pmd_t pmd)
 {
-	/*
-	 * Checking for _PAGE_PSE is needed too because
-	 * split_huge_page will temporarily clear the present bit (but
-	 * the _PAGE_PSE flag will remain set at all times while the
-	 * _PAGE_PRESENT bit is clear).
-	 */
-	return pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);
+	return pmd_flags(pmd) & _PAGE_PRESENT;
 }
 
 static inline int pmd_none(pmd_t pmd)
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index e5f7248..7aceb23 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -99,6 +99,7 @@ struct cpuinfo_x86 {
 	u16			apicid;
 	u16			initial_apicid;
 	u16			x86_clflush_size;
+#ifdef CONFIG_SMP
 	/* number of cores as seen by the OS: */
 	u16			booted_cores;
 	/* Physical processor id: */
@@ -109,6 +110,7 @@ struct cpuinfo_x86 {
 	u8			compute_unit_id;
 	/* Index into per_cpu list: */
 	u16			cpu_index;
+#endif
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
 
 #define X86_VENDOR_INTEL	0
@@ -620,7 +622,6 @@ typedef struct {
 	unsigned long		seg;
 } mm_segment_t;
 
-
 /*
  * create a kernel thread without removing it from tasklists
  */
diff --git a/arch/x86/include/asm/ptrace.h b/arch/x86/include/asm/ptrace.h
index bdab62f..d19f612 100644
--- a/arch/x86/include/asm/ptrace.h
+++ b/arch/x86/include/asm/ptrace.h
@@ -186,14 +186,21 @@ static inline int v8086_mode(struct pt_regs *regs)
 #endif
 }
 
-#ifdef CONFIG_X86_32
-extern unsigned long kernel_stack_pointer(struct pt_regs *regs);
-#else
+/*
+ * X86_32 CPUs don't save ss and esp if the CPU is already in kernel mode
+ * when it traps.  The previous stack will be directly underneath the saved
+ * registers, and 'sp/ss' won't even have been saved. Thus the '&regs->sp'.
+ *
+ * This is valid only for kernel mode traps.
+ */
 static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
 {
+#ifdef CONFIG_X86_32
+	return (unsigned long)(&regs->sp);
+#else
 	return regs->sp;
-}
 #endif
+}
 
 #define GET_IP(regs) ((regs)->ip)
 #define GET_FP(regs) ((regs)->bp)
diff --git a/arch/x86/include/asm/signal.h b/arch/x86/include/asm/signal.h
index 6cbc795..fc80ddc 100644
--- a/arch/x86/include/asm/signal.h
+++ b/arch/x86/include/asm/signal.h
@@ -125,8 +125,6 @@ typedef unsigned long sigset_t;
 extern void do_notify_resume(struct pt_regs *, void *, __u32);
 # endif /* __KERNEL__ */
 
-#define __ARCH_HAS_SA_RESTORER
-
 #ifdef __i386__
 # ifdef __KERNEL__
 struct old_sigaction {
@@ -213,7 +211,6 @@ static inline void __const_sigaddset(sigset_t *set, int _sig)
 	 ? __const_sigdelset((set), (sig))  \
 	 : __gen_sigdelset((set), (sig)))
 
-
 static inline void __gen_sigdelset(sigset_t *set, int _sig)
 {
 	asm("btrl %1,%0" : "+m"(*set) : "Ir"(_sig - 1) : "cc");
diff --git a/arch/x86/include/asm/system.h b/arch/x86/include/asm/system.h
index f0d89d9..c2ff2a1 100644
--- a/arch/x86/include/asm/system.h
+++ b/arch/x86/include/asm/system.h
@@ -93,6 +93,10 @@ do {									\
 			"memory");					\
 } while (0)
 
+/*
+ * disable hlt during certain critical i/o operations
+ */
+#define HAVE_DISABLE_HLT
 #else
 
 /* frame pointer must be last for get_wchan */
@@ -388,6 +392,9 @@ static inline void clflush(volatile void *__p)
 
 #define nop() asm volatile ("nop")
 
+void disable_hlt(void);
+void enable_hlt(void);
+
 void cpu_idle_wait(void);
 
 extern unsigned long arch_align_stack(unsigned long sp);
diff --git a/arch/x86/include/asm/traps.h b/arch/x86/include/asm/traps.h
index 1d44903..0310da6 100644
--- a/arch/x86/include/asm/traps.h
+++ b/arch/x86/include/asm/traps.h
@@ -1,7 +1,6 @@
 #ifndef _ASM_X86_TRAPS_H
 #define _ASM_X86_TRAPS_H
 
-#include <linux/kprobes.h>
 #include <asm/debugreg.h>
 #include <asm/siginfo.h>			/* TRAP_TRACE, ... */
 
@@ -88,29 +87,4 @@ asmlinkage void smp_thermal_interrupt(void);
 asmlinkage void mce_threshold_interrupt(void);
 #endif
 
-/* Interrupts/Exceptions */
-enum {
-	X86_TRAP_DE = 0,	/*  0, Divide-by-zero */
-	X86_TRAP_DB,		/*  1, Debug */
-	X86_TRAP_NMI,		/*  2, Non-maskable Interrupt */
-	X86_TRAP_BP,		/*  3, Breakpoint */
-	X86_TRAP_OF,		/*  4, Overflow */
-	X86_TRAP_BR,		/*  5, Bound Range Exceeded */
-	X86_TRAP_UD,		/*  6, Invalid Opcode */
-	X86_TRAP_NM,		/*  7, Device Not Available */
-	X86_TRAP_DF,		/*  8, Double Fault */
-	X86_TRAP_OLD_MF,	/*  9, Coprocessor Segment Overrun */
-	X86_TRAP_TS,		/* 10, Invalid TSS */
-	X86_TRAP_NP,		/* 11, Segment Not Present */
-	X86_TRAP_SS,		/* 12, Stack Segment Fault */
-	X86_TRAP_GP,		/* 13, General Protection Fault */
-	X86_TRAP_PF,		/* 14, Page Fault */
-	X86_TRAP_SPURIOUS,	/* 15, Spurious Interrupt */
-	X86_TRAP_MF,		/* 16, x87 Floating-Point Exception */
-	X86_TRAP_AC,		/* 17, Alignment Check */
-	X86_TRAP_MC,		/* 18, Machine Check */
-	X86_TRAP_XF,		/* 19, SIMD Floating-Point Exception */
-	X86_TRAP_IRET = 32,	/* 32, IRET Exception */
-};
-
 #endif /* _ASM_X86_TRAPS_H */
diff --git a/block/Kconfig.iosched b/block/Kconfig.iosched
index 3199b76..e30fbec 100644
--- a/block/Kconfig.iosched
+++ b/block/Kconfig.iosched
@@ -14,7 +14,7 @@ config IOSCHED_NOOP
 
 config IOSCHED_DEADLINE
 	tristate "Deadline I/O scheduler"
-	default y
+	default n
 	---help---
 	  The deadline I/O scheduler is simple and compact. It will provide
 	  CSCAN service with FIFO expiration of requests, switching to
@@ -23,7 +23,6 @@ config IOSCHED_DEADLINE
 
 config IOSCHED_CFQ
 	tristate "CFQ I/O scheduler"
-	# If BLK_CGROUP is a module, CFQ has to be built as module.
 	depends on (BLK_CGROUP=m && m) || !BLK_CGROUP || BLK_CGROUP=y
 	default y
 	---help---
@@ -32,8 +31,6 @@ config IOSCHED_CFQ
 	  and low latency working environment, suitable for both desktop
 	  and server systems.
 
-	  This is the default I/O scheduler.
-
 	  Note: If BLK_CGROUP=m, then CFQ can be built only as module.
 
 config CFQ_GROUP_IOSCHED
@@ -50,22 +47,22 @@ choice
 	  Select the I/O scheduler which will be used by default for all
 	  block devices.
 
+	config DEFAULT_NOOP
+		bool "No-op"
+
 	config DEFAULT_DEADLINE
 		bool "Deadline" if IOSCHED_DEADLINE=y
 
 	config DEFAULT_CFQ
 		bool "CFQ" if IOSCHED_CFQ=y
 
-	config DEFAULT_NOOP
-		bool "No-op"
-
 endchoice
 
 config DEFAULT_IOSCHED
 	string
+	default "noop" if DEFAULT_NOOP
 	default "deadline" if DEFAULT_DEADLINE
 	default "cfq" if DEFAULT_CFQ
-	default "noop" if DEFAULT_NOOP
 
 endmenu
 
diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index cb0f1a0..6b22106 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -307,7 +307,7 @@ static struct queue_sysfs_entry queue_max_segment_size_entry = {
 };
 
 static struct queue_sysfs_entry queue_iosched_entry = {
-	.attr = {.name = "scheduler", .mode = S_IRUGO | S_IWUSR },
+	.attr = {.name = "scheduler", .mode = S_IRUGO | S_IWUSR | S_IWGRP},
 	.show = elv_iosched_show,
 	.store = elv_iosched_store,
 };
diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index f4369da..a309d99 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -497,7 +497,6 @@ static inline bool cfq_bio_sync(struct bio *bio)
 static inline void cfq_schedule_dispatch(struct cfq_data *cfqd)
 {
 	if (cfqd->busy_queues) {
-		cfq_log(cfqd, "schedule dispatch");
 		kblockd_schedule_work(cfqd->queue, &cfqd->unplug_work);
 	}
 }
@@ -628,7 +627,6 @@ cfq_set_prio_slice(struct cfq_data *cfqd, struct cfq_queue *cfqq)
 	cfqq->slice_start = jiffies;
 	cfqq->slice_end = jiffies + slice;
 	cfqq->allocated_slice = slice;
-	cfq_log_cfqq(cfqd, cfqq, "set_slice=%lu", cfqq->slice_end - jiffies);
 }
 
 /*
@@ -915,7 +913,6 @@ cfq_group_notify_queue_del(struct cfq_data *cfqd, struct cfq_group *cfqg)
 	if (cfqg->nr_cfqq)
 		return;
 
-	cfq_log_cfqg(cfqd, cfqg, "del_from_rr group");
 	cfq_group_service_tree_del(st, cfqg);
 	cfqg->saved_workload_slice = 0;
 	cfq_blkiocg_update_dequeue_stats(&cfqg->blkg, 1);
@@ -984,12 +981,6 @@ static void cfq_group_served(struct cfq_data *cfqd, struct cfq_group *cfqg,
 	} else
 		cfqg->saved_workload_slice = 0;
 
-	cfq_log_cfqg(cfqd, cfqg, "served: vt=%llu min_vt=%llu", cfqg->vdisktime,
-					st->min_vdisktime);
-	cfq_log_cfqq(cfqq->cfqd, cfqq,
-		     "sl_used=%u disp=%u charge=%u iops=%u sect=%lu",
-		     used_sl, cfqq->slice_dispatch, charge,
-		     iops_mode(cfqd), cfqq->nr_sectors);
 	cfq_blkiocg_update_timeslice_used(&cfqg->blkg, used_sl,
 					  unaccounted_sl);
 	cfq_blkiocg_set_start_empty_time(&cfqg->blkg);
@@ -1434,7 +1425,6 @@ static void cfq_resort_rr_list(struct cfq_data *cfqd, struct cfq_queue *cfqq)
  */
 static void cfq_add_cfqq_rr(struct cfq_data *cfqd, struct cfq_queue *cfqq)
 {
-	cfq_log_cfqq(cfqd, cfqq, "add_to_rr");
 	BUG_ON(cfq_cfqq_on_rr(cfqq));
 	cfq_mark_cfqq_on_rr(cfqq);
 	cfqd->busy_queues++;
@@ -1450,7 +1440,6 @@ static void cfq_add_cfqq_rr(struct cfq_data *cfqd, struct cfq_queue *cfqq)
  */
 static void cfq_del_cfqq_rr(struct cfq_data *cfqd, struct cfq_queue *cfqq)
 {
-	cfq_log_cfqq(cfqd, cfqq, "del_from_rr");
 	BUG_ON(!cfq_cfqq_on_rr(cfqq));
 	cfq_clear_cfqq_on_rr(cfqq);
 
@@ -1567,8 +1556,6 @@ static void cfq_activate_request(struct request_queue *q, struct request *rq)
 	struct cfq_data *cfqd = q->elevator->elevator_data;
 
 	cfqd->rq_in_driver++;
-	cfq_log_cfqq(cfqd, RQ_CFQQ(rq), "activate rq, drv=%d",
-						cfqd->rq_in_driver);
 
 	cfqd->last_position = blk_rq_pos(rq) + blk_rq_sectors(rq);
 }
@@ -1579,8 +1566,6 @@ static void cfq_deactivate_request(struct request_queue *q, struct request *rq)
 
 	WARN_ON(!cfqd->rq_in_driver);
 	cfqd->rq_in_driver--;
-	cfq_log_cfqq(cfqd, RQ_CFQQ(rq), "deactivate rq, drv=%d",
-						cfqd->rq_in_driver);
 }
 
 static void cfq_remove_request(struct request *rq)
@@ -1690,8 +1675,6 @@ static void __cfq_set_active_queue(struct cfq_data *cfqd,
 				   struct cfq_queue *cfqq)
 {
 	if (cfqq) {
-		cfq_log_cfqq(cfqd, cfqq, "set_active wl_prio:%d wl_type:%d",
-				cfqd->serving_prio, cfqd->serving_type);
 		cfq_blkiocg_update_avg_queue_size_stats(&cfqq->cfqg->blkg);
 		cfqq->slice_start = 0;
 		cfqq->dispatch_start = jiffies;
@@ -1719,8 +1702,6 @@ static void
 __cfq_slice_expired(struct cfq_data *cfqd, struct cfq_queue *cfqq,
 		    bool timed_out)
 {
-	cfq_log_cfqq(cfqd, cfqq, "slice expired t=%d", timed_out);
-
 	if (cfq_cfqq_wait_request(cfqq))
 		cfq_del_timer(cfqd, cfqq);
 
@@ -1744,7 +1725,6 @@ __cfq_slice_expired(struct cfq_data *cfqd, struct cfq_queue *cfqq,
 			cfqq->slice_resid = cfq_scaled_cfqq_slice(cfqd, cfqq);
 		else
 			cfqq->slice_resid = cfqq->slice_end - jiffies;
-		cfq_log_cfqq(cfqd, cfqq, "resid=%ld", cfqq->slice_resid);
 	}
 
 	cfq_group_served(cfqd, cfqq->cfqg, cfqq);
@@ -1969,8 +1949,6 @@ static bool cfq_should_idle(struct cfq_data *cfqd, struct cfq_queue *cfqq)
 	 */
 	if (service_tree->count == 1 && cfq_cfqq_sync(cfqq))
 		return true;
-	cfq_log_cfqq(cfqd, cfqq, "Not idling. st->count:%d",
-			service_tree->count);
 	return false;
 }
 
@@ -2022,8 +2000,6 @@ static void cfq_arm_slice_timer(struct cfq_data *cfqd)
 	 */
 	if (sample_valid(cic->ttime_samples) &&
 	    (cfqq->slice_end - jiffies < cic->ttime_mean)) {
-		cfq_log_cfqq(cfqd, cfqq, "Not idling. think_time:%lu",
-			     cic->ttime_mean);
 		return;
 	}
 
@@ -2040,8 +2016,6 @@ static void cfq_arm_slice_timer(struct cfq_data *cfqd)
 
 	mod_timer(&cfqd->idle_slice_timer, jiffies + sl);
 	cfq_blkiocg_update_set_idle_time_stats(&cfqq->cfqg->blkg);
-	cfq_log_cfqq(cfqd, cfqq, "arm_idle: %lu group_idle: %d", sl,
-			group_idle ? 1 : 0);
 }
 
 /*
@@ -2052,8 +2026,6 @@ static void cfq_dispatch_insert(struct request_queue *q, struct request *rq)
 	struct cfq_data *cfqd = q->elevator->elevator_data;
 	struct cfq_queue *cfqq = RQ_CFQQ(rq);
 
-	cfq_log_cfqq(cfqd, cfqq, "dispatch_insert");
-
 	cfqq->next_rq = cfq_find_next_rq(cfqd, cfqq, rq);
 	cfq_remove_request(rq);
 	cfqq->dispatched++;
@@ -2086,7 +2058,6 @@ static struct request *cfq_check_fifo(struct cfq_queue *cfqq)
 	if (time_before(jiffies, rq_fifo_time(rq)))
 		rq = NULL;
 
-	cfq_log_cfqq(cfqq->cfqd, cfqq, "fifo=%p", rq);
 	return rq;
 }
 
@@ -2254,7 +2225,6 @@ new_workload:
 		slice = max(slice, 2 * cfqd->cfq_slice_idle);
 
 	slice = max_t(unsigned, slice, CFQ_MIN_TT);
-	cfq_log(cfqd, "workload slice:%d", slice);
 	cfqd->workload_expires = jiffies + slice;
 }
 
@@ -2435,7 +2405,6 @@ static int cfq_forced_dispatch(struct cfq_data *cfqd)
 
 	BUG_ON(cfqd->busy_queues);
 
-	cfq_log(cfqd, "forced_dispatch=%d", dispatched);
 	return dispatched;
 }
 
@@ -2611,7 +2580,6 @@ static int cfq_dispatch_requests(struct request_queue *q, int force)
 		cfq_slice_expired(cfqd, 0);
 	}
 
-	cfq_log_cfqq(cfqd, cfqq, "dispatched a request");
 	return 1;
 }
 
@@ -2633,7 +2601,6 @@ static void cfq_put_queue(struct cfq_queue *cfqq)
 	if (cfqq->ref)
 		return;
 
-	cfq_log_cfqq(cfqd, cfqq, "put_queue");
 	BUG_ON(rb_first(&cfqq->sort_list));
 	BUG_ON(cfqq->allocated[READ] + cfqq->allocated[WRITE]);
 	cfqg = cfqq->cfqg;
@@ -2961,7 +2928,6 @@ static void changed_cgroup(struct io_context *ioc, struct cfq_io_context *cic)
 		 * Drop reference to sync queue. A new sync queue will be
 		 * assigned in new group upon arrival of a fresh request.
 		 */
-		cfq_log_cfqq(cfqd, sync_cfqq, "changed cgroup");
 		cic_set_cfqq(cic, NULL, 1);
 		cfq_put_queue(sync_cfqq);
 	}
@@ -3017,7 +2983,6 @@ retry:
 			cfq_init_cfqq(cfqd, cfqq, current->pid, is_sync);
 			cfq_init_prio_data(cfqq, ioc);
 			cfq_link_cfqq_cfqg(cfqq, cfqg);
-			cfq_log_cfqq(cfqd, cfqq, "alloced");
 		} else
 			cfqq = &cfqd->oom_cfqq;
 	}
@@ -3291,7 +3256,6 @@ cfq_update_idle_window(struct cfq_data *cfqd, struct cfq_queue *cfqq,
 	}
 
 	if (old_idle != enable_idle) {
-		cfq_log_cfqq(cfqd, cfqq, "idle=%d", enable_idle);
 		if (enable_idle)
 			cfq_mark_cfqq_idle_window(cfqq);
 		else
@@ -3383,7 +3347,6 @@ static void cfq_preempt_queue(struct cfq_data *cfqd, struct cfq_queue *cfqq)
 {
 	struct cfq_queue *old_cfqq = cfqd->active_queue;
 
-	cfq_log_cfqq(cfqd, cfqq, "preempt");
 	cfq_slice_expired(cfqd, 1);
 
 	/*
@@ -3465,7 +3428,6 @@ static void cfq_insert_request(struct request_queue *q, struct request *rq)
 	struct cfq_data *cfqd = q->elevator->elevator_data;
 	struct cfq_queue *cfqq = RQ_CFQQ(rq);
 
-	cfq_log_cfqq(cfqd, cfqq, "insert_request");
 	cfq_init_prio_data(cfqq, RQ_CIC(rq)->ioc);
 
 	rq_set_fifo_time(rq, jiffies + cfqd->cfq_fifo_expire[rq_is_sync(rq)]);
@@ -3555,8 +3517,6 @@ static void cfq_completed_request(struct request_queue *q, struct request *rq)
 	unsigned long now;
 
 	now = jiffies;
-	cfq_log_cfqq(cfqd, cfqq, "complete rqnoidle %d",
-		     !!(rq->cmd_flags & REQ_NOIDLE));
 
 	cfq_update_hw_tag(cfqd);
 
@@ -3599,7 +3559,6 @@ static void cfq_completed_request(struct request_queue *q, struct request *rq)
 				extend_sl = cfqd->cfq_group_idle;
 			cfqq->slice_end = jiffies + extend_sl;
 			cfq_mark_cfqq_wait_busy(cfqq);
-			cfq_log_cfqq(cfqd, cfqq, "will busy wait");
 		}
 
 		/*
@@ -3717,7 +3676,6 @@ static struct cfq_queue *
 cfq_merge_cfqqs(struct cfq_data *cfqd, struct cfq_io_context *cic,
 		struct cfq_queue *cfqq)
 {
-	cfq_log_cfqq(cfqd, cfqq, "merging with queue %p", cfqq->new_cfqq);
 	cic_set_cfqq(cic, cfqq->new_cfqq, 1);
 	cfq_mark_cfqq_coop(cfqq->new_cfqq);
 	cfq_put_queue(cfqq);
@@ -3777,7 +3735,6 @@ new_queue:
 		 * If the queue was seeky for too long, break it apart.
 		 */
 		if (cfq_cfqq_coop(cfqq) && cfq_cfqq_split_coop(cfqq)) {
-			cfq_log_cfqq(cfqd, cfqq, "breaking apart cfqq");
 			cfqq = split_cfqq(cic, cfqq);
 			if (!cfqq)
 				goto new_queue;
@@ -3805,7 +3762,6 @@ new_queue:
 queue_fail:
 	cfq_schedule_dispatch(cfqd);
 	spin_unlock_irqrestore(q->queue_lock, flags);
-	cfq_log(cfqd, "set_request fail");
 	return 1;
 }
 
@@ -3830,8 +3786,6 @@ static void cfq_idle_slice_timer(unsigned long data)
 	unsigned long flags;
 	int timed_out = 1;
 
-	cfq_log(cfqd, "idle timer fired");
-
 	spin_lock_irqsave(cfqd->queue->queue_lock, flags);
 
 	cfqq = cfqd->active_queue;
diff --git a/block/deadline-iosched.c b/block/deadline-iosched.c
index 5139c0e..b05d925 100644
--- a/block/deadline-iosched.c
+++ b/block/deadline-iosched.c
@@ -17,11 +17,11 @@
 /*
  * See Documentation/block/deadline-iosched.txt
  */
-static const int read_expire = HZ / 2;  /* max time before a read is submitted. */
+static const int read_expire = HZ / 4;  /* max time before a read is submitted. */
 static const int write_expire = 5 * HZ; /* ditto for writes, these limits are SOFT! */
-static const int writes_starved = 2;    /* max times reads can starve a write */
-static const int fifo_batch = 16;       /* # of sequential requests treated as one
-				     by the above parameters. For throughput. */
+static const int writes_starved = 4;    /* max times reads can starve a write */
+static const int fifo_batch = 1;        /* Sequential requests treated as one
+				                           by the above parameters. For throughput. */
 
 struct deadline_data {
 	/*
@@ -31,7 +31,7 @@ struct deadline_data {
 	/*
 	 * requests (deadline_rq s) are present on both sort_list and fifo_list
 	 */
-	struct rb_root sort_list[2];	
+	struct rb_root sort_list[2];
 	struct list_head fifo_list[2];
 
 	/*
@@ -232,7 +232,7 @@ static inline int deadline_check_fifo(struct deadline_data *dd, int ddir)
 	/*
 	 * rq is expired!
 	 */
-	if (time_after(jiffies, rq_fifo_time(rq)))
+	if (time_after_eq(jiffies, rq_fifo_time(rq)))
 		return 1;
 
 	return 0;
@@ -354,7 +354,7 @@ static void *deadline_init_queue(struct request_queue *q)
 	dd->fifo_expire[READ] = read_expire;
 	dd->fifo_expire[WRITE] = write_expire;
 	dd->writes_starved = writes_starved;
-	dd->front_merges = 1;
+	dd->front_merges = 0;
 	dd->fifo_batch = fifo_batch;
 	return dd;
 }
diff --git a/block/elevator.c b/block/elevator.c
index b0b38ce..17f2085 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -32,12 +32,9 @@
 #include <linux/init.h>
 #include <linux/compiler.h>
 #include <linux/delay.h>
-#include <linux/blktrace_api.h>
 #include <linux/hash.h>
 #include <linux/uaccess.h>
 
-#include <trace/events/block.h>
-
 #include "blk.h"
 
 static DEFINE_SPINLOCK(elv_list_lock);
@@ -650,8 +647,6 @@ void elv_quiesce_end(struct request_queue *q)
 
 void __elv_add_request(struct request_queue *q, struct request *rq, int where)
 {
-	trace_block_rq_insert(q, rq);
-
 	rq->q = q;
 
 	if (rq->cmd_flags & REQ_SOFTBARRIER) {
@@ -795,7 +790,6 @@ void elv_abort_queue(struct request_queue *q)
 	while (!list_empty(&q->queue_head)) {
 		rq = list_entry_rq(q->queue_head.next);
 		rq->cmd_flags |= REQ_QUIET;
-		trace_block_rq_abort(q, rq);
 		/*
 		 * Mark this request as started so we don't trigger
 		 * any debug logic in the end I/O path.
@@ -1006,8 +1000,6 @@ static int elevator_switch(struct request_queue *q, struct elevator_type *new_e)
 	elv_quiesce_end(q);
 	spin_unlock_irq(q->queue_lock);
 
-	blk_add_trace_msg(q, "elv switch: %s", e->elevator_type->elevator_name);
-
 	return 0;
 
 fail_register:
diff --git a/block/genhd.c b/block/genhd.c
index 2a485ca..50c95f0 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -614,16 +614,35 @@ void add_disk(struct gendisk *disk)
 	register_disk(disk);
 	blk_register_queue(disk);
 
-        /*
-         * Take an extra ref on queue which will be put on disk_release()
-         * so that it sticks around as long as @disk is there.
-         */
-        WARN_ON_ONCE(blk_get_queue(disk->queue));
-
-	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,
-				   "bdi");
+    /*
+     * Take an extra ref on queue which will be put on disk_release()
+     * so that it sticks around as long as @disk is there.
+     */
+	WARN_ON_ONCE(blk_get_queue(disk->queue));
+
+	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj, "bdi");
 	WARN_ON(retval);
 
+	/*
+ 	 * Limit default readahead size for small devices.
+	 *        disk size    readahead size
+	 *               1M                8k
+	 *               4M               16k
+	 *              16M               32k
+	 *              64M               64k
+	 *             256M              128k
+	 *               1G              256k
+	 *               4G              512k
+	 *              16G             1024k
+	 *              64G             2048k
+	 *             256G             4096k
+	 */
+	if (get_capacity(disk)) {
+		unsigned long size = get_capacity(disk) >> 9;
+		size = 1UL << (ilog2(size) / 2);
+		bdi->ra_pages = min(bdi->ra_pages, size);
+	}
+
 	disk_add_events(disk);
 }
 EXPORT_SYMBOL(add_disk);
@@ -890,7 +909,6 @@ static const struct file_operations proc_partitions_operations = {
 };
 #endif
 
-
 static struct kobject *base_probe(dev_t devt, int *partno, void *data)
 {
 	if (request_module("block-major-%d-%d", MAJOR(devt), MINOR(devt)) > 0)
@@ -1185,7 +1203,7 @@ static int diskstats_show(struct seq_file *seqf, void *v)
 				"wsect wuse running use aveq"
 				"\n\n");
 	*/
- 
+
 	disk_part_iter_init(&piter, gp, DISK_PITER_INCL_EMPTY_PART0);
 	while ((hd = disk_part_iter_next(&piter))) {
 		cpu = part_stat_lock();
@@ -1209,7 +1227,7 @@ static int diskstats_show(struct seq_file *seqf, void *v)
 			);
 	}
 	disk_part_iter_exit(&piter);
- 
+
 	return 0;
 }
 
diff --git a/crypto/cryptd.c b/crypto/cryptd.c
index 7bdd61b..53804b1 100644
--- a/crypto/cryptd.c
+++ b/crypto/cryptd.c
@@ -139,9 +139,8 @@ static void cryptd_queue_worker(struct work_struct *work)
 	cpu_queue = container_of(work, struct cryptd_cpu_queue, work);
 	/*
 	 * Only handle one request at a time to avoid hogging crypto workqueue.
-	 * preempt_disable/enable is used to prevent being preempted by
-	 * cryptd_enqueue_request(). local_bh_disable/enable is used to prevent
-	 * cryptd_enqueue_request() being accessed from software interrupts.
+	 * preempt_disable/enable  prevent being preempted by cryptd_enqueue_request().
+	 * local_bh_disable/enable prevent cryptd_enqueue_request() being accessed from software interrupts.
 	 */
 	local_bh_disable();
 	preempt_disable();
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 9e5f622..5b6a538 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -8,10 +8,6 @@ source "drivers/mtd/Kconfig"
 
 source "drivers/of/Kconfig"
 
-source "drivers/parport/Kconfig"
-
-source "drivers/pnp/Kconfig"
-
 source "drivers/block/Kconfig"
 
 # misc before ide - BLK_DEV_SGIIOC4 depends on SGI_IOC4
@@ -30,16 +26,10 @@ source "drivers/target/Kconfig"
 
 source "drivers/message/fusion/Kconfig"
 
-source "drivers/firewire/Kconfig"
-
 source "drivers/message/i2o/Kconfig"
 
-source "drivers/macintosh/Kconfig"
-
 source "drivers/net/Kconfig"
 
-source "drivers/isdn/Kconfig"
-
 source "drivers/telephony/Kconfig"
 
 # input before char - char/joystick depends on it. As does USB.
@@ -102,8 +92,6 @@ source "drivers/accessibility/Kconfig"
 
 source "drivers/infiniband/Kconfig"
 
-source "drivers/edac/Kconfig"
-
 source "drivers/rtc/Kconfig"
 
 source "drivers/dma/Kconfig"
@@ -116,8 +104,6 @@ source "drivers/uio/Kconfig"
 
 source "drivers/vlynq/Kconfig"
 
-source "drivers/xen/Kconfig"
-
 source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index a8de753..80c5b2f 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -7,15 +7,12 @@
 
 obj-y				+= gpio/
 obj-$(CONFIG_PCI)		+= pci/
-obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
 obj-y				+= video/
 obj-y				+= idle/
 obj-$(CONFIG_ACPI)		+= acpi/
 obj-$(CONFIG_SFI)		+= sfi/
-# PnP must come after ACPI since it will eventually need to check if acpi
-# was used and do nothing if so
-obj-$(CONFIG_PNP)		+= pnp/
+
 obj-$(CONFIG_ARM_AMBA)		+= amba/
 # Many drivers will want to use DMA so this has to be made available
 # really early.
@@ -23,7 +20,6 @@ obj-$(CONFIG_DMA_ENGINE)	+= dma/
 
 obj-$(CONFIG_VIRTIO)		+= virtio/
 obj-$(CONFIG_RPMSG)		+= rpmsg/
-obj-$(CONFIG_XEN)		+= xen/
 
 # regulators early, since some subsystems rely on them to initialize
 obj-$(CONFIG_REGULATOR)		+= regulator/
@@ -42,10 +38,8 @@ obj-$(CONFIG_CONNECTOR)		+= connector/
 obj-$(CONFIG_FB_I810)           += video/i810/
 obj-$(CONFIG_FB_INTEL)          += video/intelfb/
 
-obj-$(CONFIG_PARPORT)		+= parport/
 obj-y				+= base/ block/ misc/ mfd/ nfc/
 obj-$(CONFIG_NUBUS)		+= nubus/
-obj-y				+= macintosh/
 obj-$(CONFIG_IDE)		+= ide/
 obj-$(CONFIG_SCSI)		+= scsi/
 obj-$(CONFIG_ATA)		+= ata/
@@ -55,7 +49,6 @@ obj-$(CONFIG_SPI)		+= spi/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
-obj-y				+= firewire/
 obj-$(CONFIG_UIO)		+= uio/
 obj-y				+= cdrom/
 obj-y				+= auxdisplay/
@@ -63,7 +56,6 @@ obj-$(CONFIG_PCCARD)		+= pcmcia/
 obj-$(CONFIG_DIO)		+= dio/
 obj-$(CONFIG_SBUS)		+= sbus/
 obj-$(CONFIG_ZORRO)		+= zorro/
-obj-$(CONFIG_MAC)		+= macintosh/
 obj-$(CONFIG_ATA_OVER_ETH)	+= block/aoe/
 obj-$(CONFIG_PARIDE) 		+= block/paride/
 obj-$(CONFIG_TC)		+= tc/
@@ -89,10 +81,6 @@ obj-$(CONFIG_PHONE)		+= telephony/
 obj-$(CONFIG_MD)		+= md/
 obj-$(CONFIG_BT)		+= bluetooth/
 obj-$(CONFIG_ACCESSIBILITY)	+= accessibility/
-obj-$(CONFIG_ISDN)		+= isdn/
-obj-$(CONFIG_EDAC)		+= edac/
-obj-$(CONFIG_MCA)		+= mca/
-obj-$(CONFIG_EISA)		+= eisa/
 obj-y				+= lguest/
 obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_CPU_IDLE)		+= cpuidle/
diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
index 908f40a..5efe401 100644
--- a/drivers/acpi/battery.c
+++ b/drivers/acpi/battery.c
@@ -98,17 +98,6 @@ enum {
 	 */
 	ACPI_BATTERY_QUIRK_SIGNED16_CURRENT,
 	ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY,
-	/* On Lenovo Thinkpad models from 2010 and 2011, the power unit
-	   switches between mWh and mAh depending on whether the system
-	   is running on battery or not.  When mAh is the unit, most
-	   reported values are incorrect and need to be adjusted by
-	   10000/design_voltage.  Verified on x201, t410, t410s, and x220.
-	   Pre-2010 and 2012 models appear to always report in mWh and
-	   are thus unaffected (tested with t42, t61, t500, x200, x300,
-	   and x230).  Also, in mid-2012 Lenovo issued a BIOS update for
-	   the 2011 models that fixes the issue (tested on x220 with a
-	   post-1.29 BIOS), but as of Nov. 2012, no such update is
-	   available for the 2010 models.  */
 	ACPI_BATTERY_QUIRK_THINKPAD_MAH,
 };
 
diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c
index af66776..cfc4901 100644
--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@ -85,12 +85,11 @@ module_param(ec_delay, uint, 0644);
 MODULE_PARM_DESC(ec_delay, "Timeout(ms) waited until an EC command completes");
 
 /*
- * If the number of false interrupts per one transaction exceeds
- * this threshold, will think there is a GPE storm happened and
- * will disable the GPE for normal transaction.
+ * If the number of false interrupts per one transaction exceeds this threshold,
+ * will think there is a GPE storm happened and will disable the GPE for normal transaction.
  */
 static unsigned int ec_storm_threshold  __read_mostly = 8;
-module_param(ec_storm_threshold, uint, 0644);
+module_param(ec_storm_threshold, uint, 0664);
 MODULE_PARM_DESC(ec_storm_threshold, "Maxim false GPE numbers not considered as GPE storm");
 
 /* If we find an EC via the ECDT, we need to keep a ptr to its context */
@@ -217,7 +216,7 @@ static int ec_check_sci_sync(struct acpi_ec *ec, u8 state)
 static int ec_poll(struct acpi_ec *ec)
 {
 	unsigned long flags;
-	int repeat = 5; /* number of command restarts */
+	int repeat = 4; /* number of command restarts */
 	while (repeat--) {
 		unsigned long delay = jiffies +
 			msecs_to_jiffies(ec_delay);
@@ -919,8 +918,8 @@ static int ec_flag_msi(const struct dmi_system_id *id)
 }
 
 /*
- * Clevo M720 notebook actually works ok with IRQ mode, if we lifted
- * the GPE storm threshold back to 20
+ * Clevo M720 notebook actually works ok with IRQ mode,
+ * if we lifted the GPE storm threshold back to 20
  */
 static int ec_enlarge_storm_threshold(const struct dmi_system_id *id)
 {
diff --git a/drivers/acpi/video.c b/drivers/acpi/video.c
index 5e14a6b..2fe0c6e 100644
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@ -395,6 +395,12 @@ static int video_ignore_initial_backlight(const struct dmi_system_id *d)
 	return 0;
 }
 
+static int video_ignore_initial_backlight(const struct dmi_system_id *d)
+{
+	use_bios_initial_backlight = 0;
+	return 0;
+}
+
 static struct dmi_system_id video_dmi_table[] __initdata = {
 	/*
 	 * Broken _BQC workaround http://bugzilla.kernel.org/show_bug.cgi?id=13121
@@ -463,6 +469,30 @@ static struct dmi_system_id video_dmi_table[] __initdata = {
 		DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion m4 Notebook PC"),
 		},
 	},
+	{
+	 .callback = video_ignore_initial_backlight,
+	 .ident = "HP Folio 13-2000",
+	 .matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "HP Folio 13 - 2000 Notebook PC"),
+		},
+	},
+	{
+	 .callback = video_ignore_initial_backlight,
+	 .ident = "HP Pavilion g6 Notebook PC",
+	 .matches = {
+		 DMI_MATCH(DMI_BOARD_VENDOR, "Hewlett-Packard"),
+		 DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion g6 Notebook PC"),
+		},
+	},
+	{
+	 .callback = video_ignore_initial_backlight,
+	 .ident = "HP Pavilion m4",
+	 .matches = {
+		DMI_MATCH(DMI_BOARD_VENDOR, "Hewlett-Packard"),
+		DMI_MATCH(DMI_PRODUCT_NAME, "HP Pavilion m4 Notebook PC"),
+		},
+	},
 	{}
 };
 
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index 34575fb..75afa75 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -93,7 +93,7 @@ config SATA_FSL
 	  If unsure, say N.
 
 config SATA_INIC162X
-	tristate "Initio 162x SATA support (Very Experimental)"
+	tristate "Initio 162x SATA support"
 	depends on PCI
 	help
 	  This option enables support for Initio 162x Serial ATA.
diff --git a/drivers/ata/sata_inic162x.c b/drivers/ata/sata_inic162x.c
index 15391ee..68a22bd 100644
--- a/drivers/ata/sata_inic162x.c
+++ b/drivers/ata/sata_inic162x.c
@@ -7,17 +7,12 @@
  * This file is released under GPL v2.
  *
  * **** WARNING ****
- *
  * This driver never worked properly and unfortunately data corruption is
  * relatively common.  There isn't anyone working on the driver and there's
- * no support from the vendor.  Do not use this driver in any production
- * environment.
- *
+ * no support from the vendor.  Do not use this driver in production environment.
  * http://thread.gmane.org/gmane.linux.debian.devel.bugs.rc/378525/focus=54491
  * https://bugzilla.kernel.org/show_bug.cgi?id=60565
- *
  * *****************
- *
  * This controller is eccentric and easily locks up if something isn't
  * right.  Documentation is available at initio's website but it only
  * documents registers (not programming model).
@@ -822,7 +817,7 @@ static int inic_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (!printed_version++)
 		dev_printk(KERN_DEBUG, &pdev->dev, "version " DRV_VERSION "\n");
 
-	dev_alert(&pdev->dev, "inic162x support is broken with common data corruption issues and will be disabled by default, contact linux-ide@vger.kernel.org if in production use\n");
+	dev_alert(&pdev->dev, "inic162x is broken with common data corruption issues and will be disabled by default, not use in production environment\n");
 
 	/* alloc host */
 	host = ata_host_alloc_pinfo(&pdev->dev, ppi, NR_PORTS);
diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
index e490ce6..c3bb7c5 100644
--- a/drivers/base/dma-contiguous.c
+++ b/drivers/base/dma-contiguous.c
@@ -1,7 +1,6 @@
 /*
  * Contiguous Memory Allocator for DMA mapping framework
  * Copyright (c) 2010-2011 by Samsung Electronics.
- * Written by:
  *	Marek Szyprowski <m.szyprowski@samsung.com>
  *	Michal Nazarewicz <mina86@mina86.com>
  *
@@ -65,7 +64,6 @@ static long size_cmdline = -1;
 
 static int __init early_cma(char *p)
 {
-	pr_debug("%s(%s)\n", __func__, p);
 	size_cmdline = memparse(p, &p);
 	return 0;
 }
@@ -111,8 +109,6 @@ void __init dma_contiguous_reserve(phys_addr_t limit)
 {
 	unsigned long selected_size = 0;
 
-	pr_debug("%s(limit %08lx)\n", __func__, (unsigned long)limit);
-
 	if (size_cmdline != -1) {
 		selected_size = size_cmdline;
 	} else {
@@ -128,9 +124,6 @@ void __init dma_contiguous_reserve(phys_addr_t limit)
 	}
 
 	if (selected_size) {
-		pr_debug("%s: reserving %ld MiB for global area\n", __func__,
-			 selected_size / SZ_1M);
-
 		dma_declare_contiguous(NULL, selected_size, 0, limit);
 	}
 };
@@ -166,8 +159,6 @@ static __init struct cma *cma_create_area(unsigned long base_pfn,
 	struct cma *cma;
 	int ret = -ENOMEM;
 
-	pr_debug("%s(base %08lx, count %lx)\n", __func__, base_pfn, count);
-
 	cma = kmalloc(sizeof *cma, GFP_KERNEL);
 	if (!cma)
 		return ERR_PTR(-ENOMEM);
@@ -183,7 +174,6 @@ static __init struct cma *cma_create_area(unsigned long base_pfn,
 	if (ret)
 		goto error;
 
-	pr_debug("%s: returned %p\n", __func__, (void *)cma);
 	return cma;
 
 error:
@@ -205,8 +195,6 @@ static int __init cma_init_reserved_areas(void)
 	struct cma_reserved *r = cma_reserved;
 	unsigned i = cma_reserved_count;
 
-	pr_debug("%s()\n", __func__);
-
 	for (; i; --i, ++r) {
 		struct cma *cma;
 		cma = cma_create_area(PFN_DOWN(r->start),
@@ -239,10 +227,6 @@ int __init dma_declare_contiguous(struct device *dev, unsigned long size,
 	struct cma_reserved *r = &cma_reserved[cma_reserved_count];
 	unsigned long alignment;
 
-	pr_debug("%s(size %lx, base %08lx, limit %08lx)\n", __func__,
-		 (unsigned long)size, (unsigned long)base,
-		 (unsigned long)limit);
-
 	/* Sanity checks */
 	if (cma_reserved_count == ARRAY_SIZE(cma_reserved)) {
 		pr_err("Not enough slots for CMA reserved regions!\n");
@@ -291,8 +275,6 @@ int __init dma_declare_contiguous(struct device *dev, unsigned long size,
 	r->size = size;
 	r->dev = dev;
 	cma_reserved_count++;
-	pr_info("CMA: reserved %ld MiB at %08lx\n", size / SZ_1M,
-		(unsigned long)base);
 
 	/* Architecture specific contiguous memory fixup. */
 	dma_contiguous_early_fixup(base, size);
@@ -321,9 +303,6 @@ static struct page *__dma_alloc_from_contiguous(struct device *dev, int count,
 	if (align > CONFIG_CMA_ALIGNMENT)
 		align = CONFIG_CMA_ALIGNMENT;
 
-	pr_debug("%s(cma %p, count %d, align %d)\n", __func__, (void *)cma,
-		 count, align);
-
 	if (!count)
 		return NULL;
 
@@ -350,8 +329,6 @@ static struct page *__dma_alloc_from_contiguous(struct device *dev, int count,
 		} else if (ret != -EBUSY && ret != -EAGAIN) {
 			goto error;
 		}
-		pr_debug("%s(): memory range at %p is busy, retrying\n",
-			 __func__, pfn_to_page(pfn));
 		/* try again with a bit different memory target */
 
 		/* FIXME: woojong.yoo@samsung.com
@@ -363,7 +340,6 @@ static struct page *__dma_alloc_from_contiguous(struct device *dev, int count,
 
 	mutex_unlock(&cma_mutex);
 
-	pr_debug("%s(): returned %p\n", __func__, pfn_to_page(pfn));
 	return pfn_to_page(pfn);
 error:
 	pr_err("%s(): returned error (%d)\n", __func__, ret);
@@ -392,9 +368,6 @@ static void do_dma_prepare_alloc(struct work_struct *work)
 
 	ctx->result = __dma_alloc_from_contiguous(ctx->dev, ctx->count,
 			ctx->align);
-	printk(KERN_INFO "%s[%d]: alloc %d pages for dev %s %s\n",
-		__func__, __LINE__, ctx->count, dev_name(ctx->dev),
-		ctx->result ? "succeeded" : "failed");
 }
 
 /**
@@ -494,12 +467,9 @@ bool dma_release_from_contiguous(struct device *dev, struct page *pages,
 	if (!cma || !pages)
 		return false;
 
-	pr_debug("%s(page %p)\n", __func__, (void *)pages);
-
 	pfn = page_to_pfn(pages);
 
 	if (pfn < cma->base_pfn || pfn >= cma->base_pfn + cma->count) {
-		pr_info("%s : return false\n", __func__);
 		return false;
 	}
 
diff --git a/drivers/battery/max77693_charger.c b/drivers/battery/max77693_charger.c
index 8f27f86..e61b6f2 100644
--- a/drivers/battery/max77693_charger.c
+++ b/drivers/battery/max77693_charger.c
@@ -17,8 +17,8 @@
 #define ENABLE 1
 #define DISABLE 0
 
-#define MAX77693_TERMINATION_CURRENT_MASK	0x7
-#define MAX77693_TOPOFF_TIME_MASK		0x38
+#define MAX77693_TERMINATION_CURRENT_MASK 0x7
+#define MAX77693_TOPOFF_TIME_MASK		   0x38
 
 static DEFINE_MUTEX(isr_lock);
 static DEFINE_MUTEX(init_lock);
@@ -120,7 +120,6 @@ static void max77693_set_termination_current(struct sec_charger_info *charger,
 
 	max77693_register_lock(charger, 0);
 
-	pr_info("%s: CHG_CNFG_03(0x%02x)\n", __func__, reg_data);
 	max77693_write_reg(charger->client,
 		MAX77693_CHG_REG_CHG_CNFG_03, reg_data);
 
@@ -155,8 +154,7 @@ static int max77693_get_input_current(struct sec_charger_info *charger)
 	int get_current = 0;
 
 	max77693_read_reg(charger->client,
-			MAX77693_CHG_REG_CHG_CNFG_09, &reg_data);
-	pr_debug("%s: CHG_CNFG_09(0x%02x)\n", __func__, reg_data);
+		MAX77693_CHG_REG_CHG_CNFG_09, &reg_data);
 
 	get_current = reg_data * 20;
 
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 7d10ae3..4f447c3 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -311,7 +311,7 @@ if RTC_LIB=n
 config RTC
 	tristate "Enhanced Real Time Clock Support (legacy PC RTC driver)"
 	depends on !PPC && !PARISC && !IA64 && !M68K && !SPARC && !FRV \
-			&& !ARM && !SUPERH && !S390 && !AVR32 && !BLACKFIN
+			&& !ARM && !SUPERH && !AVR32 && !BLACKFIN
 	---help---
 	  If you say Y here and create a character special file /dev/rtc with
 	  major number 10 and minor number 135 using mknod ("man mknod"), you
@@ -359,7 +359,7 @@ config JS_RTC
 
 config GEN_RTC
 	tristate "Generic /dev/rtc emulation"
-	depends on RTC!=y && !IA64 && !ARM && !M32R && !MIPS && !SPARC && !FRV && !S390 && !SUPERH && !AVR32 && !BLACKFIN
+	depends on RTC!=y && !IA64 && !ARM && !M32R && !MIPS && !SPARC && !FRV && !SUPERH && !AVR32 && !BLACKFIN
 	---help---
 	  If you say Y here and create a character special file /dev/rtc with
 	  major number 10 and minor number 135 using mknod ("man mknod"), you
@@ -568,7 +568,7 @@ config HPET_MMAP
 
 config HANGCHECK_TIMER
 	tristate "Hangcheck timer"
-	depends on X86 || IA64 || PPC64 || S390
+	depends on X86 || IA64 || PPC64
 	help
 	  The hangcheck-timer module detects when the system has gone
 	  out to lunch past a certain margin.  It can reboot the system
@@ -615,8 +615,6 @@ config DCC_TTY
 	tristate "DCC tty driver"
 	depends on ARM
 
-source "drivers/s390/char/Kconfig"
-
 config RAMOOPS
 	tristate "Log panic/oops to a RAM buffer"
 	depends on HAS_IOMEM
@@ -634,4 +632,3 @@ config MSM_SMD_PKT
 	  ports via device interface for MSM chipset.
 
 endmenu
-
diff --git a/drivers/char/random.c b/drivers/char/random.c
index e7e479c..15b9e39 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -416,8 +416,8 @@ module_param(debug, bool, 0644);
 
 /**********************************************************************
  *
- * OS independent entropy store.   Here are the functions which handle
- * storing entropy in an entropy pool.
+ * OS independent entropy store. Here are the functions
+ * which handle storing entropy in an entropy pool.
  *
  **********************************************************************/
 
@@ -593,14 +593,11 @@ static void credit_entropy_bits(struct entropy_store *r, int nbits)
 
 	if (!nbits)
 		return;
-
-	DEBUG_ENT("added %d entropy credits to %s\n", nbits, r->name);
 retry:
 	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
 	entropy_count += nbits;
 
 	if (entropy_count < 0) {
-		DEBUG_ENT("negative entropy/overflow\n");
 		entropy_count = 0;
 	} else if (entropy_count > r->poolinfo->POOLBITS)
 		entropy_count = r->poolinfo->POOLBITS;
@@ -729,16 +726,19 @@ out:
 void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value)
 {
+/* Prevent add_input from doing anything */
+#if 0
 	static unsigned char last_value;
 
 	/* ignore autorepeat and the like */
 	if (value == last_value)
 		return;
 
-	DEBUG_ENT("input event\n");
 	last_value = value;
 	add_timer_randomness(&input_timer_state,
 			     (type << 4) ^ code ^ (code >> 4) ^ value);
+#endif
+	return;
 }
 EXPORT_SYMBOL_GPL(add_input_randomness);
 
@@ -791,9 +791,6 @@ void add_disk_randomness(struct gendisk *disk)
 {
 	if (!disk || !disk->random)
 		return;
-	/* first major is 1, so we get >= 0x200 here */
-	DEBUG_ENT("disk event %d:%d\n",
-		  MAJOR(disk_devt(disk)), MINOR(disk_devt(disk)));
 
 	add_timer_randomness(disk->random, 0x100 + disk_devt(disk));
 }
@@ -828,10 +825,6 @@ static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
 		/* but never more than the buffer size */
 		bytes = min_t(int, bytes, sizeof(tmp));
 
-		DEBUG_ENT("going to reseed %s with %d bits "
-			  "(%d of %d requested)\n",
-			  r->name, bytes * 8, nbytes * 8, r->entropy_count);
-
 		bytes = extract_entropy(r->pull, tmp, bytes,
 					random_read_wakeup_thresh / 8, rsvd);
 		mix_pool_bytes(r, tmp, bytes, NULL);
@@ -860,8 +853,6 @@ static size_t account(struct entropy_store *r, size_t nbytes, int min,
 	spin_lock_irqsave(&r->lock, flags);
 
 	BUG_ON(r->entropy_count > r->poolinfo->POOLBITS);
-	DEBUG_ENT("trying to extract %d bits from %s\n",
-		  nbytes * 8, r->name);
 
 	/* Can we pull enough? */
 	if (r->entropy_count / 8 < min + reserved) {
@@ -882,9 +873,6 @@ static size_t account(struct entropy_store *r, size_t nbytes, int min,
 		}
 	}
 
-	DEBUG_ENT("debiting %d entropy credits from %s%s\n",
-		  nbytes * 8, r->name, r->limit ? "" : " (unlimited)");
-
 	spin_unlock_irqrestore(&r->lock, flags);
 
 	return nbytes;
@@ -1068,7 +1056,6 @@ void get_random_bytes_arch(void *buf, int nbytes)
 }
 EXPORT_SYMBOL(get_random_bytes_arch);
 
-
 /*
  * init_std_data - initialize pool with system data
  *
@@ -1132,6 +1119,10 @@ void rand_initialize_disk(struct gendisk *disk)
 static ssize_t
 random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
+/*
+ * Entropy tweaks are all the rage nowadays. Use nonblocking for all.
+ */
+#if 0
 	ssize_t n, retval = 0, count = 0;
 
 	if (nbytes == 0)
@@ -1142,27 +1133,18 @@ random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 		if (n > SEC_XFER_SIZE)
 			n = SEC_XFER_SIZE;
 
-		DEBUG_ENT("reading %d bits\n", n*8);
-
 		n = extract_entropy_user(&blocking_pool, buf, n);
 
-		DEBUG_ENT("read got %d bits (%d still needed)\n",
-			  n*8, (nbytes-n)*8);
-
 		if (n == 0) {
 			if (file->f_flags & O_NONBLOCK) {
 				retval = -EAGAIN;
 				break;
 			}
 
-			DEBUG_ENT("sleeping?\n");
-
 			wait_event_interruptible(random_read_wait,
 				input_pool.entropy_count >=
 						 random_read_wakeup_thresh);
 
-			DEBUG_ENT("awake\n");
-
 			if (signal_pending(current)) {
 				retval = -ERESTARTSYS;
 				break;
@@ -1183,6 +1165,8 @@ random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 	}
 
 	return (count ? count : retval);
+#endif
+	return extract_entropy_user(&nonblocking_pool, buf, nbytes);
 }
 
 static ssize_t
diff --git a/drivers/cpufreq/Kconfig b/drivers/cpufreq/Kconfig
index 8c6ff52..fa91ccf 100644
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -54,51 +54,47 @@ config CPU_FREQ_DEFAULT_GOV_PERFORMANCE
 	bool "performance"
 	select CPU_FREQ_GOV_PERFORMANCE
 	help
-	  Use the CPUFreq governor 'performance' as default. This sets
-	  the frequency statically to the highest frequency supported by
-	  the CPU.
+	  Use the CPUFreq governor 'performance' as default. This sets the
+	  frequency statically to the highest frequency supported by the CPU.
 
 config CPU_FREQ_DEFAULT_GOV_POWERSAVE
 	bool "powersave"
 	depends on EXPERT
 	select CPU_FREQ_GOV_POWERSAVE
 	help
-	  Use the CPUFreq governor 'powersave' as default. This sets
-	  the frequency statically to the lowest frequency supported by
-	  the CPU.
+	  Use the CPUFreq governor 'powersave' as default. This sets the
+	  frequency statically to the lowest frequency supported by the CPU.
 
 config CPU_FREQ_DEFAULT_GOV_USERSPACE
 	bool "userspace"
 	select CPU_FREQ_GOV_USERSPACE
 	help
 	  Use the CPUFreq governor 'userspace' as default. This allows
-	  you to set the CPU frequency manually or when a userspace 
+	  you to set the CPU frequency manually or when a userspace
 	  program shall be able to set the CPU dynamically without having
 	  to enable the userspace governor manually.
 
 config CPU_FREQ_DEFAULT_GOV_ONDEMAND
 	bool "ondemand"
 	select CPU_FREQ_GOV_ONDEMAND
-	select CPU_FREQ_GOV_PERFORMANCE
 	help
 	  Use the CPUFreq governor 'ondemand' as default. This allows
 	  you to get a full dynamic frequency capable system by simply
 	  loading your cpufreq low-level hardware driver.
 	  Be aware that not all cpufreq drivers support the ondemand
-	  governor. If unsure have a look at the help section of the
-	  driver. Fallback governor will be the performance governor.
+	  governor. If unsure have a look at the help section of the driver.
+	  Fallback governor will be the 'interactive' governor.
 
 config CPU_FREQ_DEFAULT_GOV_CONSERVATIVE
 	bool "conservative"
 	select CPU_FREQ_GOV_CONSERVATIVE
-	select CPU_FREQ_GOV_PERFORMANCE
 	help
 	  Use the CPUFreq governor 'conservative' as default. This allows
 	  you to get a full dynamic frequency capable system by simply
 	  loading your cpufreq low-level hardware driver.
 	  Be aware that not all cpufreq drivers support the conservative
-	  governor. If unsure have a look at the help section of the
-	  driver. Fallback governor will be the performance governor.
+	  governor. If unsure have a look at the help section of the driver.
+	  Fallback governor will be the 'interactive' governor.
 
 config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
 	bool "interactive"
@@ -109,19 +105,16 @@ config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
 	  loading your cpufreq low-level hardware driver, using the
 	  'interactive' governor for latency-sensitive workloads.
 
-
 config CPU_FREQ_DEFAULT_GOV_HOTPLUG
 	bool "hotplug"
 	select CPU_FREQ_GOV_HOTPLUG
-	select CPU_FREQ_GOV_PERFORMANCE
 	help
-	  Use the CPUFreq governor 'hotplug' as default. This allows you
-	  to get a full dynamic frequency capable system with CPU
-	  hotplug support by simply loading your cpufreq low-level
-	  hardware driver.  Be aware that not all cpufreq drivers
-	  support the hotplug governor. If unsure have a look at
-	  the help section of the driver. Fallback governor will be the
-	  performance governor.
+	  Use the CPUFreq governor 'hotplug' as default.
+	  This allows you to get a full dynamic frequency capable
+	  system with by simply loading your cpufreq hardware driver.
+	  Not all cpufreq drivers support the hotplug governor.
+	  Fallback governor will be the 'interactive' governor.
+
 endchoice
 
 config CPU_FREQ_GOV_PERFORMANCE
@@ -133,7 +126,7 @@ config CPU_FREQ_GOV_PERFORMANCE
 	  To compile this driver as a module, choose M here: the
 	  module will be called cpufreq_performance.
 
-	  If in doubt, say Y.
+	  If in doubt, say N.
 
 config CPU_FREQ_GOV_POWERSAVE
 	tristate "'powersave' governor"
@@ -144,14 +137,14 @@ config CPU_FREQ_GOV_POWERSAVE
 	  To compile this driver as a module, choose M here: the
 	  module will be called cpufreq_powersave.
 
-	  If in doubt, say Y.
+	  If in doubt, say N.
 
 config CPU_FREQ_GOV_USERSPACE
 	tristate "'userspace' governor for userspace frequency scaling"
 	help
 	  Enable this cpufreq governor when you either want to set the
 	  CPU frequency manually or when a userspace program shall
-	  be able to set the CPU dynamically, like on LART 
+	  be able to set the CPU dynamically, like on LART
 	  <http://www.lartmaker.nl/>.
 
 	  To compile this driver as a module, choose M here: the
@@ -159,18 +152,18 @@ config CPU_FREQ_GOV_USERSPACE
 
 	  For details, take a look at <file:Documentation/cpu-freq/>.
 
-	  If in doubt, say Y.
+	  If in doubt, say N.
 
 config CPU_FREQ_GOV_ONDEMAND
 	tristate "'ondemand' cpufreq policy governor"
 	select CPU_FREQ_TABLE
 	help
 	  'ondemand' - This driver adds a dynamic cpufreq policy governor.
-	  The governor does a periodic polling and 
+	  The governor does a periodic polling and
 	  changes frequency based on the CPU utilization.
 	  The support for this governor depends on CPU capability to
 	  do fast frequency switching (i.e, very low latency frequency
-	  transitions). 
+	  transitions).
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called cpufreq_ondemand.
@@ -179,23 +172,6 @@ config CPU_FREQ_GOV_ONDEMAND
 
 	  If in doubt, say N.
 
-config CPU_FREQ_GOV_INTERACTIVE
-	tristate "'interactive' cpufreq policy governor"
-	help
-	  'interactive' - This driver adds a dynamic cpufreq policy governor
-	  designed for latency-sensitive workloads.
-
-	  This governor attempts to reduce the latency of clock
-	  increases so that the system is more responsive to
-	  interactive workloads.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called cpufreq_interactive.
-
-	  For details, take a look at linux/Documentation/cpu-freq.
-
-	  If in doubt, say N.
-
 config CPU_FREQ_GOV_CONSERVATIVE
 	tristate "'conservative' cpufreq governor"
 	depends on CPU_FREQ
@@ -219,10 +195,23 @@ config CPU_FREQ_GOV_CONSERVATIVE
 
 	  If in doubt, say N.
 
-menu "x86 CPU frequency scaling drivers"
-depends on X86
-source "drivers/cpufreq/Kconfig.x86"
-endmenu
+config CPU_FREQ_GOV_INTERACTIVE
+	tristate "'interactive' cpufreq policy governor"
+        depends on CPU_FREQ
+	help
+	  'interactive' - This driver adds a dynamic cpufreq policy governor
+	  designed for latency-sensitive workloads.
+
+	  This governor attempts to reduce the latency of clock
+	  increases so that the system is more responsive to
+	  interactive workloads.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cpufreq_interactive.
+
+	  For details, take a look at linux/Documentation/cpu-freq.
+
+	  If in doubt, say Y.
 
 config CPU_FREQ_GOV_HOTPLUG
 	tristate "'hotplug' cpufreq governor"
@@ -240,7 +229,7 @@ config CPU_FREQ_GOV_HOTPLUG
 	  devices.
 
 	  If you don't have one of these architectures or devices, use
-	  'ondemand' instead.
+	  'interactive' instead.
 
 	  If in doubt, say N.
 
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 1a5e64d..788a084 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -1,9 +1,9 @@
 # CPUfreq core
-obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o
+obj-$(CONFIG_CPU_FREQ)			+= cpufreq.o cpu-boost.o
 # CPUfreq stats
 obj-$(CONFIG_CPU_FREQ_STAT)             += cpufreq_stats.o
 
-# CPUfreq governors 
+# CPUfreq governors
 obj-$(CONFIG_CPU_FREQ_GOV_PERFORMANCE)	+= cpufreq_performance.o
 obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
@@ -15,31 +15,5 @@ obj-$(CONFIG_CPU_FREQ_GOV_HOTPLUG)	+= cpufreq_hotplug.o
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
 
-##################################################################################d
-# x86 drivers.
-# Link order matters. K8 is preferred to ACPI because of firmware bugs in early
-# K8 systems. ACPI is preferred to all other hardware-specific drivers.
-# speedstep-* is preferred over p4-clockmod.
-
-obj-$(CONFIG_X86_POWERNOW_K8)		+= powernow-k8.o mperf.o
-obj-$(CONFIG_X86_ACPI_CPUFREQ)		+= acpi-cpufreq.o mperf.o
-obj-$(CONFIG_X86_PCC_CPUFREQ)		+= pcc-cpufreq.o
-obj-$(CONFIG_X86_POWERNOW_K6)		+= powernow-k6.o
-obj-$(CONFIG_X86_POWERNOW_K7)		+= powernow-k7.o
-obj-$(CONFIG_X86_LONGHAUL)		+= longhaul.o
-obj-$(CONFIG_X86_E_POWERSAVER)		+= e_powersaver.o
-obj-$(CONFIG_ELAN_CPUFREQ)		+= elanfreq.o
-obj-$(CONFIG_SC520_CPUFREQ)		+= sc520_freq.o
-obj-$(CONFIG_X86_LONGRUN)		+= longrun.o
-obj-$(CONFIG_X86_GX_SUSPMOD)		+= gx-suspmod.o
-obj-$(CONFIG_X86_SPEEDSTEP_ICH)		+= speedstep-ich.o
-obj-$(CONFIG_X86_SPEEDSTEP_LIB)		+= speedstep-lib.o
-obj-$(CONFIG_X86_SPEEDSTEP_SMI)		+= speedstep-smi.o
-obj-$(CONFIG_X86_SPEEDSTEP_CENTRINO)	+= speedstep-centrino.o
-obj-$(CONFIG_X86_P4_CLOCKMOD)		+= p4-clockmod.o
-obj-$(CONFIG_X86_CPUFREQ_NFORCE2)	+= cpufreq-nforce2.o
-
-##################################################################################d
-
 # ARM SoC drivers
 obj-$(CONFIG_UX500_SOC_DB8500)		+= db8500-cpufreq.o
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index b493663..8d65b9d 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -5,7 +5,7 @@
 # Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
 #
 menuconfig DRM
-	tristate "Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)"
+	tristate "Direct Rendering Manager
 	depends on (AGP || AGP=n) && !EMULATED_CMPXCHG && MMU
 	select I2C
 	select I2C_ALGOBIT
@@ -27,134 +27,3 @@ config DRM_KMS_HELPER
 	select FRAMEBUFFER_CONSOLE_DETECT_PRIMARY if FRAMEBUFFER_CONSOLE
 	help
 	  FB and CRTC helpers for KMS drivers.
-
-config DRM_TTM
-	tristate
-	depends on DRM
-	help
-	  GPU memory management subsystem for devices with multiple
-	  GPU memory types. Will be enabled automatically if a device driver
-	  uses it.
-
-config DRM_TDFX
-	tristate "3dfx Banshee/Voodoo3+"
-	depends on DRM && PCI
-	help
-	  Choose this option if you have a 3dfx Banshee or Voodoo3 (or later),
-	  graphics card.  If M is selected, the module will be called tdfx.
-
-config DRM_R128
-	tristate "ATI Rage 128"
-	depends on DRM && PCI
-	select FW_LOADER
-	help
-	  Choose this option if you have an ATI Rage 128 graphics card.  If M
-	  is selected, the module will be called r128.  AGP support for
-	  this card is strongly suggested (unless you have a PCI version).
-
-config DRM_RADEON
-	tristate "ATI Radeon"
-	depends on DRM && PCI
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	select FW_LOADER
-        select DRM_KMS_HELPER
-        select DRM_TTM
-	select POWER_SUPPLY
-	select HWMON
-	help
-	  Choose this option if you have an ATI Radeon graphics card.  There
-	  are both PCI and AGP versions.  You don't need to choose this to
-	  run the Radeon in plain VGA mode.
-
-	  If M is selected, the module will be called radeon.
-
-source "drivers/gpu/drm/radeon/Kconfig"
-
-config DRM_I810
-	tristate "Intel I810"
-	# !PREEMPT because of missing ioctl locking
-	depends on DRM && AGP && AGP_INTEL && (!PREEMPT || BROKEN)
-	help
-	  Choose this option if you have an Intel I810 graphics card.  If M is
-	  selected, the module will be called i810.  AGP support is required
-	  for this driver to work.
-
-config DRM_I915
-	tristate "Intel 8xx/9xx/G3x/G4x/HD Graphics"
-	depends on DRM
-	depends on AGP
-	depends on AGP_INTEL
-	# we need shmfs for the swappable backing store, and in particular
-	# the shmem_readpage() which depends upon tmpfs
-	select SHMEM
-	select TMPFS
-	select DRM_KMS_HELPER
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	# i915 depends on ACPI_VIDEO when ACPI is enabled
-	# but for select to work, need to select ACPI_VIDEO's dependencies, ick
-	select BACKLIGHT_CLASS_DEVICE if ACPI
-	select VIDEO_OUTPUT_CONTROL if ACPI
-	select INPUT if ACPI
-	select ACPI_VIDEO if ACPI
-	select ACPI_BUTTON if ACPI
-	help
-	  Choose this option if you have a system that has "Intel Graphics
-	  Media Accelerator" or "HD Graphics" integrated graphics,
-	  including 830M, 845G, 852GM, 855GM, 865G, 915G, 945G, 965G,
-	  G35, G41, G43, G45 chipsets and Celeron, Pentium, Core i3,
-	  Core i5, Core i7 as well as Atom CPUs with integrated graphics.
-	  If M is selected, the module will be called i915.  AGP support
-	  is required for this driver to work. This driver is used by
-	  the Intel driver in X.org 6.8 and XFree86 4.4 and above. It
-	  replaces the older i830 module that supported a subset of the
-	  hardware in older X.org releases.
-
-	  Note that the older i810/i815 chipsets require the use of the
-	  i810 driver instead, and the Atom z5xx series has an entirely
-	  different implementation.
-
-config DRM_I915_KMS
-	bool "Enable modesetting on intel by default"
-	depends on DRM_I915
-	help
-	  Choose this option if you want kernel modesetting enabled by default,
-	  and you have a new enough userspace to support this. Running old
-	  userspaces with this enabled will cause pain.  Note that this causes
-	  the driver to bind to PCI devices, which precludes loading things
-	  like intelfb.
-
-config DRM_MGA
-	tristate "Matrox g200/g400"
-	depends on DRM && PCI
-	select FW_LOADER
-	help
-	  Choose this option if you have a Matrox G200, G400 or G450 graphics
-	  card.  If M is selected, the module will be called mga.  AGP
-	  support is required for this driver to work.
-
-config DRM_SIS
-	tristate "SiS video cards"
-	depends on DRM && AGP
-	depends on FB_SIS || FB_SIS=n
-	help
-	  Choose this option if you have a SiS 630 or compatible video
-          chipset. If M is selected the module will be called sis. AGP
-          support is required for this driver to work.
-
-config DRM_VIA
-	tristate "Via unichrome video cards"
-	depends on DRM && PCI
-	help
-	  Choose this option if you have a Via unichrome or compatible video
-	  chipset. If M is selected the module will be called via.
-
-config DRM_SAVAGE
-	tristate "Savage video cards"
-	depends on DRM && PCI
-	help
-	  Choose this option if you have a Savage3D/4/SuperSavage/Pro/Twister
-	  chipset. If M is selected the module will be called savage.
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 89cf05a..f2d47f1 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -23,16 +23,5 @@ obj-$(CONFIG_DRM_KMS_HELPER) += drm_kms_helper.o
 CFLAGS_drm_trace_points.o := -I$(src)
 
 obj-$(CONFIG_DRM)	+= drm.o
-obj-$(CONFIG_DRM_TTM)	+= ttm/
-obj-$(CONFIG_DRM_TDFX)	+= tdfx/
-obj-$(CONFIG_DRM_R128)	+= r128/
-obj-$(CONFIG_DRM_RADEON)+= radeon/
-obj-$(CONFIG_DRM_MGA)	+= mga/
-obj-$(CONFIG_DRM_I810)	+= i810/
-obj-$(CONFIG_DRM_I915)  += i915/
-obj-$(CONFIG_DRM_SIS)   += sis/
-obj-$(CONFIG_DRM_SAVAGE)+= savage/
 obj-$(CONFIG_DRM_VMWGFX)+= vmwgfx/
-obj-$(CONFIG_DRM_VIA)	+=via/
-obj-$(CONFIG_DRM_NOUVEAU) +=nouveau/
 obj-y			+= i2c/
diff --git a/drivers/hwmon/sht15.c b/drivers/hwmon/sht15.c
index 8aa6e12..9594cdb 100644
--- a/drivers/hwmon/sht15.c
+++ b/drivers/hwmon/sht15.c
@@ -926,13 +926,7 @@ static int __devinit sht15_probe(struct platform_device *pdev)
 		if (voltage)
 			data->supply_uV = voltage;
 
-		ret = regulator_enable(data->reg);
-		if (ret != 0) {
-			dev_err(&pdev->dev,
-				"failed to enable regulator: %d\n", ret);
-			goto err_free_data;
-		}
-
+		regulator_enable(data->reg);
 		/*
 		 * Setup a notifier block to update this if another device
 		 * causes the voltage to change
diff --git a/drivers/input/misc/gpio_input.c b/drivers/input/misc/gpio_input.c
index 87c095d..39265bd 100644
--- a/drivers/input/misc/gpio_input.c
+++ b/drivers/input/misc/gpio_input.c
@@ -10,7 +10,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
  */
 
 #include <linux/kernel.h>
@@ -64,13 +63,6 @@ static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
 	uint8_t debounce;
 	bool sync_needed;
 
-#if 0
-	key_entry = kp->keys_info->keymap;
-	key_state = kp->key_state;
-	for (i = 0; i < nkeys; i++, key_entry++, key_state++)
-		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
-			gpio_read_detect_status(key_entry->gpio));
-#endif
 	key_entry = ds->info->keymap;
 	key_state = ds->key_state;
 	sync_needed = false;
@@ -82,11 +74,6 @@ static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
 		if (key_state->debounce & DEBOUNCE_UNSTABLE) {
 			debounce = key_state->debounce = DEBOUNCE_UNKNOWN;
 			enable_irq(gpio_to_irq(key_entry->gpio));
-			if (gpio_flags & GPIOEDF_PRINT_KEY_UNSTABLE)
-				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
-					"(%d) continue debounce\n",
-					ds->info->type, key_entry->code,
-					i, key_entry->gpio);
 		}
 		npolarity = !(gpio_flags & GPIOEDF_ACTIVE_HIGH);
 		pressed = gpio_get_value(key_entry->gpio) ^ npolarity;
@@ -94,29 +81,14 @@ static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
 			if (pressed == !(debounce & DEBOUNCE_PRESSED)) {
 				ds->debounce_count++;
 				key_state->debounce = DEBOUNCE_UNKNOWN;
-				if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
-					pr_info("gpio_keys_scan_keys: key %x-"
-						"%x, %d (%d) start debounce\n",
-						ds->info->type, key_entry->code,
-						i, key_entry->gpio);
 			}
 			continue;
 		}
 		if (pressed && (debounce & DEBOUNCE_NOTPRESSED)) {
-			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
-				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
-					"(%d) debounce pressed 1\n",
-					ds->info->type, key_entry->code,
-					i, key_entry->gpio);
 			key_state->debounce = DEBOUNCE_PRESSED;
 			continue;
 		}
 		if (!pressed && (debounce & DEBOUNCE_PRESSED)) {
-			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
-				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
-					"(%d) debounce pressed 0\n",
-					ds->info->type, key_entry->code,
-					i, key_entry->gpio);
 			key_state->debounce = DEBOUNCE_NOTPRESSED;
 			continue;
 		}
@@ -126,10 +98,6 @@ static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
 			key_state->debounce |= DEBOUNCE_WAIT_IRQ;
 		else
 			key_state->debounce |= DEBOUNCE_POLL;
-		if (gpio_flags & GPIOEDF_PRINT_KEYS)
-			pr_info("gpio_keys_scan_keys: key %x-%x, %d (%d) "
-				"changed to %d\n", ds->info->type,
-				key_entry->code, i, key_entry->gpio, pressed);
 		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
 			    key_entry->code, pressed);
 		sync_needed = true;
@@ -139,15 +107,6 @@ static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
 			input_sync(ds->input_devs->dev[i]);
 	}
 
-#if 0
-	key_entry = kp->keys_info->keymap;
-	key_state = kp->key_state;
-	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
-		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
-			gpio_read_detect_status(key_entry->gpio));
-	}
-#endif
-
 	if (ds->debounce_count)
 		hrtimer_start(timer, ds->info->debounce_time, HRTIMER_MODE_REL);
 	else if (!ds->use_irq)
@@ -184,11 +143,6 @@ static irqreturn_t gpio_event_input_irq_handler(int irq, void *dev_id)
 					&ds->timer, ds->info->debounce_time,
 					HRTIMER_MODE_REL);
 			}
-			if (ds->info->flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
-				pr_info("gpio_event_input_irq_handler: "
-					"key %x-%x, %d (%d) start debounce\n",
-					ds->info->type, key_entry->code,
-					keymap_index, key_entry->gpio);
 		} else {
 			disable_irq_nosync(irq);
 			ks->debounce = DEBOUNCE_UNSTABLE;
@@ -197,11 +151,6 @@ static irqreturn_t gpio_event_input_irq_handler(int irq, void *dev_id)
 	} else {
 		pressed = gpio_get_value(key_entry->gpio) ^
 			!(ds->info->flags & GPIOEDF_ACTIVE_HIGH);
-		if (ds->info->flags & GPIOEDF_PRINT_KEYS)
-			pr_info("gpio_event_input_irq_handler: key %x-%x, %d "
-				"(%d) changed to %d\n",
-				ds->info->type, key_entry->code, keymap_index,
-				key_entry->gpio, pressed);
 		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
 			    key_entry->code, pressed);
 		input_sync(ds->input_devs->dev[key_entry->dev]);
@@ -339,11 +288,6 @@ int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
 		spin_lock_irqsave(&ds->irq_lock, irqflags);
 		ds->use_irq = ret == 0;
 
-		pr_info("GPIO Input Driver: Start gpio inputs for %s%s in %s "
-			"mode\n", input_devs->dev[0]->name,
-			(input_devs->count > 1) ? "..." : "",
-			ret == 0 ? "interrupt" : "polling");
-
 		hrtimer_init(&ds->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 		ds->timer.function = gpio_event_input_timer_func;
 		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
diff --git a/drivers/input/mousedev.c b/drivers/input/mousedev.c
index 0110b5a..6f024ff 100644
--- a/drivers/input/mousedev.c
+++ b/drivers/input/mousedev.c
@@ -501,7 +501,6 @@ static void mixdev_close_devices(void)
 	}
 }
 
-
 static void mousedev_attach_client(struct mousedev *mousedev,
 				   struct mousedev_client *client)
 {
@@ -1088,14 +1087,10 @@ static int __init mousedev_init(void)
 #ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
 	error = misc_register(&psaux_mouse);
 	if (error)
-		pr_warning("could not register psaux device, error: %d\n",
-			   error);
+		pr_warning("could not register psaux device, error: %d\n", error);
 	else
 		psaux_registered = 1;
 #endif
-
-	pr_info("PS/2 mouse device common for all mice\n");
-
 	return 0;
 }
 
diff --git a/drivers/input/touchscreen/mms136.c b/drivers/input/touchscreen/mms136.c
index 9b8c1c2..049aaba 100644
--- a/drivers/input/touchscreen/mms136.c
+++ b/drivers/input/touchscreen/mms136.c
@@ -152,7 +152,6 @@ static void reset_points(struct ts_data *ts)
 	ts->finger_cnt = 0;
 	if (ts->platform_data->set_dvfs)
 		ts->platform_data->set_dvfs(false);
-	tsp_log("reset_all_fingers");
 	return;
 }
 
@@ -182,7 +181,6 @@ static void reset_tsp(struct ts_data *ts)
 	mdelay(200);
 	init_tsp(ts);
 
-	tsp_log("reset tsp ic done");
 	return;
 }
 
@@ -214,7 +212,6 @@ static bool fw_updater(struct ts_data *ts, char const *mode)
 	}
 
 	if ((!strcmp("force", mode)) || (buf[0] < fw_version)) {
-		pr_info("tsp: fw_updater: fw. force upload.\n");
 		ret = isp_updater(fw->data, fw->size, ts->platform_data);
 
 	} else if (!strcmp("file", mode)) {
@@ -263,15 +260,13 @@ static bool fw_updater(struct ts_data *ts, char const *mode)
 		kfree(fw_data);
 
 	} else {
-		pr_info("tsp: fw_updater: No need to fw. update.\n");
 		updated = false;
 	}
 
 	if (updated) {
 		reset_tsp(ts);
 		if (ts_read_reg_data(ts, TS_READ_VERSION_ADDR, 4, buf) > 0) {
-			pr_info("tsp: fw. ver. : new.(%.2x), cur.(%.2x)\n",
-							fw_version, buf[0]);
+			pr_info("tsp: fw. ver. : new.(%.2x), cur.(%.2x)\n", fw_version, buf[0]);
 			ts->fw_version_ic = (u32)buf[0];
 		} else
 			pr_err("tsp: fw. ver. read fail!!\n");
@@ -383,8 +378,6 @@ static void set_node_data(struct ts_data *ts_data, const u8 data_type,
 			if (x == 0 && y == 0)
 				*max_value = *min_value = temp;
 
-			tsp_log("cm_delta: rx %d tx %d value %d", x, y,
-				ts_data->node_data->cm_delta_data[x * tx + y]);
 			break;
 
 			case CM_ABS:
@@ -393,8 +386,6 @@ static void set_node_data(struct ts_data *ts_data, const u8 data_type,
 			if (x == 0 && y == 0)
 				*max_value = *min_value = temp;
 
-			tsp_log("cm_abs: rx %d tx %d value %d", x, y,
-				ts_data->node_data->cm_abs_data[x * tx + y]);
 			break;
 
 			case INTENSITY_DATA:
@@ -403,8 +394,6 @@ static void set_node_data(struct ts_data *ts_data, const u8 data_type,
 			if (x == 0 && y == 0)
 				*max_value = *min_value = temp;
 
-			tsp_log("intensity: rx %d tx %d value %d", x, y,
-				ts_data->node_data->intensity_data[x * tx + y]);
 			break;
 
 			case REFERENCE_DATA:
@@ -413,8 +402,6 @@ static void set_node_data(struct ts_data *ts_data, const u8 data_type,
 			if (x == 0 && y == 0)
 				*max_value = *min_value = temp;
 
-			tsp_log("reference: rx %d tx %d value %d", x, y,
-				ts_data->node_data->reference_data[x * tx + y]);
 			break;
 
 			default:
@@ -456,8 +443,6 @@ static void not_support_cmd(void *device_data)
 	sprintf(data->cmd_buff, "%s", "NA");
 	set_cmd_result(data, data->cmd_buff, strlen(data->cmd_buff));
 	data->cmd_state = NOT_APPLICABLE;
-	pr_info("tsp factory : %s: \"%s(%d)\"\n", __func__,
-				data->cmd_buff,	strlen(data->cmd_buff));
 	return;
 }
 
@@ -861,7 +846,6 @@ static void run_cm_abs_read(void *device_data)
 
 			max_value = max(max_value, temp);
 			min_value = min(min_value, temp);
-			tsp_log("cm_abs: rx %d tx %d value %d", x, y, temp);
 		}
 	}
 out:
@@ -1084,47 +1068,43 @@ static DEVICE_ATTR(cmd, S_IWUSR | S_IWGRP, NULL, cmd_store);
 static DEVICE_ATTR(cmd_status, S_IRUGO, cmd_status_show, NULL);
 static DEVICE_ATTR(cmd_result, S_IRUGO, cmd_result_show, NULL);
 
-static ssize_t mms136_pivot_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+static ssize_t mms136_pivot_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct ts_data *ts = dev_get_drvdata(dev);
-	int count;
+  struct ts_data *ts = dev_get_drvdata(dev);
+  int count;
 
-	count = sprintf(buf, "%d\n", ts->platform_data->pivot);
-	pr_info("tsp: pivot mode=%d\n", ts->platform_data->pivot);
+  count = sprintf(buf, "%d\n", ts->platform_data->pivot);
+  pr_info("tsp: pivot mode=%d\n", ts->platform_data->pivot);
 
-	return count;
+  return count;
 }
 
-ssize_t mms136_pivot_store(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf, size_t size)
+ssize_t mms136_pivot_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
 {
-	struct ts_data *ts = dev_get_drvdata(dev);
-	int pivot;
-
-	if (kstrtoint(buf, 0, &pivot))
-		pr_err("tsp: failed storing pivot value\n");
-
-	if (pivot < 0) {
-		pivot = 0;
-	} else if (pivot > 1) {
-		pivot = 1;
-	}
-
-	if (ts->platform_data->pivot != pivot) {
-		swap(ts->platform_data->x_pixel_size,
-					ts->platform_data->y_pixel_size);
-		input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0,
-					ts->platform_data->x_pixel_size, 0, 0);
-		input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0,
-					ts->platform_data->y_pixel_size, 0, 0);
-
-		ts->platform_data->pivot = pivot;
-		pr_info("tsp: pivot mode=%d\n", pivot);
-	}
-
-	return size;
+  struct ts_data *ts = dev_get_drvdata(dev);
+  int pivot;
+
+  if (kstrtoint(buf, 0, &pivot))
+    pr_err("tsp: failed storing pivot value\n");
+
+  if (pivot < 0) {
+    pivot = 0;
+  } else if (pivot > 1) {
+    pivot = 1;
+  }
+
+  if (ts->platform_data->pivot != pivot) {
+    swap(ts->platform_data->x_pixel_size,
+          ts->platform_data->y_pixel_size);
+    input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0,
+		  ts->platform_data->x_pixel_size, 0, 0);
+    input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0,
+		  ts->platform_data->y_pixel_size, 0, 0);
+    ts->platform_data->pivot = pivot;
+    pr_info("tsp: pivot mode=%d\n", pivot);
+  }
+
+  return size;
 }
 
 static DEVICE_ATTR(pivot, S_IRUGO | S_IWUSR, mms136_pivot_show, mms136_pivot_store);
@@ -1283,7 +1263,6 @@ static int __devinit ts_probe(struct i2c_client *client,
 	struct node_data *node_data;
 	u32 rx, tx;
 #endif
-	tsp_log("enter");
 
 	/* Return 1 if adapter supports everything we need, 0 if not. */
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
@@ -1357,8 +1336,6 @@ static int __devinit ts_probe(struct i2c_client *client,
 	}
 
 	if (ts->client->irq) {
-		tsp_log("trying to request irq: %s-%d",
-			ts->client->name, ts->client->irq);
 		ret = request_threaded_irq(client->irq, NULL,
 					ts_irq_handler,
 					IRQF_TRIGGER_LOW | IRQF_ONESHOT,
diff --git a/drivers/input/touchscreen/mms144.c b/drivers/input/touchscreen/mms144.c
index d1e64ef..46bcc19 100644
--- a/drivers/input/touchscreen/mms144.c
+++ b/drivers/input/touchscreen/mms144.c
@@ -176,18 +176,15 @@ static void set_ta_mode(int *ta_state)
 		case CABLE_TA:
 		command = 0x01;
 		ts_write_reg_data(ts, TS_TA_STAT_REG, 1, &command);
-		pr_info("tsp: TA connected\n");
 		break;
 		case CABLE_USB:
 		command = 0x01;
 		ts_write_reg_data(ts, TS_TA_STAT_REG, 1, &command);
-		pr_info("tsp: USB connected\n");
 		break;
 		case CABLE_NONE:
 		default:
 		command = 0x00;
 		ts_write_reg_data(ts, TS_TA_STAT_REG, 1, &command);
-		pr_info("tsp: No connected cable\n");
 		break;
 		}
 		enable_irq(ts->client->irq);
diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c
index 0e5084b..0bce812 100644
--- a/drivers/md/raid0.c
+++ b/drivers/md/raid0.c
@@ -5,17 +5,16 @@
 	     <maz@gloups.fdn.fr>
              Copyright (C) 1999, 2000 Ingo Molnar, Red Hat
 
-
    RAID-0 management functions.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
    any later version.
-   
+
    You should have received a copy of the GNU General Public License
    (for example /usr/src/linux/COPYING); if not, write to the Free
-   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
+   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include <linux/blkdev.h>
@@ -283,7 +282,7 @@ abort:
 	kfree(conf->strip_zone);
 	kfree(conf->devlist);
 	kfree(conf);
-	*private_conf = ERR_PTR(err);
+	*private_conf = NULL;
 	return err;
 }
 
@@ -314,7 +313,7 @@ static int raid0_mergeable_bvec(struct request_queue *q,
 	if (max < 0) max = 0; /* bio_add cannot handle a negative return */
 	if (max <= biovec->bv_len && bio_sectors == 0)
 		return biovec->bv_len;
-	else 
+	else
 		return max;
 }
 
diff --git a/drivers/mfd/twl6030-power.c b/drivers/mfd/twl6030-power.c
index d3e7196..168ce25 100644
--- a/drivers/mfd/twl6030-power.c
+++ b/drivers/mfd/twl6030-power.c
@@ -23,7 +23,7 @@
 
 #include <asm/mach-types.h>
 
-#define VREG_GRP		0
+#define VREG_GRP			0
 #define MSK_TRANSITION_APP_SHIFT	0x5
 
 static u8 dev_on_group;
@@ -114,7 +114,6 @@ static __initdata struct twl6030_resource_map twl6034_res_map[] = {
 	TWL6032_RES_DATA(RES_REGEN2, "REGEN2", 2, DEV_GRP_P1, BIT(1)),
 	TWL6032_RES_DATA(RES_REGEN, "REGEN1", 2, DEV_GRP_P1, BIT(0)),
 
-
 	/* PREQx_RES_ASS_D register resources */
 	TWL6032_RES_DATA(RES_LDOn15, "LDOn15", 4, DEV_GRP_P1, BIT(7)),
 	TWL6032_RES_DATA(RES_LDOn14, "LDOn14", 4, DEV_GRP_P1, BIT(6)),
@@ -247,7 +246,8 @@ static __init void twl6030_process_system_config(void)
 static __init void twl6030_program_map(unsigned long features)
 {
 	struct twl6030_resource_map *res;
-	int r, i;
+	int r = 0;
+	int i;
 
 	if (features & TWL6032_SUBCLASS) {
 		/*
@@ -284,7 +284,6 @@ static __init void twl6030_program_map(unsigned long features)
 			res++;
 		}
 
-
 		if (features & TWL6034_SUBCLASS)  {
 			r |= twl_i2c_write(TWL6030_MODULE_ID0, &mask[0],
 					TWL6032_PREQ1_RES_ASS_A, 3);
@@ -378,7 +377,6 @@ static __init void twl6030_update_map(struct twl4030_resconfig *res_list, \
 	}
 }
 
-
 static int twl6030_power_notifier_cb(struct notifier_block *notifier,
 					unsigned long pm_event,  void *unused)
 {
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index cad5f78..b5f1079 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -589,26 +589,23 @@ config LEDS_AN30259A
           function, combined operation is possible.
 
 config OMAP4_DUTY_CYCLE_LEGACY
-	tristate "Control OPP_NITRO usage based on duty cycle strategy (LEGACY)"
+	tristate "Control OPP_NITRO based on duty cycle strategy (LEGACY)"
 	depends on ARCH_OMAP4
 	default n
 	---help---
-	If you are going to use OPP_NITRO
-	with high level of leakage which.
-	could pontentially sustain a thermal runaway,
-	say Y here.
+	This could have high level of leakage which could pontentially sustain a thermal runaway.
 
 config MPU_333_ENABLE
-	bool "mpu gyro sensor MPL 4.1.1"
+	bool "Mpu gyro sensor MPL 4.1.1"
 	depends on I2C
 	default n
 
 config FACTORY_PBA_JACK_TEST_SUPPORT
-	bool "For samsung factory pba jack test"
+	bool "Samsung factory pba jack test"
 	default n
 
 config JACK_RESELECTOR_SUPPORT
-	bool "For samsung jack reselector control"
+	bool "Samsung jack reselector control"
 	default n
 
 config TWL6040_VIB
diff --git a/drivers/misc/modem_if/modem_io_device.c b/drivers/misc/modem_if/modem_io_device.c
old mode 100755
new mode 100644
index 19d5480..022897a
--- a/drivers/misc/modem_if/modem_io_device.c
+++ b/drivers/misc/modem_if/modem_io_device.c
@@ -11,7 +11,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
  */
 
 #include <linux/init.h>
@@ -30,9 +29,8 @@
 #include <linux/platform_data/modem.h>
 #include "modem_prj.h"
 
-
-#define HDLC_START	0x7F
-#define HDLC_END	0x7E
+#define HDLC_START		0x7F
+#define HDLC_END		0x7E
 #define SIZE_OF_HDLC_START	1
 #define SIZE_OF_HDLC_END	1
 #define MAX_RXDATA_SIZE		(4096 - 512)
@@ -872,7 +870,6 @@ send_remain_data:
 	}
 	tx_done_len += data_size;
 
-
 	/* send data with sk_buff, link device will put sk_buff
 	 * into the specific sk_buff_q and run work-q to send data
 	 */
@@ -881,15 +878,7 @@ send_remain_data:
 	if (err < 0)
 		return err;
 
-	if (err != tx_size)
-		pr_err("[MODEM_IF] %s: WARNNING: wrong tx size: %s, format=%d "
-			"count=%d, tx_size=%d, return_size=%d, data_size=%d\n",
-			__func__, iod->name, iod->format, count, tx_size,
-			err, data_size);
-
 	if (tx_done_len < count) {
-		pr_debug("[MODEM_IF] Send remain data. tx_done_len=%d, count=%d, "
-			"data_size : %d\n", tx_done_len, count, data_size);
 		data_size = count - tx_done_len;
 		goto send_remain_data;
 	}
@@ -1115,4 +1104,3 @@ int init_io_device(struct io_device *iod)
 				iod->name, iod->io_typ, ret);
 	return ret;
 }
-
diff --git a/drivers/misc/modem_if_v2/Kconfig b/drivers/misc/modem_if_v2/Kconfig
index 2a72e9b..0de936a 100644
--- a/drivers/misc/modem_if_v2/Kconfig
+++ b/drivers/misc/modem_if_v2/Kconfig
@@ -58,11 +58,6 @@ config LINK_DEVICE_DPRAM
 	depends on SEC_MODEM_V2
 	default n
 
-config LINK_DEVICE_USB
-	bool "modem driver link device USB"
-	depends on SEC_MODEM_V2
-	default n
-
 config LINK_DEVICE_HSIC
 	bool "modem driver link device HSIC"
 	depends on SEC_MODEM_V2
@@ -81,4 +76,4 @@ config LINK_DEVICE_SPI
 config WORKQUEUE_FRONT
 	bool "IPC: SPI workqueue front"
 	depends on SEC_MODEM_V2
-	default n
\ No newline at end of file
+	default n
diff --git a/drivers/misc/modem_if_v2/Makefile b/drivers/misc/modem_if_v2/Makefile
index 06d1f74..35f3f5d 100644
--- a/drivers/misc/modem_if_v2/Makefile
+++ b/drivers/misc/modem_if_v2/Makefile
@@ -17,7 +17,6 @@ obj-$(CONFIG_TDSCDMA_MODEM_SPRD8803) += modem_modemctl_device_sprd8803.o
 
 obj-$(CONFIG_LINK_DEVICE_MIPI) += modem_link_device_mipi.o
 obj-$(CONFIG_LINK_DEVICE_DPRAM) += modem_link_device_dpram.o
-obj-$(CONFIG_LINK_DEVICE_USB) += modem_link_device_usb.o
 obj-$(CONFIG_LINK_DEVICE_HSIC) += modem_link_device_hsic.o
 obj-$(CONFIG_LINK_DEVICE_C2C) += modem_link_device_c2c.o
-obj-$(CONFIG_LINK_DEVICE_SPI) += modem_link_device_spi.o
\ No newline at end of file
+obj-$(CONFIG_LINK_DEVICE_SPI) += modem_link_device_spi.o
diff --git a/drivers/misc/modem_if_v2/modem_link_device_mipi.c b/drivers/misc/modem_if_v2/modem_link_device_mipi.c
index 1236d53..a01b0d1 100644
--- a/drivers/misc/modem_if_v2/modem_link_device_mipi.c
+++ b/drivers/misc/modem_if_v2/modem_link_device_mipi.c
@@ -30,8 +30,6 @@
 #include "modem_link_device_mipi.h"
 #include "modem_utils.h"
 
-#define DEBUG_PRINT 0
-
 static int mipi_hsi_init_communication(struct link_device *ld,
 			struct io_device *iod)
 {
@@ -230,22 +228,6 @@ static void mipi_hsi_tx_work(struct work_struct *work)
 			if (ret < 0) {
 				/* TODO: Re Enqueue */
 				mipi_err("write fail : %d\n", ret);
-			}  else {
-				mipi_debug("write Done\n");
-
-#if DEBUG_PRINT
-				if ((iod->format == IPC_FMT) ||
-						(iod->format == IPC_RFS))
-					print_hex_dump(KERN_DEBUG,
-							iod->format == IPC_FMT ?
-							"IPC-TX: " : "RFS-TX: ",
-							DUMP_PREFIX_NONE,
-							1, 1,
-							(void *)fmt_skb->data,
-							fmt_skb->len <= 16 ?
-							(size_t)fmt_skb->len :
-							(size_t)16, false);
-#endif
 			}
 
 			dev_kfree_skb_any(fmt_skb);
@@ -263,7 +245,6 @@ static void mipi_hsi_tx_raw_work(struct work_struct *work)
 	unsigned bulk_size;
 
 	while (ld->sk_raw_tx_q.qlen) {
-		mipi_debug("raw qlen:%d\n", ld->sk_raw_tx_q.qlen);
 
 		if (ld->com_state != COM_ONLINE) {
 			mipi_debug("raw CP not ready\n");
@@ -1348,12 +1329,6 @@ static int if_hsi_write(struct if_hsi_channel *channel, u32 *data,
 				HSI_WRITE_DONE_TIMEOUT) < 0) {
 		mipi_err("ch=%d, hsi_write_done timeout : %d\n",
 					channel->channel_id, size);
-
-#if DEBUG_PRINT
-		print_hex_dump_bytes("[HSI]", DUMP_PREFIX_OFFSET,
-						channel->tx_data, size);
-#endif
-
 		hsi_write_cancel(channel->dev);
 
 		spin_lock_irqsave(&channel->tx_state_lock, flags);
@@ -1367,11 +1342,6 @@ static int if_hsi_write(struct if_hsi_channel *channel, u32 *data,
 		mipi_err("ch:%d,write_done fail,write_size:%d,origin_size:%d\n",
 				channel->channel_id, channel->tx_count, size);
 
-#ifdef DEBUG
-	print_hex_dump_bytes("[HSI]", DUMP_PREFIX_OFFSET,
-					channel->tx_data, size);
-#endif
-
 	return channel->tx_count;
 }
 
@@ -1566,41 +1536,10 @@ static void if_hsi_read_done(struct hsi_device *dev, unsigned int size)
 					channel->packet_size);
 		if (ret < 0) {
 			mipi_err("recv call fail : %d\n", ret);
-
-#if DEBUG_PRINT
-			if (channel->packet_size <= 0x40)
-				print_hex_dump_bytes("[HSI]",
-					DUMP_PREFIX_OFFSET,
-					channel->rx_data, channel->packet_size);
-			else {
-				print_hex_dump_bytes("[HSI]",
-					DUMP_PREFIX_OFFSET,
-					channel->rx_data, 0x40 - 0x10);
-				print_hex_dump_bytes("[HSI]",
-					DUMP_PREFIX_OFFSET,
-					(u8 *)channel->rx_data +
-					channel->packet_size - 0x10,
-					0x10);
-			}
-#endif
 			mipi_err("discard data: channel=%d, packet_size=%d\n",
 				channel->channel_id, channel->packet_size);
 		}
 
-#if DEBUG_PRINT
-		if ((iod->format == IPC_FMT) ||
-					(iod->format == IPC_RFS))
-			print_hex_dump(KERN_DEBUG,
-					iod->format == IPC_FMT ?
-					"IPC-RX: " : "RFS-RX: ",
-					DUMP_PREFIX_NONE,
-					1, 1,
-					(void *)channel->rx_data,
-					channel->packet_size <= 16 ?
-					(size_t)channel->packet_size :
-					(size_t)16, false);
-#endif
-
 		channel->packet_size = 0;
 
 		ch = channel->channel_id;
diff --git a/drivers/misc/modem_if_v2/sipc4_io_device.c b/drivers/misc/modem_if_v2/sipc4_io_device.c
index f4c08cf..f220112 100644
--- a/drivers/misc/modem_if_v2/sipc4_io_device.c
+++ b/drivers/misc/modem_if_v2/sipc4_io_device.c
@@ -30,7 +30,6 @@
 #include "modem_prj.h"
 #include "modem_utils.h"
 
-
 #define HDLC_START	0x7F
 #define HDLC_END	0x7E
 #define SIZE_OF_HDLC_START	1
@@ -39,7 +38,6 @@
 static const char hdlc_start[1] = { HDLC_START };
 static const char hdlc_end[1] = { HDLC_END };
 
-
 static ssize_t show_waketime(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -978,11 +976,6 @@ static ssize_t misc_write(struct file *filp, const char __user *buf,
 	if (err < 0)
 		return err;
 
-	if (err != tx_size)
-		mif_err("WARNNING: wrong tx size: %s, format=%d "
-			"count=%d, tx_size=%d, return_size=%d",
-			iod->name, iod->format, count, tx_size, err);
-
 	return count;
 }
 
@@ -1237,4 +1230,3 @@ int sipc4_init_io_device(struct io_device *iod)
 				iod->name, iod->io_typ, ret);
 	return ret;
 }
-
diff --git a/drivers/misc/modem_if_v2/sipc5_io_device.c b/drivers/misc/modem_if_v2/sipc5_io_device.c
index 38ffe63..a865f3c 100644
--- a/drivers/misc/modem_if_v2/sipc5_io_device.c
+++ b/drivers/misc/modem_if_v2/sipc5_io_device.c
@@ -858,11 +858,6 @@ static ssize_t misc_write(struct file *filp, const char __user *buf,
 	if (err < 0)
 		return err;
 
-	if (err != tx_size)
-		mif_err("WARNNING: wrong tx size: %s, format=%d "
-			"count=%d, tx_size=%d, return_size=%d",
-			iod->name, iod->format, count, tx_size, err);
-
 	return count;
 }
 
diff --git a/drivers/misc/omap4_duty_cycle.c b/drivers/misc/omap4_duty_cycle.c
index 42b4e88..085dbb8 100644
--- a/drivers/misc/omap4_duty_cycle.c
+++ b/drivers/misc/omap4_duty_cycle.c
@@ -2,7 +2,6 @@
  * Module to control max opp duty cycle
  *
  * Copyright (c) 2011 Texas Instrument
- * Contact: Eduardo Valentin <eduardo.valentin@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -715,4 +714,3 @@ static void __exit omap4_duty_module_exit(void)
 
 module_init(omap4_duty_module_init);
 module_exit(omap4_duty_module_exit);
-
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ab419ce..d71d3f7 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -1982,7 +1982,7 @@ void mmc_rescan(struct work_struct *work)
 
  out:
 	if (extend_wakelock)
-		wake_lock_timeout(&host->detect_wake_lock, HZ / 2);
+		wake_lock_timeout(&host->detect_wake_lock, HZ / 4);
 	else
 		wake_unlock(&host->detect_wake_lock);
 	if (host->caps & MMC_CAP_NEEDS_POLL) {
@@ -2235,7 +2235,6 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	struct omapsdcc_host *omaphost = mmc_priv(host);
 	unsigned long flags;
 
-
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index f5e1980..bf719fa 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -354,7 +354,8 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 		ext_csd[EXT_CSD_SEC_FEATURE_SUPPORT];
 	card->ext_csd.raw_trim_mult =
 		ext_csd[EXT_CSD_TRIM_MULT];
-	card->ext_csd.raw_partition_support = ext_csd[EXT_CSD_PARTITION_SUPPORT];
+	card->ext_csd.raw_partition_support =
+		ext_csd[EXT_CSD_PARTITION_SUPPORT];
 	if (card->ext_csd.rev >= 4) {
 		/*
 		 * Enhanced area feature support -- check whether the eMMC
@@ -433,9 +434,6 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 		card->cid.movi_pnm == 0x47344741 ||
 		card->cid.movi_pnm == 0x47344741 ||
 		card->cid.movi_pnm == 0x47384741) {
-			printk(KERN_DEBUG "%s : moviNAND VHX 4.41 "
-				"DISCARD feature is enabled\n",
-				mmc_hostname(card->host));
 			card->ext_csd.feature_support |= MMC_DISCARD_FEATURE;
 		}
 	card->ext_csd.raw_erased_mem_count = ext_csd[EXT_CSD_ERASED_MEM_CONT];
@@ -454,7 +452,6 @@ static inline void mmc_free_ext_csd(u8 *ext_csd)
 	kfree(ext_csd);
 }
 
-
 static int mmc_compare_ext_csds(struct mmc_card *card, unsigned bus_width)
 {
 	u8 *bw_ext_csd;
@@ -1016,9 +1013,6 @@ static int mmc_sleep(struct mmc_host *host)
 
 	if (card && card->ext_csd.rev >= 3) {
 		err = mmc_card_sleepawake(host, 1);
-		if (err < 0)
-			pr_debug("%s: Error %d while putting card into sleep",
-				 mmc_hostname(host), err);
 	}
 
 	return err;
@@ -1031,9 +1025,6 @@ static int mmc_awake(struct mmc_host *host)
 
 	if (card && card->ext_csd.rev >= 3) {
 		err = mmc_card_sleepawake(host, 0);
-		if (err < 0)
-			pr_debug("%s: Error %d while awaking sleeping card",
-				 mmc_hostname(host), err);
 	}
 
 	return err;
@@ -1103,9 +1094,6 @@ int mmc_attach_mmc(struct mmc_host *host)
 	 * support.
 	 */
 	if (ocr & 0x7F) {
-		printk(KERN_WARNING "%s: card claims to support voltages "
-		       "below the defined range. These will be ignored.\n",
-		       mmc_hostname(host));
 		ocr &= ~0x7F;
 	}
 
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index b26c5cc..ae2a451 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -648,7 +648,6 @@ MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
 MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
 MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
 
-
 static struct attribute *sd_std_attrs[] = {
 	&dev_attr_cid.attr,
 	&dev_attr_csd.attr,
@@ -797,11 +796,6 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 		for (retries = 1; retries <= 3; retries++) {
 			err = mmc_read_switch(card);
 			if (!err) {
-				if (retries > 1) {
-					printk(KERN_WARNING
-					       "%s: recovered\n", 
-					       mmc_hostname(host));
-				}
 				break;
 			} else {
 				printk(KERN_WARNING
@@ -839,9 +833,7 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 			ro = host->ops->get_ro(host);
 
 		if (ro < 0) {
-			printk(KERN_WARNING "%s: host does not "
-				"support reading read-only "
-				"switch. assuming write-enable.\n",
+			printk(KERN_WARNING "%s: assuming write-enable host.\n",
 				mmc_hostname(host));
 		} else if (ro > 0) {
 			mmc_card_set_readonly(card);
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index e9a6f2a..30b23e2 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -43,8 +43,6 @@
 #include <plat/cpu.h>
 #include <plat/omap-pm.h>
 
-#define DEBUG_PRINT 0
-
 /* OMAP HSMMC Host Controller Registers */
 #define OMAP_HSMMC_SYSCONFIG	0x0010
 #define OMAP_HSMMC_SYSSTATUS	0x0014
@@ -335,21 +333,13 @@ static int omap_hsmmc_1_set_power(struct device *dev, int slot, int power_on,
 
 	if (power_on) {
 		if (host->external_ldo) {
-#if DEBUG_PRINT
-			printk(KERN_INFO "%s LDO enable\n",
-				mmc_hostname(host->mmc));
-#endif
 			gpio_set_value(host->gpio_for_ldo, 1);
-			}
+		}
 		else
 			ret = mmc_regulator_set_ocr(host->mmc, host->vcc, vdd);
 		}
 	else {
 		if (host->external_ldo) {
-#if DEBUG_PRINT
-			printk(KERN_INFO "%s LDO Disable\n",
-				mmc_hostname(host->mmc));
-#endif
 			gpio_set_value(host->gpio_for_ldo, 0);
 			}
 		else
@@ -375,9 +365,6 @@ static int omap_hsmmc_2_set_power(struct device *dev, int slot, int power_on,
 		mmc_slot(host).before_set_reg(dev, slot, power_on, vdd);
 
 	if (power_on) {
-#if DEBUG_PRINT
-		printk(KERN_INFO "%s LDO enable\n", mmc_hostname(host->mmc));
-#endif
 		if (host->external_ldo)
 			gpio_set_value(host->gpio_for_ldo, 1);
 		else {
@@ -386,9 +373,6 @@ static int omap_hsmmc_2_set_power(struct device *dev, int slot, int power_on,
 				ret = regulator_enable(host->vcc_aux);
 		}
 	} else {
-#if DEBUG_PRINT
-		printk(KERN_INFO "%s LDO Disable\n", mmc_hostname(host->mmc));
-#endif
 		if (host->external_ldo)
 			gpio_set_value(host->gpio_for_ldo, 0);
 		else {
@@ -610,7 +594,6 @@ static int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)
 				regulator_disable(reg);
 			}
 		}
-		/*add delay to stabilize power*/
 		mdelay(50);
 	}
 
@@ -2444,7 +2427,6 @@ static int omap_hsmmc_regs_show(struct seq_file *s, void *data)
 	struct mmc_host *mmc = s->private;
 	struct omap_hsmmc_host *host = mmc_priv(mmc);
 
-
 	seq_printf(s, "mmc%d:\n"
 			" enabled:\t%d\n"
 			" dpm_state:\t%d\n"
@@ -2594,9 +2576,7 @@ static int __init omap_hsmmc_probe(struct platform_device *pdev)
 
 	spin_lock_init(&host->irq_lock);
 
-	/* wake lock init */
-	wake_lock_init(&host->wake_lock,
-		WAKE_LOCK_SUSPEND, "omaphsmmc_wake_lock");
+	wake_lock_init(&host->wake_lock, WAKE_LOCK_SUSPEND, "omaphsmmc_wake_lock");
 
 #ifdef CONFIG_MMC_SOFTWARE_TIMEOUT
 	init_timer(&host->sw_timer);
@@ -3029,7 +3009,6 @@ static int omap_hsmmc_runtime_resume(struct device *dev)
 	return 0;
 }
 
-
 static struct dev_pm_ops omap_hsmmc_dev_pm_ops = {
 	.suspend	= omap_hsmmc_suspend,
 	.resume		= omap_hsmmc_resume,
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index d651f97..76361cb 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2945,8 +2945,6 @@ source "drivers/atm/Kconfig"
 
 source "drivers/ieee802154/Kconfig"
 
-source "drivers/s390/net/Kconfig"
-
 source "drivers/net/caif/Kconfig"
 
 config TILE_NET
@@ -3290,9 +3288,9 @@ config PPPOE
 	  Support for PPP over Ethernet.
 
 	  This driver requires the latest version of pppd from the CVS
-	  repository at cvs.samba.org.  Alternatively, see the 
+	  repository at cvs.samba.org.  Alternatively, see the
 	  RoaringPenguin package (<http://www.roaringpenguin.com/pppoe>)
-	  which contains instruction on how to use this driver (under 
+	  which contains instruction on how to use this driver (under
 	  the heading "Kernel mode PPPoE").
 
 config PPTP
diff --git a/drivers/net/ifb.c b/drivers/net/ifb.c
index 902ba2f..441f6fe 100644
--- a/drivers/net/ifb.c
+++ b/drivers/net/ifb.c
@@ -26,7 +26,6 @@
 
 */
 
-
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
@@ -252,8 +251,6 @@ static int __init ifb_init_module(void)
 
 	rtnl_lock();
 	err = __rtnl_link_register(&ifb_link_ops);
-	if (err < 0)
-		goto out;
 
 	for (i = 0; i < numifbs && !err; i++) {
 		err = ifb_init_one(i);
@@ -261,8 +258,6 @@ static int __init ifb_init_module(void)
 	}
 	if (err)
 		__rtnl_link_unregister(&ifb_link_ops);
-
-out:
 	rtnl_unlock();
 
 	return err;
diff --git a/drivers/net/wireless/ath/ath9k/common.h b/drivers/net/wireless/ath/ath9k/common.h
index 247f7f8..77ec288 100644
--- a/drivers/net/wireless/ath/ath9k/common.h
+++ b/drivers/net/wireless/ath/ath9k/common.h
@@ -35,7 +35,7 @@
 #define WME_AC_BK   3
 #define WME_NUM_AC  4
 
-#define ATH_RSSI_DUMMY_MARKER   127
+#define ATH_RSSI_DUMMY_MARKER   0x127
 #define ATH_RSSI_LPF_LEN 		10
 #define RSSI_LPF_THRESHOLD		-20
 #define ATH_RSSI_EP_MULTIPLIER     (1<<7)
diff --git a/drivers/net/wireless/bcmdhd/Makefile b/drivers/net/wireless/bcmdhd/Makefile
index 6669338..f27f572 100644
--- a/drivers/net/wireless/bcmdhd/Makefile
+++ b/drivers/net/wireless/bcmdhd/Makefile
@@ -129,7 +129,8 @@ ifneq ($(CONFIG_BCM43241),)
   DHDCFLAGS += -DDHD_USE_IDLECOUNT
   DHDCFLAGS += -DSUPPORT_AMPDU_MPDU_CMD
   DHDCFLAGS += -DMIMO_ANT_SETTING -DAMPDU_HOSTREORDER
-  DHDCFLAGS += -DCUSTOM_GLOM_SETTING=1 -DCUSTOM_SDIO_F2_BLKSIZE=128
+  DHDCFLAGS += -DCUSTOM_GLOM_SETTING=1
+  DHDCFLAGS += -DCUSTOM_SDIO_F2_BLKSIZE=128
   DHDCFLAGS += -DROAM_AP_ENV_DETECTION
   DHDCFLAGS += -DSDIO_CRC_ERROR_FIX
   DHDCFLAGS :=$(filter-out -DWL_CFG80211_GON_COLLISION,$(DHDCFLAGS))
@@ -212,7 +213,7 @@ DHDCFLAGS += -include "dhd_sec_feature.h"
 
 EXTRA_LDFLAGS += --strip-debug
 
-EXTRA_CFLAGS += $(DHDCFLAGS) -DDHD_DEBUG
+EXTRA_CFLAGS += $(DHDCFLAGS)
 EXTRA_CFLAGS += -DSRCBASE=\"$(src)\"
 EXTRA_CFLAGS += -I$(src)/include/ -I$(src)/
 KBUILD_CFLAGS += -I$(LINUXDIR)/include -I$(shell pwd)
diff --git a/drivers/net/wireless/bcmdhd/bcmwifi_channels.h b/drivers/net/wireless/bcmdhd/bcmwifi_channels.h
index 0bc0950..7bd0977 100644
--- a/drivers/net/wireless/bcmdhd/bcmwifi_channels.h
+++ b/drivers/net/wireless/bcmdhd/bcmwifi_channels.h
@@ -274,61 +274,46 @@ typedef uint16 chanspec_t;
 
 #define LCHSPEC_CREATE(chan, band, bw, sb)  ((uint16)((chan) | (sb) | (bw) | (band)))
 
-#endif 
-
-
-
-
-#define WF_CHAN_FACTOR_2_4_G		4814	
-
-
-#define WF_CHAN_FACTOR_5_G		10000	
-
+#endif
 
-#define WF_CHAN_FACTOR_4_G		8000	
+#define WF_CHAN_FACTOR_2_4_G		4814
 
+#define WF_CHAN_FACTOR_5_G		10000
 
-#define WLC_MAXRATE	108	
-#define WLC_RATE_1M	2	
-#define WLC_RATE_2M	4	
-#define WLC_RATE_5M5	11	
-#define WLC_RATE_11M	22	
-#define WLC_RATE_6M	12	
-#define WLC_RATE_9M	18	
-#define WLC_RATE_12M	24	
-#define WLC_RATE_18M	36	
-#define WLC_RATE_24M	48	
-#define WLC_RATE_36M	72	
-#define WLC_RATE_48M	96	
-#define WLC_RATE_54M	108	
+#define WF_CHAN_FACTOR_4_G		8000
 
-#define WLC_2G_25MHZ_OFFSET		5	
+#define WLC_MAXRATE	108
+#define WLC_RATE_1M	2
+#define WLC_RATE_2M	4
+#define WLC_RATE_5M5	11
+#define WLC_RATE_11M	22
+#define WLC_RATE_6M	12
+#define WLC_RATE_9M	18
+#define WLC_RATE_12M	24
+#define WLC_RATE_18M	36
+#define WLC_RATE_24M	48
+#define WLC_RATE_36M	72
+#define WLC_RATE_48M	96
+#define WLC_RATE_54M	108
 
+#define WLC_2G_25MHZ_OFFSET		5
 
 extern char * wf_chspec_ntoa(chanspec_t chspec, char *buf);
 
-
 extern chanspec_t wf_chspec_aton(const char *a);
 
-
 extern bool wf_chspec_malformed(chanspec_t chanspec);
 
-
 extern bool wf_chspec_valid(chanspec_t chanspec);
 
-
 extern uint8 wf_chspec_ctlchan(chanspec_t chspec);
 
-
 extern chanspec_t wf_chspec_ctlchspec(chanspec_t chspec);
 
-
 extern chanspec_t wf_chspec_primary40_chspec(chanspec_t chspec);
 
-
 extern int wf_mhz2channel(uint freq, uint start_factor);
 
-
 extern int wf_channel2mhz(uint channel, uint start_factor);
 
-#endif	
+#endif
diff --git a/drivers/net/wireless/bcmdhd/dhd.h b/drivers/net/wireless/bcmdhd/dhd.h
index c54989b..e9b5b5a 100644
--- a/drivers/net/wireless/bcmdhd/dhd.h
+++ b/drivers/net/wireless/bcmdhd/dhd.h
@@ -96,15 +96,15 @@ enum dhd_op_flags {
 #define MAX_CNTL_TIMEOUT  2
 #endif
 
-#define DHD_SCAN_ASSOC_ACTIVE_TIME	40 /* ms: Embedded default Active setting from DHD */
-#define DHD_SCAN_UNASSOC_ACTIVE_TIME 80 /* ms: Embedded def. Unassoc Active setting from DHD */
-#define DHD_SCAN_PASSIVE_TIME		130 /* ms: Embedded default Passive setting from DHD */
+#define DHD_SCAN_ASSOC_ACTIVE_TIME	  40 /* ms: Embedded default Active setting from DHD */
+#define DHD_SCAN_UNASSOC_ACTIVE_TIME  80 /* ms: Embedded def. Unassoc Active setting from DHD */
+#define DHD_SCAN_PASSIVE_TIME		 130 /* ms: Embedded default Passive setting from DHD */
 
 #ifndef POWERUP_MAX_RETRY
-#define POWERUP_MAX_RETRY	3 /* how many times we retry to power up the chip */
+#define POWERUP_MAX_RETRY	6        /* how many times we retry to power up the chip */
 #endif
 #ifndef POWERUP_WAIT_MS
-#define POWERUP_WAIT_MS		2000	 /* ms: time out in waiting wifi to come up */
+#define POWERUP_WAIT_MS		1000	 /* ms: time out in waiting wifi to come up */
 #endif
 
 enum dhd_bus_wake_state {
diff --git a/drivers/net/wireless/bcmdhd/dhd_sec_feature.h b/drivers/net/wireless/bcmdhd/dhd_sec_feature.h
index 6a387ab..4260bb8 100644
--- a/drivers/net/wireless/bcmdhd/dhd_sec_feature.h
+++ b/drivers/net/wireless/bcmdhd/dhd_sec_feature.h
@@ -82,12 +82,12 @@
 
 /* REGION CODE */
 
-#if (WLAN_REGION_CODE >= 100) && (WLAN_REGION_CODE < 200) /*EUR*/
-#if (WLAN_REGION_CODE == 101) /*EUR ORG*/
+//#if (WLAN_REGION_CODE >= 100) && (WLAN_REGION_CODE < 200) /*EUR*/
+//#if (WLAN_REGION_CODE == 101) /*EUR ORG*/
 /* GAN LITE NAT KEEPALIVE FILTER */
-#define GAN_LITE_NAT_KEEPALIVE_FILTER
-#endif /* WLAN_REGION_CODE == 101 */
-#endif /* WLAN_REGION_CODE >= 100 && WLAN_REGION_CODE < 200 */
+//#define GAN_LITE_NAT_KEEPALIVE_FILTER
+//#endif
+//#endif
 
 #if (WLAN_REGION_CODE >= 200) && (WLAN_REGION_CODE < 300) /* KOR */
 #undef USE_INITIAL_2G_SCAN_ORG
diff --git a/drivers/net/wireless/bcmdhd/wl_android.c b/drivers/net/wireless/bcmdhd/wl_android.c
index 6c066cf..afc5ae3 100644
--- a/drivers/net/wireless/bcmdhd/wl_android.c
+++ b/drivers/net/wireless/bcmdhd/wl_android.c
@@ -320,7 +320,6 @@ static int wl_android_get_link_speed(struct net_device *net, char *command, int
 	/* Convert Kbps to Android Mbps */
 	link_speed = link_speed / 1000;
 	bytes_written = snprintf(command, total_len, "LinkSpeed %d", link_speed);
-	DHD_INFO(("%s: command result is %s\n", __FUNCTION__, command));
 	return bytes_written;
 }
 
@@ -345,7 +344,6 @@ static int wl_android_get_rssi(struct net_device *net, char *command, int total_
 		bytes_written = ssid.SSID_len;
 	}
 	bytes_written += snprintf(&command[bytes_written], total_len, " rssi %d", rssi);
-	DHD_INFO(("%s: command result is %s (%d)\n", __FUNCTION__, command, bytes_written));
 	return bytes_written;
 }
 
@@ -365,10 +363,7 @@ static int wl_android_set_suspendopt(struct net_device *dev, char *command, int
 		ret_now = net_os_set_suspend_disable(dev, suspend_flag);
 
 		if (ret_now != suspend_flag) {
-			if (!(ret = net_os_set_suspend(dev, ret_now, 1)))
-				DHD_INFO(("%s: Suspend Flag %d -> %d\n",
-					__FUNCTION__, ret_now, suspend_flag));
-			else
+			if ((ret = net_os_set_suspend(dev, ret_now, 1)))
 				DHD_ERROR(("%s: failed %d\n", __FUNCTION__, ret));
 		}
 #ifdef CUSTOMER_HW4
@@ -389,9 +384,7 @@ static int wl_android_set_suspendmode(struct net_device *dev, char *command, int
 	if (suspend_flag != 0)
 		suspend_flag = 1;
 
-	if (!(ret = net_os_set_suspend(dev, suspend_flag, 0)))
-		DHD_INFO(("%s: Suspend Mode %d\n", __FUNCTION__, suspend_flag));
-	else
+	if ((ret = net_os_set_suspend(dev, suspend_flag, 0)))
 		DHD_ERROR(("%s: failed %d\n", __FUNCTION__, ret));
 #endif
 	return ret;
@@ -535,8 +528,6 @@ static int wl_android_get_full_roam_scan_period(
 		DHD_ERROR(("%s: get full roam scan period failed code %d\n",
 			__func__, error));
 		return -1;
-	} else {
-		DHD_INFO(("%s: get full roam scan period %d\n", __func__, full_roam_scan_period));
 	}
 
 	bytes_written = snprintf(command, total_len, "%s %d",
@@ -571,8 +562,6 @@ int wl_android_set_country_rev(
 			__FUNCTION__, cspec.ccode, cspec.rev, error));
 	} else {
 		dhd_bus_country_set(dev, &cspec);
-		DHD_INFO(("%s: set country '%s/%d'\n",
-			__FUNCTION__, cspec.ccode, cspec.rev));
 	}
 
 	return error;
@@ -595,8 +584,6 @@ static int wl_android_get_country_rev(
 		return -1;
 	} else {
 		memcpy(&cspec, smbuf, sizeof(cspec));
-		DHD_INFO(("%s: get country '%c%c %d'\n",
-			__FUNCTION__, cspec.ccode[0], cspec.ccode[1], cspec.rev));
 	}
 
 	bytes_written = snprintf(command, total_len, "%s %c%c %d",
@@ -1083,14 +1070,11 @@ static int wl_android_set_pno_setup(struct net_device *dev, char *command, int t
 		};
 #endif /* PNO_SET_DEBUG */
 
-	DHD_INFO(("%s: command=%s, len=%d\n", __FUNCTION__, command, total_len));
-
 	if (total_len < (strlen(CMD_PNOSETUP_SET) + sizeof(cmd_tlv_t))) {
 		DHD_ERROR(("%s argument=%d less min size\n", __FUNCTION__, total_len));
 		goto exit_proc;
 	}
 
-
 #ifdef PNO_SET_DEBUG
 	memcpy(command, pno_in_example, sizeof(pno_in_example));
 	for (i = 0; i < sizeof(pno_in_example); i++)
@@ -1124,7 +1108,6 @@ static int wl_android_set_pno_setup(struct net_device *dev, char *command, int t
 			}
 			str_ptr++;
 			pno_time = simple_strtoul(str_ptr, &str_ptr, 16);
-			DHD_INFO(("%s: pno_time=%d\n", __FUNCTION__, pno_time));
 
 			if (str_ptr[0] != 0) {
 				if ((str_ptr[0] != PNO_TLV_FREQ_REPEAT)) {
@@ -1134,7 +1117,6 @@ static int wl_android_set_pno_setup(struct net_device *dev, char *command, int t
 				}
 				str_ptr++;
 				pno_repeat = simple_strtoul(str_ptr, &str_ptr, 16);
-				DHD_INFO(("%s :got pno_repeat=%d\n", __FUNCTION__, pno_repeat));
 				if (str_ptr[0] != PNO_TLV_FREQ_EXPO_MAX) {
 					DHD_ERROR(("%s FREQ_EXPO_MAX corrupted field size\n",
 						__FUNCTION__));
@@ -1142,8 +1124,6 @@ static int wl_android_set_pno_setup(struct net_device *dev, char *command, int t
 				}
 				str_ptr++;
 				pno_freq_expo_max = simple_strtoul(str_ptr, &str_ptr, 16);
-				DHD_INFO(("%s: pno_freq_expo_max=%d\n",
-					__FUNCTION__, pno_freq_expo_max));
 			}
 		}
 	} else {
@@ -1334,10 +1314,8 @@ static int wl_android_set_fwpath(struct net_device *net, char *command, int tota
 	bcm_strncpy_s(fw_path, sizeof(fw_path),
 		command + strlen(CMD_SETFWPATH) + 1, MOD_PARAM_PATHLEN - 1);
 	if (strstr(fw_path, "apsta") != NULL) {
-		DHD_INFO(("GOT APSTA FIRMWARE\n"));
 		ap_fw_loaded = TRUE;
 	} else {
-		DHD_INFO(("GOT STA FIRMWARE\n"));
 		ap_fw_loaded = FALSE;
 	}
 	return 0;
@@ -1350,7 +1328,6 @@ wl_android_set_max_num_sta(struct net_device *dev, const char* string_num)
 	int max_assoc;
 
 	max_assoc = bcm_atoi(string_num);
-	DHD_INFO(("%s : HAPD_MAX_NUM_STA = %d\n", __FUNCTION__, max_assoc));
 	wldev_iovar_setint(dev, "maxassoc", max_assoc);
 	return 1;
 }
@@ -1367,7 +1344,6 @@ wl_android_set_ssid(struct net_device *dev, const char* hapd_ssid)
 		DHD_ERROR(("%s : Too long SSID Length %d\n", __FUNCTION__, strlen(hapd_ssid)));
 	}
 	bcm_strncpy_s(ssid.SSID, sizeof(ssid.SSID), hapd_ssid, ssid.SSID_len);
-	DHD_INFO(("%s: HAPD_SSID = %s\n", __FUNCTION__, ssid.SSID));
 	ret = wldev_ioctl(dev, WLC_SET_SSID, &ssid, sizeof(wlc_ssid_t), true);
 	if (ret < 0) {
 		DHD_ERROR(("%s : WLC_SET_SSID Error:%d\n", __FUNCTION__, ret));
@@ -1383,7 +1359,6 @@ wl_android_set_hide_ssid(struct net_device *dev, const char* string_num)
 	int enable = 0;
 
 	hide_ssid = bcm_atoi(string_num);
-	DHD_INFO(("%s: HAPD_HIDE_SSID = %d\n", __FUNCTION__, hide_ssid));
 	if (hide_ssid)
 		enable = 1;
 	wldev_iovar_setint(dev, "closednet", enable);
@@ -1409,7 +1384,6 @@ wl_android_set_auto_channel(struct net_device *dev, const char* string_num,
 	wl_uint32_list_t request;
 
 	channel = bcm_atoi(string_num);
-	DHD_INFO(("%s : HAPD_AUTO_CHANNEL = %d\n", __FUNCTION__, channel));
 
 	if (channel == 20)
 		ret = wldev_ioctl(dev, WLC_START_CHANNEL_SEL, (void *)&req_buf,
@@ -1435,8 +1409,6 @@ wl_android_set_auto_channel(struct net_device *dev, const char* string_num,
 		ret = wldev_ioctl(dev, WLC_GET_CHANNEL_SEL, &chosen, sizeof(chosen),
 			false);
 		if (ret < 0 || dtoh32(chosen) == 0) {
-			DHD_INFO(("%s: %d tried, ret = %d, chosen = %d\n",
-				__FUNCTION__, (10 - retry), ret, chosen));
 			bcm_mdelay(200);
 		}
 		else {
@@ -1453,7 +1425,6 @@ wl_android_set_auto_channel(struct net_device *dev, const char* string_num,
 
 done:
 	snprintf(command, 4, "%d", channel);
-	DHD_INFO(("%s: command result is %s\n", __FUNCTION__, command));
 
 	return 4;
 }
@@ -1465,8 +1436,6 @@ wl_android_sta_diassoc(struct net_device *dev, const char* straddr)
 {
 	scb_val_t scbval;
 
-	DHD_INFO(("%s: deauth STA %s\n", __FUNCTION__, straddr));
-
 	/* Unspecified reason */
 	scbval.val = htod32(1);
 	bcm_ether_atoe(straddr, &scbval.ea);
@@ -1632,10 +1601,8 @@ int wl_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		ret = -EFAULT;
 		goto exit;
 	}
-	DHD_INFO(("%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name));
 
 	if (strnicmp(command, CMD_START, strlen(CMD_START)) == 0) {
-		DHD_INFO(("%s, Received regular START command\n", __FUNCTION__));
 #ifdef SUPPORT_DEEP_SLEEP
 		sleep_never = 1;
 #else
@@ -2211,7 +2178,6 @@ void* wl_android_prealloc(int section, unsigned long size)
 	if (wifi_control_data && wifi_control_data->mem_prealloc) {
 		alloc_ptr = wifi_control_data->mem_prealloc(section, size);
 		if (alloc_ptr) {
-			DHD_INFO(("success alloc section %d\n", section));
 			if (size != 0L)
 				bzero(alloc_ptr, size);
 			return alloc_ptr;
diff --git a/drivers/net/wireless/bcmdhd/wl_cfg80211.c b/drivers/net/wireless/bcmdhd/wl_cfg80211.c
old mode 100755
new mode 100644
index a870a8f..b817221
--- a/drivers/net/wireless/bcmdhd/wl_cfg80211.c
+++ b/drivers/net/wireless/bcmdhd/wl_cfg80211.c
@@ -2,13 +2,13 @@
  * Linux cfg80211 driver
  *
  * Copyright (C) 1999-2012, Broadcom Corporation
- * 
+ *
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
  * under the terms of the GNU General Public License version 2 (the "GPL"),
  * available at http://www.broadcom.com/licenses/GPLv2.php, with the
  * following added to such license:
- * 
+ *
  *      As a special exception, the copyright holders of this software give you
  * permission to link this software with independent modules, and to copy and
  * distribute the resulting executable under terms of your choice, provided that
@@ -16,7 +16,7 @@
  * the license of that module.  An independent module is a module which is not
  * derived from this software.  The special exception does not apply to any
  * modifications of the software.
- * 
+ *
  *      Notwithstanding the above, under no circumstances may you combine this
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
@@ -148,7 +148,6 @@ u32 wl_dbg_level = WL_DBG_ERR;
 
 #define WL_CHANSPEC_CTL_SB_NONE WL_CHANSPEC_CTL_SB_LLL
 
-
 #define DNGL_FUNC(func, parameters) func parameters;
 #define COEX_DHCP
 
@@ -179,7 +178,6 @@ static const struct ieee80211_regdomain brcm_regdom = {
 		REG_RULE(5470-10, 5850+10, 40, 6, 20, 0), }
 };
 
-
 /* Data Element Definitions */
 #define WPS_ID_CONFIG_METHODS     0x1008
 #define WPS_ID_REQ_TYPE           0x103A
@@ -495,7 +493,6 @@ void print_roam_cache(void);
 void set_roam_band(int band);
 #endif
 
-
 #define CHECK_SYS_UP(wlpriv)						\
 do {									\
 	struct net_device *ndev = wl_to_prmry_ndev(wlpriv);       	\
@@ -505,12 +502,10 @@ do {									\
 	}								\
 } while (0)
 
-
 #define IS_WPA_AKM(akm) ((akm) == RSN_AKM_NONE || 			\
 				 (akm) == RSN_AKM_UNSPECIFIED || 	\
 				 (akm) == RSN_AKM_PSK)
 
-
 extern int dhd_wait_pend8021x(struct net_device *dev);
 #ifdef PROP_TXSTATUS_VSDB
 extern int disable_proptx;
@@ -988,7 +983,6 @@ static chanspec_t wl_cfg80211_get_shared_freq(struct wiphy *wiphy)
 		return wl_ch_host_to_driver(WL_P2P_TEMP_CHAN);
 	}
 
-
 	*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
 	if ((err = wldev_ioctl(dev, WLC_GET_BSS_INFO, wl->extra_buf,
 		WL_EXTRA_BUF_MAX, false))) {
@@ -1006,13 +1000,11 @@ static chanspec_t wl_cfg80211_get_shared_freq(struct wiphy *wiphy)
 static struct net_device* wl_cfg80211_add_monitor_if(char *name)
 {
 #if defined(WLP2P) && defined(WL_ENABLE_P2P_IF)
-	WL_INFO(("wl_cfg80211_add_monitor_if: No more support monitor interface\n"));
 	return ERR_PTR(-EOPNOTSUPP);
 #else
 	struct net_device* ndev = NULL;
 
 	dhd_add_monitor(name, &ndev);
-	WL_INFO(("wl_cfg80211_add_monitor_if net device returned: 0x%p\n", ndev));
 	return ndev;
 #endif /* defined(WLP2P) && defined(WL_ENABLE_P2P_IF) */
 }
@@ -1046,7 +1038,6 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 	dhd = (dhd_pub_t *)(wl->pub);
 #endif /* PROP_TXSTATUS_VSDB */
 
-
 	/* Use primary I/F for sending cmds down to firmware */
 	_ndev = wl_to_prmry_ndev(wl);
 
@@ -1090,8 +1081,6 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 				rtnl_unlock();
 				rollback_lock = true;
 			}
-			WL_INFO(("%s: Released the lock and wait till IF_DEL is complete\n",
-				__func__));
 			timeout = wait_event_interruptible_timeout(wl->netif_change_event,
 				(wl_get_p2p_status(wl, IF_DELETING) == false),
 				msecs_to_jiffies(MAX_WAIT_TIME));
@@ -1177,8 +1166,6 @@ wl_cfg80211_add_virtual_iface(struct wiphy *wiphy, char *name,
 				return ERR_PTR(-ENOMEM);
 			}
 			vwdev->wiphy = wl->wdev->wiphy;
-			WL_INFO((" virtual interface(%s) is created memalloc done \n",
-				wl->p2p->vir_ifname));
 			vwdev->iftype = type;
 			_ndev =  wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION);
 			_ndev->ieee80211_ptr = vwdev;
@@ -1543,7 +1530,6 @@ wl_cfg80211_is_progress_ifchange(void)
 	return is_progress;
 }
 
-
 s32
 wl_cfg80211_notify_ifchange(void)
 {
@@ -1993,16 +1979,13 @@ wl_run_escan(struct wl_priv *wl, struct net_device *ndev,
 						(default_chan_list[2] == SOCIAL_CHAN_3))) {
 				/* SOCIAL CHANNELS 1, 6, 11 */
 				search_state = WL_P2P_DISC_ST_SEARCH;
-				WL_INFO(("P2P SEARCH PHASE START \n"));
 			} else if ((dev = wl_to_p2p_bss_ndev(wl, P2PAPI_BSSCFG_CONNECTION)) &&
 				(wl_get_mode_by_netdev(wl, dev) == WL_MODE_AP)) {
 				/* If you are already a GO, then do SEARCH only */
-				WL_INFO(("Already a GO. Do SEARCH Only"));
 				search_state = WL_P2P_DISC_ST_SEARCH;
 				num_chans = n_nodfs;
 
 			} else {
-				WL_INFO(("P2P SCAN STATE START \n"));
 				num_chans = n_nodfs;
 			}
 
@@ -2023,7 +2006,6 @@ exit:
 	return err;
 }
 
-
 static s32
 wl_do_escan(struct wl_priv *wl, struct wiphy *wiphy, struct net_device *ndev,
 	struct cfg80211_scan_request *request)
@@ -2127,7 +2109,6 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 	}
 #endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
 
-
 	/* Arm scan timeout timer */
 	mod_timer(&wl->scan_timeout, jiffies + msecs_to_jiffies(WL_SCAN_TIMER_INTERVAL_MS));
 	iscan_req = false;
@@ -2221,8 +2202,6 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		/* we don't do iscan in ibss */
 		ssids = this_ssid;
 	}
-	if (request && !p2p_scan(wl))
-		WL_TRACE_HW4(("START SCAN\n"));
 	wl->scan_request = request;
 	wl_set_drv_status(wl, SCANNING, ndev);
 	if (iscan_req) {
@@ -2253,7 +2232,6 @@ __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		else
 			goto scan_out;
 
-
 	} else {
 		memset(&sr->ssid, 0, sizeof(sr->ssid));
 		sr->ssid.SSID_len =
@@ -3201,10 +3179,6 @@ wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 #endif /* ROAM_CHANNEL_CACHE */
 	}
 	ext_join_params->assoc.chanspec_num = htod32(ext_join_params->assoc.chanspec_num);
-	if (ext_join_params->ssid.SSID_len < IEEE80211_MAX_SSID_LEN) {
-		WL_INFO(("ssid \"%s\", len (%d)\n", ext_join_params->ssid.SSID,
-			ext_join_params->ssid.SSID_len));
-	}
 	wl_set_drv_status(wl, CONNECTING, dev);
 	err = wldev_iovar_setbuf_bsscfg(dev, "join", ext_join_params, join_params_size,
 		wl->ioctl_buf, WLC_IOCTL_MAXLEN, wl_cfgp2p_find_idx(wl, dev), &wl->ioctl_buf_sync);
@@ -3235,10 +3209,6 @@ set_ssid:
 	wl_ch_to_chanspec(wl->channel, &join_params, &join_params_size);
 	WL_DBG(("join_param_size %d\n", join_params_size));
 
-	if (join_params.ssid.SSID_len < IEEE80211_MAX_SSID_LEN) {
-		WL_INFO(("ssid \"%s\", len (%d)\n", join_params.ssid.SSID,
-			join_params.ssid.SSID_len));
-	}
 	wl_set_drv_status(wl, CONNECTING, dev);
 	err = wldev_ioctl(dev, WLC_SET_SSID, &join_params, join_params_size, true);
 	if (err) {
@@ -3721,7 +3691,6 @@ static s32
 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
 	struct net_device *dev, u8 key_idx)
 {
-	WL_INFO(("Not supported\n"));
 	return -EOPNOTSUPP;
 }
 
@@ -3735,9 +3704,6 @@ wl_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 	s32 rate;
 	s32 err = 0;
 	sta_info_t *sta;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
-	s8 eabuf[ETHER_ADDR_STR_LEN];
-#endif
 	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
 	CHECK_SYS_UP(wl);
 	if (wl_get_mode_by_netdev(wl, dev) == WL_MODE_AP) {
@@ -3755,15 +3721,10 @@ wl_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 		sta->idle = dtoh32(sta->idle);
 		sta->in = dtoh32(sta->in);
 		sinfo->inactive_time = sta->idle * 1000;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
 		if (sta->flags & WL_STA_ASSOC) {
 			sinfo->filled |= STATION_INFO_CONNECTED_TIME;
 			sinfo->connected_time = sta->in;
 		}
-		WL_INFO(("STA %s : idle time : %d sec, connected time :%d ms\n",
-			bcm_ether_ntoa((const struct ether_addr *)mac, eabuf), sinfo->inactive_time,
-			sta->idle * 1000));
-#endif
 	} else if (wl_get_mode_by_netdev(wl, dev) == WL_MODE_BSS) {
 		get_pktcnt_t pktcnt;
 		u8 *curmacp = wl_read_prof(wl, dev, WL_PROF_BSSID);
@@ -3923,7 +3884,6 @@ static s32 wl_cfg80211_resume(struct wiphy *wiphy)
 	s32 err = 0;
 
 	if (unlikely(!wl_get_drv_status(wl, READY, ndev))) {
-		WL_INFO(("device is not ready\n"));
 		return 0;
 	}
 
@@ -3944,8 +3904,6 @@ static s32 wl_cfg80211_suspend(struct wiphy *wiphy)
 	struct net_device *ndev = wl_to_prmry_ndev(wl);
 	unsigned long flags;
 	if (unlikely(!wl_get_drv_status(wl, READY, ndev))) {
-		WL_INFO(("device is not ready : status (%d)\n",
-			(int)wl->status));
 		return 0;
 	}
 	for_each_ndev(wl, iter, next)
@@ -3986,8 +3944,6 @@ wl_update_pmklist(struct net_device *dev, struct wl_pmk_list *pmk_list,
 	 * Refer code wlc_bsscfg.c->wlc_bsscfg_sta_init
 	 */
 	if (primary_dev != dev) {
-		WL_INFO(("Not supporting Flushing pmklist on virtual"
-			" interfaces than primary interface\n"));
 		return err;
 	}
 
@@ -4259,7 +4215,6 @@ wl_cfg80211_remain_on_channel(struct wiphy *wiphy, struct net_device *dev,
 
 exit:
 	if (err == BCME_OK) {
-		WL_INFO(("Success\n"));
 		cfg80211_ready_on_channel(dev, *cookie, channel,
 			channel_type, duration, GFP_KERNEL);
 	} else {
@@ -4497,7 +4452,6 @@ wl_cfg80211_config_p2p_pub_af_tx(struct wiphy *wiphy,
 	return err;
 }
 
-
 static bool
 wl_cfg80211_send_action_frame(struct wiphy *wiphy, struct net_device *dev,
 	struct net_device *ndev, wl_af_params_t *af_params,
@@ -4513,7 +4467,6 @@ wl_cfg80211_send_action_frame(struct wiphy *wiphy, struct net_device *dev,
 #endif
 	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
 
-
 	category = action_frame->data[DOT11_ACTION_CAT_OFF];
 	action = action_frame->data[DOT11_ACTION_ACT_OFF];
 
@@ -4724,9 +4677,6 @@ exit:
 	if (wl->afx_hdl->pending_tx_act_frm)
 		wl->afx_hdl->pending_tx_act_frm = NULL;
 
-	WL_INFO(("-- sending Action Frame is %s, listen chan: %d\n",
-		(ack) ? "Succeeded!!":"Failed!!", wl->afx_hdl->my_listen_chan));
-
 #ifdef WL_CFG80211_GON_COLLISION
 	if (wl->block_gon_req_tx_count) {
 		wl->block_gon_req_tx_count--;
@@ -4916,7 +4866,6 @@ exit:
 	return err;
 }
 
-
 static void
 wl_cfg80211_mgmt_frame_register(struct wiphy *wiphy, struct net_device *dev,
 	u16 frame_type, bool reg)
@@ -4930,7 +4879,6 @@ wl_cfg80211_mgmt_frame_register(struct wiphy *wiphy, struct net_device *dev,
 	return;
 }
 
-
 static s32
 wl_cfg80211_change_bss(struct wiphy *wiphy,
 	struct net_device *dev,
@@ -5225,7 +5173,6 @@ wl_validate_wpaie(struct net_device *dev, wpa_ie_fixed_t *wpaie, s32 bssidx)
 	len -= WPA_IE_TAG_FIXED_LEN;
 	/* check for multicast cipher suite */
 	if (len < WPA_SUITE_LEN) {
-		WL_INFO(("no multicast cipher suite\n"));
 		goto exit;
 	}
 
@@ -5257,7 +5204,6 @@ wl_validate_wpaie(struct net_device *dev, wpa_ie_fixed_t *wpaie, s32 bssidx)
 	}
 	/* Check for unicast suite(s) */
 	if (len < WPA_IE_SUITE_COUNT_LEN) {
-		WL_INFO(("no unicast suite\n"));
 		goto exit;
 	}
 	/* walk thru unicast cipher list and pick up what we recognize */
@@ -5293,7 +5239,6 @@ wl_validate_wpaie(struct net_device *dev, wpa_ie_fixed_t *wpaie, s32 bssidx)
 	len -= (count - i) * WPA_SUITE_LEN;
 	/* Check for auth key management suite(s) */
 	if (len < WPA_IE_SUITE_COUNT_LEN) {
-		WL_INFO((" no auth key mgmt suite\n"));
 		goto exit;
 	}
 	/* walk thru auth management suite list and pick up what we recognize */
@@ -5585,7 +5530,6 @@ wl_cfg80211_bcn_bringup_ap(
 		}
 	}
 
-
 exit:
 	return err;
 }
@@ -5694,7 +5638,6 @@ static s32 wl_cfg80211_hostapd_sec(
 	bool update_bss = 0;
 	struct wl_priv *wl = wlcfg_drv_priv;
 
-
 	if (ies->wps_ie) {
 		if (wl->ap_info->wps_ie &&
 			memcmp(wl->ap_info->wps_ie, ies->wps_ie, ies->wps_ie_len)) {
@@ -6154,7 +6097,6 @@ int wl_cfg80211_sched_scan_start(struct wiphy *wiphy,
 	WL_PNO(("ssids:%d pno_time:%d pno_repeat:%d pno_freq:%d \n",
 		request->n_ssids, pno_time, pno_repeat, pno_freq_expo_max));
 
-
 	if (!request || !request->n_ssids || !request->n_match_sets) {
 		WL_ERR(("Invalid sched scan req!! n_ssids:%d \n", request->n_ssids));
 		return -EINVAL;
@@ -6564,7 +6506,6 @@ static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi, u8 i
 #endif
 	}
 
-
 	cbss = cfg80211_inform_bss_frame(wiphy, channel, mgmt,
 		le16_to_cpu(notif_bss_info->frame_len), signal, aflags);
 	if (unlikely(!cbss)) {
@@ -6674,7 +6615,6 @@ wl_notify_connect_status_ap(struct wl_priv *wl, struct net_device *ndev,
 	if (event == WLC_E_LINK && reason == WLC_E_LINK_BSSCFG_DIS &&
 		wl_get_p2p_status(wl, IF_DELETING) && (ndev != wl_to_prmry_ndev(wl))) {
 		wl_add_remove_eventmsg(ndev, WLC_E_PROBREQ_MSG, false);
-		WL_INFO(("AP mode link down !! \n"));
 		complete(&wl->iface_disable);
 		return 0;
 	}
@@ -8077,10 +8017,8 @@ static void wl_destroy_event_handler(struct wl_priv *wl)
 static void wl_term_iscan(struct wl_priv *wl)
 {
 	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
-	WL_TRACE(("In\n"));
 	if (wl->iscan_on && iscan->tsk) {
 		iscan->state = WL_ISCAN_STATE_IDLE;
-		WL_INFO(("SIGTERM\n"));
 		send_sig(SIGTERM, iscan->tsk, 1);
 		WL_DBG(("kthread_stop\n"));
 		kthread_stop(iscan->tsk);
@@ -8507,7 +8445,6 @@ static s32 wl_escan_handler(struct wl_priv *wl,
 	escan_result = (wl_escan_result_t *) data;
 #endif
 	if (status == WLC_E_STATUS_PARTIAL) {
-		WL_INFO(("WLC_E_STATUS_PARTIAL \n"));
 		escan_result = (wl_escan_result_t *) data;
 		if (!escan_result) {
 			WL_ERR(("Invalid escan result (NULL pointer)\n"));
@@ -8597,7 +8534,6 @@ static s32 wl_escan_handler(struct wl_priv *wl,
 				channel_band = (channel > CH_MAX_2G_CHANNEL) ?
 				WLC_BAND_5G : WLC_BAND_2G;
 
-
 				if ((wl->curr_band == WLC_BAND_5G) &&
 					(channel_band == WLC_BAND_2G)) {
 					/* Avoid sending the GO results in band conflict */
@@ -8712,23 +8648,17 @@ static s32 wl_escan_handler(struct wl_priv *wl,
 			status, wl->escan_info.cur_sync_id, escan_result->sync_id));
 #endif
 		if (wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL)) {
-			WL_INFO(("ACTION FRAME SCAN DONE\n"));
 			wl_clr_p2p_status(wl, SCANNING);
 			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
 			if (wl->afx_hdl->peer_chan == WL_INVALID)
 				complete(&wl->act_frm_scan);
 		} else if ((likely(wl->scan_request)) || (wl->sched_scan_running)) {
-			WL_INFO(("ESCAN COMPLETED\n"));
 #if defined(DUAL_ESCAN_RESULT_BUFFER)
 			wl->bss_list = (wl_scan_results_t *)
 				wl->escan_info.escan_buf[wl->escan_info.cur_sync_id%2];
 #else
 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
 #endif
-			if (wl->scan_request && wl->scan_request->dev != wl->p2p_net) {
-				WL_TRACE_HW4(("SCAN COMPLETED: scanned AP count=%d\n",
-					wl->bss_list->count));
-			}
 			wl_inform_bss(wl);
 			wl_notify_escan_complete(wl, ndev, false, false);
 		}
@@ -8745,23 +8675,17 @@ static s32 wl_escan_handler(struct wl_priv *wl,
 			status, wl->escan_info.cur_sync_id, escan_result->sync_id));
 #endif
 		if (wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL)) {
-			WL_INFO(("ACTION FRAME SCAN DONE\n"));
 			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
 			wl_clr_p2p_status(wl, SCANNING);
 			if (wl->afx_hdl->peer_chan == WL_INVALID)
 				complete(&wl->act_frm_scan);
 		} else if ((likely(wl->scan_request)) || (wl->sched_scan_running)) {
-			WL_INFO(("ESCAN ABORTED\n"));
 #if defined(DUAL_ESCAN_RESULT_BUFFER)
 			wl->bss_list = (wl_scan_results_t *)
 				wl->escan_info.escan_buf[(wl->escan_info.cur_sync_id+1)%2];
 #else
 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
 #endif
-			if (wl->scan_request && wl->scan_request->dev != wl->p2p_net) {
-				WL_TRACE_HW4(("SCAN ABORTED: scanned AP count=%d\n",
-					wl->bss_list->count));
-			}
 			wl_inform_bss(wl);
 			wl_notify_escan_complete(wl, ndev, true, false);
 		}
@@ -8791,7 +8715,6 @@ static s32 wl_escan_handler(struct wl_priv *wl,
 			status, wl->escan_info.cur_sync_id, escan_result->sync_id));
 #endif
 		if (wl_get_drv_status_all(wl, FINDING_COMMON_CHANNEL)) {
-			WL_INFO(("ACTION FRAME SCAN DONE\n"));
 			wl_clr_p2p_status(wl, SCANNING);
 			wl_clr_drv_status(wl, SCANNING, wl->afx_hdl->dev);
 			if (wl->afx_hdl->peer_chan == WL_INVALID)
@@ -8803,11 +8726,6 @@ static s32 wl_escan_handler(struct wl_priv *wl,
 #else
 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
 #endif
-			if (wl->scan_request && wl->scan_request->dev != wl->p2p_net) {
-				WL_TRACE_HW4(("SCAN ABORTED(UNEXPECTED): "
-					"scanned AP count=%d\n",
-					wl->bss_list->count));
-			}
 			wl_inform_bss(wl);
 			wl_notify_escan_complete(wl, ndev, true, false);
 		}
@@ -9076,8 +8994,6 @@ static s32 wl_cfg80211_attach_p2p(void)
 {
 	struct wl_priv *wl = wlcfg_drv_priv;
 
-	WL_TRACE(("Enter \n"));
-
 	if (wl_cfgp2p_register_ndev(wl) < 0) {
 		WL_ERR(("%s: P2P attach failed. \n", __func__));
 		return -ENODEV;
@@ -9112,7 +9028,6 @@ s32 wl_cfg80211_attach_post(struct net_device *ndev)
 {
 	struct wl_priv * wl = NULL;
 	s32 err = 0;
-	WL_TRACE(("In\n"));
 	if (unlikely(!ndev)) {
 		WL_ERR(("ndev is invaild\n"));
 		return -ENODEV;
@@ -9163,7 +9078,6 @@ s32 wl_cfg80211_attach(struct net_device *ndev, void *data)
 	s32 err = 0;
 	struct device *dev;
 
-	WL_TRACE(("In\n"));
 	if (!ndev) {
 		WL_ERR(("ndev is invaild\n"));
 		return -ENODEV;
@@ -9215,7 +9129,7 @@ s32 wl_cfg80211_attach(struct net_device *ndev, void *data)
 	err = wl_cfg80211_btcoex_init(wl);
 	if (err)
 		goto cfg80211_attach_out;
-#endif 
+#endif
 
 	wlcfg_drv_priv = wl;
 
@@ -9240,11 +9154,9 @@ void wl_cfg80211_detach(void *para)
 	(void)para;
 	wl = wlcfg_drv_priv;
 
-	WL_TRACE(("In\n"));
-
 #if defined(COEX_DHCP)
 	wl_cfg80211_btcoex_deinit(wl);
-#endif 
+#endif
 
 	wl_setup_rfkill(wl, FALSE);
 	if (wl->p2p_supported) {
@@ -9287,8 +9199,6 @@ static int wl_is_p2p_event(struct wl_event_q *e)
 	case WLC_E_ACTION_FRAME_COMPLETE:
 
 		if (e->emsg.ifidx != 0) {
-			WL_TRACE(("P2P Event on Virtual I/F (ifidx:%d) \n",
-			e->emsg.ifidx));
 			/* We are only bothered about the P2P events received
 			 * on primary interface. For rest of them return false
 			 * so that it is sent over the interface corresponding
@@ -9296,15 +9206,11 @@ static int wl_is_p2p_event(struct wl_event_q *e)
 			 */
 			return FALSE;
 		} else {
-			WL_TRACE(("P2P Event on Primary I/F (ifidx:%d)."
-				" Sent it to p2p0 \n", e->emsg.ifidx));
 			return TRUE;
 		}
 		break;
 
 	default:
-		WL_TRACE(("NON-P2P Event %d on ifidx (ifidx:%d) \n",
-			e->etype, e->emsg.ifidx));
 		return FALSE;
 	}
 }
@@ -9558,7 +9464,6 @@ static int wl_construct_reginfo(struct wl_priv *wl, s32 bw_cap)
 	list = (wl_uint32_list_t *)(void *) pbuf;
 	list->count = htod32(WL_NUMCHANSPECS);
 
-
 	err = wldev_iovar_getbuf_bsscfg(dev, "chanspecs", NULL,
 		0, pbuf, LOCAL_BUF_LEN, 0, &wl->ioctl_buf_sync);
 	if (err != 0) {
@@ -9763,7 +9668,6 @@ s32 wl_update_wiphybands(struct wl_priv *wl)
 	wiphy->bands[IEEE80211_BAND_2GHZ] = bands[IEEE80211_BAND_2GHZ];
 	wiphy->bands[IEEE80211_BAND_5GHZ] = bands[IEEE80211_BAND_5GHZ];
 
-
 	wiphy_apply_custom_regulatory(wiphy, &brcm_regdom);
 	end_bands:
 		if (rollback_lock)
@@ -9824,7 +9728,6 @@ static s32 __wl_cfg80211_down(struct wl_priv *wl)
 	for_each_ndev(wl, iter, next)
 		wl_set_drv_status(wl, SCAN_ABORTING, iter->ndev);
 
-
 	wl_term_iscan(wl);
 	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
 	if (wl->scan_request) {
@@ -9883,7 +9786,6 @@ s32 wl_cfg80211_up(void *para)
 		return BCME_VERSION;
 	}
 	ioctl_version = val;
-	WL_TRACE(("WLC_GET_VERSION=%d\n", ioctl_version));
 
 	mutex_lock(&wl->usr_sync);
 	dhd = (dhd_pub_t *)(wl->pub);
diff --git a/drivers/net/wireless/bcmdhd/wl_cfg80211.h b/drivers/net/wireless/bcmdhd/wl_cfg80211.h
index 7138d21..ca090fd 100644
--- a/drivers/net/wireless/bcmdhd/wl_cfg80211.h
+++ b/drivers/net/wireless/bcmdhd/wl_cfg80211.h
@@ -59,7 +59,7 @@ struct wl_ibss;
 #define WL_DBG_ERR	(1 << 0)
 
 /* 0 invalidates all debug messages.  default is 1 */
-#define WL_DBG_LEVEL 0xFF
+#define WL_DBG_LEVEL 0
 
 #ifdef CUSTOMER_HW4
 #define CFG80211_ERROR_TEXT		"CFG80211-INFO2) "
diff --git a/drivers/power/bat_manager.c b/drivers/power/bat_manager.c
index 6c56c01..1f343bc 100644
--- a/drivers/power/bat_manager.c
+++ b/drivers/power/bat_manager.c
@@ -499,16 +499,6 @@ static void battery_manager_work(struct work_struct *work)
 			(di->charge_status != prev_status))
 		power_supply_changed(&di->psy_bat);
 
-#if DEBUG_PRINT
-	dev_info(di->dev, "vcell = %d soc = %d  current = %d avg_current = %d "
-		"status = %d health = %d temp = %d "
-		"discharge status = %d, limit time : %ld, bootmode : %d\n",
-		di->bat_info.vcell, di->bat_info.soc, di->bat_info.fg_current,
-		di->bat_info.avg_current, di->charge_status,
-		di->bat_info.health, di->bat_info.temp,
-		di->discharge_status, di->chg_limit_time, di->pdata->bootmode);
-#endif
-
 	di->last_poll = alarm_get_elapsed_realtime();
 	ts = ktime_to_timespec(di->last_poll);
 
@@ -535,12 +525,12 @@ static int otg_handle_notification(struct notifier_block *nb,
 
 	switch (event) {
 	case USB_EVENT_VBUS_CHARGER:
-		pr_info("[BAT_MANAGER] Charger Connected\n");
+		pr_info("[Battery manager] Charger is connected\n");
 		di->is_low_batt_alarm = false;
 		wake_lock(&di->cable_wake_lock);
 		break;
 	case USB_EVENT_CHARGER_NONE:
-		pr_info("[BAT_MANAGER] Charger Disconnect\n");
+		pr_info("[Battery manager] Charger is disconnect\n");
 		di->bat_info.health = POWER_SUPPLY_HEALTH_GOOD;
 		wake_unlock(&di->cable_wake_lock);
 		break;
diff --git a/drivers/power/max17042_battery.c b/drivers/power/max17042_battery.c
index f46b359..1375fcd 100644
--- a/drivers/power/max17042_battery.c
+++ b/drivers/power/max17042_battery.c
@@ -32,8 +32,6 @@
 #include <linux/delay.h>
 #include <linux/mutex.h>
 
-#define DEBUG_PRINT 0
-
 #define LOW_BATT_COMP_RANGE_NUM	5
 #define LOW_BATT_COMP_LEVEL_NUM	2
 
@@ -191,10 +189,6 @@ static int max17042_get_vcell(struct i2c_client *client)
 
 	vcell = (data & 0xFFF) * 78125 / 1000000;
 	vcell += ((((data & 0xF000) >> 4) * 78125) / 1000000) << 4;
-#if DEBUG_PRINT
-	dev_info(&client->dev, "VCELL : %d, data : 0x%x\n",
-			vcell, data);
-#endif
 
 	return vcell * 1000;
 }
@@ -207,14 +201,8 @@ static int max17042_get_soc(struct i2c_client *client)
 
 	data = max17042_read_reg(client, MAX17042_RepSOC);
 	raw_soc = ((data >> 8) * 100) + ((data & 0xFF) * 100) / 256;
-
 	soc = min((raw_soc * 100) / 9800, 100);
 
-#if DEBUG_PRINT
-	dev_info(&client->dev, "SOC : %d, data : 0x%x\n",
-			soc, data);
-#endif
-
 	return soc;
 }
 
@@ -267,11 +255,6 @@ static int max17042_get_temperature(struct i2c_client *client)
 			temper = ((7 * temper) / 10 + 7) + 20;
 	}
 
-#if DEBUG_PRINT
-	dev_info(&client->dev, "TEMPERATURE : %d, data :0x%x\n",
-		temper, data);
-#endif
-
 	return temper;
 }
 
@@ -286,10 +269,6 @@ static int max17042_get_avg_current(struct i2c_client *client)
 		((((~data & 0xFFFF) + 1) * 15625) / 100000) * (-1) :
 		(data * 15625) / 100000;
 
-#if DEBUG_PRINT
-	dev_info(&client->dev, "AVG Current : %d, data :0x%x\n",
-		avg_current, data);
-#endif
 	return avg_current;
 }
 
@@ -303,10 +282,6 @@ static int max17042_get_current(struct i2c_client *client)
 	fg_current = (data & (0x1 << 15)) ?
 		((((~data & 0xFFFF) + 1) * 15625) / 100000) * (-1) :
 		(data * 15625) / 100000;
-#if DEBUG_PRINT
-	dev_info(&client->dev, "Current : %d, data :0x%x\n",
-		fg_current, data);
-#endif
 
 	return fg_current;
 }
@@ -432,7 +407,7 @@ static void max17042_set_battery_type(struct max17042_chip *chip)
 		chip->info.battery_type = SDI_BATTERY_TYPE;
 	}
 
-#if DEBUG_PRINT
+#if 0
 	pr_info("%s : DesignCAP(0x%04x), Battery type(%s)\n",
 			__func__, data,
 			chip->info.battery_type == SDI_BATTERY_TYPE ?
@@ -1034,38 +1009,18 @@ static void max17042_fullcharged_compensation(
 	struct max17042_chip *chip =
 		container_of(ptr, struct max17042_chip, callbacks);
 
-#if DEBUG_PRINT
-	dev_info(&chip->client->dev,
-			"%s: is_recharging(%d), pre_update(%d)\n",
-			__func__, is_recharging, pre_update);
-#endif
-
 	new_fullcap = max17042_read_reg(chip->client, MAX17402_FullCAP);
 
 	if (new_fullcap < 0)
 		new_fullcap = chip->info.capacity;
 
 	if (new_fullcap > (chip->info.capacity * 110 / 100)) {
-#if DEBUG_PRINT
-		dev_info(&chip->client->dev,
-			"%s: [Case 1] previous_fullcap = 0x%04x,"
-			" NewFullCap = 0x%04x\n",
-			__func__, chip->info.previous_fullcap, new_fullcap);
-#endif
-
 		new_fullcap = (chip->info.capacity * 110) / 100;
 		max17042_write_reg(chip->client,
 			MAX17042_RepCap, (u16)(new_fullcap));
 		max17042_write_reg(chip->client,
 			MAX17402_FullCAP, (u16)(new_fullcap));
 	} else if (new_fullcap < (chip->info.capacity * 50 / 100)) {
-#if DEBUG_PRINT
-		dev_info(&chip->client->dev,
-			"%s : [Case 5] previous_fullcap = 0x%04x,"
-			" NewFullCap = 0x%04x\n",
-			__func__, chip->info.previous_fullcap, new_fullcap);
-#endif
-
 		new_fullcap = (chip->info.capacity * 50) / 100;
 		max17042_write_reg(chip->client,
 			MAX17042_RepCap, (u16)(new_fullcap));
@@ -1073,38 +1028,18 @@ static void max17042_fullcharged_compensation(
 			MAX17402_FullCAP, (u16)(new_fullcap));
 	} else {
 		if (new_fullcap > (chip->info.previous_fullcap * 110 / 100)) {
-#if DEBUG_PRINT
-			dev_info(&chip->client->dev,
-				"%s : [Case 2] previous_fullcap = 0x%04x,"
-				" NewFullCap = 0x%04x\n", __func__,
-				chip->info.previous_fullcap, new_fullcap);
-#endif
-
 			new_fullcap = (chip->info.previous_fullcap * 110) / 100;
 			max17042_write_reg(chip->client,
 				MAX17042_RepCap, (u16)(new_fullcap));
 			max17042_write_reg(chip->client,
 				MAX17402_FullCAP, (u16)(new_fullcap));
 		} else if (new_fullcap < (chip->info.previous_fullcap*90/100)) {
-#if DEBUG_PRINT
-			dev_info(&chip->client->dev,
-				"%s : [Case 3] previous_fullcap = 0x%04x,"
-				" NewFullCap = 0x%04x\n", __func__,
-				chip->info.previous_fullcap, new_fullcap);
-#endif
-
 			new_fullcap = (chip->info.previous_fullcap * 90) / 100;
 			max17042_write_reg(chip->client,
 				MAX17042_RepCap, (u16)(new_fullcap));
 			max17042_write_reg(chip->client,
 				MAX17402_FullCAP, (u16)(new_fullcap));
 		} else {
-#if DEBUG_PRINT
-			dev_info(&chip->client->dev,
-				"%s : [Case 4] previous_fullcap = 0x%04x,"
-				" NewFullCap = 0x%04x\n", __func__,
-				chip->info.previous_fullcap, new_fullcap);
-#endif
 		}
 	}
 
@@ -1125,13 +1060,6 @@ static void max17042_fullcharged_compensation(
 		chip->info.previous_fullcap =
 			max17042_read_reg(chip->client, MAX17402_FullCAP);
 
-#if DEBUG_PRINT
-	dev_info(&chip->client->dev, "%s : (A) FullCap = 0x%04x, RemCap = 0x%04x\n",
-		 __func__,
-		max17042_read_reg(chip->client, MAX17402_FullCAP),
-		max17042_read_reg(chip->client, MAX17042_RepCap));
-#endif
-
 	max17042_periodic_read(chip->client);
 }
 
@@ -1149,26 +1077,12 @@ static void max17042_check_vf_fullcap_range(
 		new_vffullcap = chip->info.vfcapacity;
 
 	if (new_vffullcap > (chip->info.vfcapacity * 110 / 100)) {
-#if DEBUG_PRINT
-		dev_info(&chip->client->dev,
-			"%s : [Case 1] previous_vffullcap = 0x%04x,"
-			" NewVfFullCap = 0x%04x\n", __func__,
-			chip->info.previous_vffullcap, new_vffullcap);
-#endif
-
 		new_vffullcap = (chip->info.vfcapacity * 110) / 100;
 
 		max17042_write_reg(chip->client, MAX17042_DQACC,
 			(u16)(new_vffullcap / 4));
 		max17042_write_reg(chip->client, MAX17042_DPACC, (u16)0x3200);
 	} else if (new_vffullcap < (chip->info.vfcapacity * 50 / 100)) {
-#if DEBUG_PRINT
-		dev_info(&chip->client->dev,
-			"%s : [Case 5] previous_vffullcap = 0x%04x,"
-			" NewVfFullCap = 0x%04x\n", __func__,
-			chip->info.previous_vffullcap, new_vffullcap);
-#endif
-
 		new_vffullcap = (chip->info.vfcapacity * 50) / 100;
 
 		max17042_write_reg(chip->client, MAX17042_DQACC,
@@ -1176,13 +1090,6 @@ static void max17042_check_vf_fullcap_range(
 		max17042_write_reg(chip->client, MAX17042_DPACC, (u16)0x3200);
 	} else {
 		if (new_vffullcap > (chip->info.previous_vffullcap*110 / 100)) {
-#if DEBUG_PRINT
-			dev_info(&chip->client->dev,
-				"%s : [Case 2] previous_vffullcap = 0x%04x,"
-				" NewVfFullCap = 0x%04x\n", __func__,
-				chip->info.previous_vffullcap, new_vffullcap);
-#endif
-
 			new_vffullcap =
 				(chip->info.previous_vffullcap * 110) / 100;
 			max17042_write_reg(chip->client, MAX17042_DQACC,
@@ -1191,13 +1098,6 @@ static void max17042_check_vf_fullcap_range(
 				MAX17042_DPACC, (u16)0x3200);
 		} else if (new_vffullcap <
 				(chip->info.previous_vffullcap * 90 / 100)) {
-#if DEBUG_PRINT
-			dev_info(&chip->client->dev,
-				"%s : [Case 3] previous_vffullcap = 0x%04x,"
-				" NewVfFullCap = 0x%04x\n", __func__,
-				chip->info.previous_vffullcap, new_vffullcap);
-#endif
-
 			new_vffullcap = (chip->info.previous_vffullcap*90)/100;
 
 			max17042_write_reg(chip->client, MAX17042_DQACC,
@@ -1205,13 +1105,6 @@ static void max17042_check_vf_fullcap_range(
 			max17042_write_reg(chip->client,
 				MAX17042_DPACC, (u16)0x3200);
 		} else {
-#if DEBUG_PRINT
-			dev_info(&chip->client->dev,
-				"%s : [Case 4] previous_vffullcap = 0x%04x,"
-				" NewVfFullCap = 0x%04x\n", __func__,
-				chip->info.previous_vffullcap,
-					new_vffullcap);
-#endif
 			print_flag = 0;
 		}
 	}
@@ -1223,16 +1116,6 @@ static void max17042_check_vf_fullcap_range(
 	chip->info.previous_vffullcap =
 			max17042_read_reg(chip->client, MAX17042_FullCAP_Nom);
 
-#if DEBUG_PRINT
-	if (print_flag)
-		dev_info(&chip->client->dev,
-			"%s:VfFullCap(0x%04x), dQacc(0x%04x), dPacc(0x%04x)\n",
-			__func__,
-			max17042_read_reg(chip->client, MAX17042_FullCAP_Nom),
-			max17042_read_reg(chip->client, MAX17042_DQACC),
-			max17042_read_reg(chip->client, MAX17042_DPACC));
-#endif
-
 }
 
 static void max17042_update_remcap_to_fullcap(
@@ -1247,12 +1130,10 @@ static void max17042_update_remcap_to_fullcap(
 	max17042_write_reg(chip->client, MAX17402_FullCAP, (u16)remcap);
 	msleep(200);
 
-#if DEBUG_PRINT
 	dev_info(&chip->client->dev,
 		"Before FullCap : 0x%x, After Fullcap : 0x%x, SOC : %d\n",
 		fullcap, max17042_read_reg(chip->client, MAX17402_FullCAP),
 		max17042_get_soc(chip->client));
-#endif
 }
 
 static int max17042_get_value(struct max17042_fuelgauge_callbacks *ptr,
diff --git a/drivers/power/smb136_charger.c b/drivers/power/smb136_charger.c
index cf8c36a..89e7280 100644
--- a/drivers/power/smb136_charger.c
+++ b/drivers/power/smb136_charger.c
@@ -9,7 +9,6 @@
  * published by the Free Software Foundation.
  */
 
-
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
@@ -118,27 +117,6 @@ static int smb136_i2c_write(struct i2c_client *client, u8 reg, u8 data)
 	return ret;
 }
 
-/* commenting this function because we r not using it currently */
-#if 0
-static void smb136_test_read(struct smb136_chg_data *chg)
-{
-	u8 data = 0;
-	u32 addr = 0;
-
-	for (addr = 0; addr < 0x0c; addr++) {
-		smb136_i2c_read(chg->client, addr, &data);
-		dev_dbg(&chg->client->dev,
-			"SMB136 addr : 0x%02x data : 0x%02x\n",	addr, data);
-	}
-
-	for (addr = 0x31; addr < 0x3D; addr++) {
-		smb136_i2c_read(chg->client, addr, &data);
-		dev_dbg(&chg->client->dev,
-			"SMB136 addr : 0x%02x data : 0x%02x\n",	addr, data);
-	}
-}
-#endif
-
 static int smb136_read_status(struct smb_charger_callbacks *ptr)
 {
 	struct smb136_chg_data *chg = container_of(ptr,
@@ -189,51 +167,6 @@ static int smb136_read_status(struct smb_charger_callbacks *ptr)
 	return res;
 }
 
-/* commenting this function because we r not using it currently */
-#if 0
-static int smb136_get_charging_current(struct smb136_chg_data *chg)
-{
-	u8 data = 0;
-	int get_current = 0;
-
-	smb136_i2c_read(chg->client, SMB_ChargeCurrent, &data);
-	switch (data >> 5) {
-	case 0:
-		get_current = 500;
-		break;
-	case 1:
-		get_current = 650;
-		break;
-	case 2:
-		get_current = 750;
-		break;
-	case 3:
-		get_current = 850;
-		break;
-	case 4:
-		get_current = 950;
-		break;
-	case 5:
-		get_current = 1100;
-		break;
-	case 6:
-		get_current = 1300;
-		break;
-	case 7:
-		get_current = 1500;
-		break;
-	default:
-		get_current = 500;
-		break;
-	}
-
-	dev_info(&chg->client->dev, "%s: Get charging current as %dmA.\n",
-		__func__, get_current);
-
-	return get_current;
-}
-#endif
-
 static void smb136_set_charging_state(struct smb_charger_callbacks *ptr,
 		int cable_status)
 {
diff --git a/drivers/power/smb347_charger.c b/drivers/power/smb347_charger.c
index f5512b4..1b5614e 100644
--- a/drivers/power/smb347_charger.c
+++ b/drivers/power/smb347_charger.c
@@ -115,28 +115,6 @@ static int smb347_i2c_write(struct i2c_client *client, u8 reg, u8 data)
 	return ret;
 }
 
-/* commenting this func as we r not using it currently */
-#if 0
-static void smb347_test_read(struct smb347_chg_data *chg)
-{
-	u8 data = 0;
-	u32 addr = 0;
-	pr_info("%s\n", __func__);
-
-	for (addr = 0; addr <= 0x0E; addr++) {
-		smb347_i2c_read(chg->client, addr, &data);
-		dev_info(&chg->client->dev,
-			"smb347 addr : 0x%02x data : 0x%02x\n",	addr, data);
-	}
-
-	for (addr = 0x30; addr <= 0x3F; addr++) {
-		smb347_i2c_read(chg->client, addr, &data);
-		dev_info(&chg->client->dev,
-			"smb347 addr : 0x%02x data : 0x%02x\n",	addr, data);
-	}
-}
-#endif
-
 static void smb347_charger_init(struct smb347_chg_data *chg)
 {
 	/* Allow volatile writes to CONFIG registers */
diff --git a/drivers/regulator/twl-regulator.c b/drivers/regulator/twl-regulator.c
index 0896181..848f04c 100644
--- a/drivers/regulator/twl-regulator.c
+++ b/drivers/regulator/twl-regulator.c
@@ -18,7 +18,6 @@
 #include <linux/regulator/machine.h>
 #include <linux/i2c/twl.h>
 
-
 /*
  * The TWL4030/TW5030/TPS659x0/TWL6030 family chips include power management, a
  * USB OTG transceiver, an RTC, ADC, PWM, and lots more.  Some versions
@@ -61,7 +60,6 @@ struct twlreg_info {
 	unsigned long		features;
 };
 
-
 /* LDO control registers ... offset is from the base of its register bank.
  * The first three registers of all power resource banks help hardware to
  * manage the various resource groups.
@@ -497,7 +495,6 @@ static int twl6030reg_suspend_disable(struct regulator_dev *rdev)
 #define IS_UNSUP(x)	(UNSUP_MASK & (x))
 #define LDO_MV(x)	(~UNSUP_MASK & (x))
 
-
 static const u16 VAUX1_VSEL_table[] = {
 	UNSUP(1500), UNSUP(1800), 2500, 2800,
 	3000, 3000, 3000, 3000,
@@ -1372,12 +1369,12 @@ static u8 twl_get_smps_mult(int id)
 
 static int __devinit twlreg_probe(struct platform_device *pdev)
 {
-	int				i;
-	struct twlreg_info		*info;
-	struct regulator_init_data	*initdata;
+	struct twlreg_info				*info;
+	struct regulator_init_data		*initdata;
 	struct regulation_constraints	*c;
-	struct regulator_dev		*rdev;
-	int ret = 0;
+	struct regulator_dev			*rdev;
+	int	i=0;
+	int ret=0;
 
 	for (i = 0, info = NULL; i < ARRAY_SIZE(twl_regs); i++) {
 		if (twl_regs[i].desc.id != pdev->id)
diff --git a/drivers/rtc/rtc-twl.c b/drivers/rtc/rtc-twl.c
index b3ca81b..7e8b0b4 100644
--- a/drivers/rtc/rtc-twl.c
+++ b/drivers/rtc/rtc-twl.c
@@ -30,7 +30,6 @@
 
 #include <linux/i2c/twl.h>
 
-
 /*
  * RTC block register offsets (use TWL_MODULE_RTC)
  */
@@ -128,7 +127,6 @@ static const u8 twl6030_rtc_reg_map[] = {
 #define BIT_RTC_INTERRUPTS_REG_IT_TIMER_M        0x04
 #define BIT_RTC_INTERRUPTS_REG_IT_ALARM_M        0x08
 
-
 /* REG_SECONDS_REG through REG_YEARS_REG is how many registers? */
 #define ALL_TIME_REGS		6
 
@@ -390,7 +388,6 @@ static int twl_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 			alm->time.tm_min,
 			alm->time.tm_sec);
 
-
 	/* update all the alarm registers in one shot */
 	ret = twl_i2c_write(TWL_MODULE_RTC, alarm_data,
 		(rtc_reg_map[REG_ALARM_SECONDS_REG]), ALL_TIME_REGS);
@@ -569,6 +566,11 @@ static int __devinit twl_rtc_probe(struct platform_device *pdev)
 			goto out1;
 	}
 
+	/* ensure interrupts are disabled, bootloaders can be strange */
+	ret = twl_rtc_write_u8(0, REG_RTC_INTERRUPTS_REG);
+	if (ret < 0)
+		dev_warn(&pdev->dev, "unable to disable interrupt\n");
+
 	/* init cached IRQ enable bits */
 	ret = twl_rtc_read_u8(&rtc_irq_bits, REG_RTC_INTERRUPTS_REG);
 	if (ret < 0)
diff --git a/drivers/sensors/accelerometer/yas_acc_kernel_driver.c b/drivers/sensors/accelerometer/yas_acc_kernel_driver.c
index 4ea984d..69b0142 100644
--- a/drivers/sensors/accelerometer/yas_acc_kernel_driver.c
+++ b/drivers/sensors/accelerometer/yas_acc_kernel_driver.c
@@ -210,7 +210,6 @@ static int read_accel_raw_xyz(struct yas_vector *acc)
 	return 0;
 }
 
-
 static int accel_open_calibration(void)
 {
 	struct file *cal_filp = NULL;
@@ -225,7 +224,6 @@ static int accel_open_calibration(void)
 		S_IRUGO | S_IWUSR | S_IWGRP);
 
 	if (IS_ERR(cal_filp)) {
-		pr_err("%s: Can't open calibration file\n", __func__);
 		set_fs(old_fs);
 		err = PTR_ERR(cal_filp);
 		return err;
@@ -259,8 +257,6 @@ static int accel_open_calibration(void)
 	return err;
 }
 
-
-
 static int accel_do_calibrate(int enable)
 {
 	struct file *cal_filp;
@@ -320,7 +316,6 @@ static int accel_do_calibrate(int enable)
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
 
-
 	cal_filp = filp_open(data->acc_pdata->cal_path,
 			O_CREAT | O_TRUNC | O_WRONLY,
 			S_IRUGO | S_IWUSR | S_IWGRP);
@@ -858,12 +853,6 @@ static int yas_acc_measure(struct yas_acc_driver *driver,
 	if (err != YAS_NO_ERROR)
 		return err;
 
-#if 0
-	pr_info("data(%10d %10d %10d) raw(%5d %5d %5d)\n",
-	       accel->xyz.v[0], accel->xyz.v[1], accel->xyz.v[2],
-	       accel->raw.v[0], accel->raw.v[1], accel->raw.v[2]);
-#endif
-
 	return err;
 }
 
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 2cdf49a..9dcf09e 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -21,7 +21,6 @@ menuconfig STAGING
 
 	  If in doubt, say N here.
 
-
 if STAGING
 
 source "drivers/staging/tty/Kconfig"
@@ -80,8 +79,6 @@ source "drivers/staging/line6/Kconfig"
 
 source "drivers/gpu/drm/vmwgfx/Kconfig"
 
-source "drivers/gpu/drm/nouveau/Kconfig"
-
 source "drivers/staging/octeon/Kconfig"
 
 source "drivers/staging/serqt_usb2/Kconfig"
diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index b97a64e..9617788 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -507,9 +507,6 @@ static void binder_set_nice(long nice)
 		return;
 	}
 	min_nice = 20 - current->signal->rlim[RLIMIT_NICE].rlim_cur;
-	binder_debug(BINDER_DEBUG_PRIORITY_CAP,
-		     "binder: %d: nice value %ld not allowed use "
-		     "%ld instead\n", current->pid, nice, min_nice);
 	set_user_nice(current, min_nice);
 	if (min_nice < 20)
 		return;
@@ -539,10 +536,6 @@ static void binder_insert_free_buffer(struct binder_proc *proc,
 
 	new_buffer_size = binder_buffer_size(proc, new_buffer);
 
-	binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-		     "binder: %d: add free buffer, size %zd, "
-		     "at %p\n", proc->pid, new_buffer_size, new_buffer);
-
 	while (*p) {
 		parent = *p;
 		buffer = rb_entry(parent, struct binder_buffer, rb_node);
@@ -618,10 +611,6 @@ static int binder_update_page_range(struct binder_proc *proc, int allocate,
 	struct page **page;
 	struct mm_struct *mm;
 
-	binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-		     "binder: %d: %s pages %p-%p\n", proc->pid,
-		     allocate ? "allocate" : "free", start, end);
-
 	if (end <= start)
 		return 0;
 
@@ -644,8 +633,6 @@ static int binder_update_page_range(struct binder_proc *proc, int allocate,
 		goto free_range;
 
 	if (vma == NULL) {
-		printk(KERN_ERR "binder: %d: binder_alloc_buf failed to "
-		       "map pages in userspace, no vma\n", proc->pid);
 		goto err_no_vma;
 	}
 
@@ -666,18 +653,12 @@ static int binder_update_page_range(struct binder_proc *proc, int allocate,
 		page_array_ptr = page;
 		ret = map_vm_area(&tmp_area, PAGE_KERNEL, &page_array_ptr);
 		if (ret) {
-			printk(KERN_ERR "binder: %d: binder_alloc_buf failed "
-			       "to map page at %p in kernel\n",
-			       proc->pid, page_addr);
 			goto err_map_kernel_failed;
 		}
 		user_page_addr =
 			(uintptr_t)page_addr + proc->user_buffer_offset;
 		ret = vm_insert_page(vma, user_page_addr, page[0]);
 		if (ret) {
-			printk(KERN_ERR "binder: %d: binder_alloc_buf failed "
-			       "to map page at %lx in userspace\n",
-			       proc->pid, user_page_addr);
 			goto err_vm_insert_page_failed;
 		}
 		/* vm_insert_page does not seem to increment the refcount */
@@ -724,8 +705,6 @@ static struct binder_buffer *binder_alloc_buf(struct binder_proc *proc,
 	size_t size;
 
 	if (proc->vma == NULL) {
-		printk(KERN_ERR "binder: %d: binder_alloc_buf, no vma\n",
-		       proc->pid);
 		return NULL;
 	}
 
@@ -740,9 +719,6 @@ static struct binder_buffer *binder_alloc_buf(struct binder_proc *proc,
 
 	if (is_async &&
 	    proc->free_async_space < size + sizeof(struct binder_buffer)) {
-		binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-			     "binder: %d: binder_alloc_buf size %zd"
-			     "failed, no async space left\n", proc->pid, size);
 		return NULL;
 	}
 
@@ -762,8 +738,6 @@ static struct binder_buffer *binder_alloc_buf(struct binder_proc *proc,
 		}
 	}
 	if (best_fit == NULL) {
-		printk(KERN_ERR "binder: %d: binder_alloc_buf size %zd failed, "
-		       "no address space\n", proc->pid, size);
 		return NULL;
 	}
 	if (n == NULL) {
@@ -771,10 +745,6 @@ static struct binder_buffer *binder_alloc_buf(struct binder_proc *proc,
 		buffer_size = binder_buffer_size(proc, buffer);
 	}
 
-	binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-		     "binder: %d: binder_alloc_buf size %zd got buff"
-		     "er %p size %zd\n", proc->pid, size, buffer, buffer_size);
-
 	has_page_addr =
 		(void *)(((uintptr_t)buffer->data + buffer_size) & PAGE_MASK);
 	if (n == NULL) {
@@ -800,18 +770,11 @@ static struct binder_buffer *binder_alloc_buf(struct binder_proc *proc,
 		new_buffer->free = 1;
 		binder_insert_free_buffer(proc, new_buffer);
 	}
-	binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-		     "binder: %d: binder_alloc_buf size %zd got "
-		     "%p\n", proc->pid, size, buffer);
 	buffer->data_size = data_size;
 	buffer->offsets_size = offsets_size;
 	buffer->async_transaction = is_async;
 	if (is_async) {
 		proc->free_async_space -= size + sizeof(struct binder_buffer);
-		binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,
-			     "binder: %d: binder_alloc_buf size %zd "
-			     "async free %zd\n", proc->pid, size,
-			     proc->free_async_space);
 	}
 
 	return buffer;
@@ -841,9 +804,6 @@ static void binder_delete_free_buffer(struct binder_proc *proc,
 		free_page_start = 0;
 		if (buffer_end_page(prev) == buffer_end_page(buffer))
 			free_page_end = 0;
-		binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-			     "binder: %d: merge free, buffer %p "
-			     "share page with %p\n", proc->pid, buffer, prev);
 	}
 
 	if (!list_is_last(&buffer->entry, &proc->buffers)) {
@@ -854,19 +814,10 @@ static void binder_delete_free_buffer(struct binder_proc *proc,
 			if (buffer_start_page(next) ==
 			    buffer_start_page(buffer))
 				free_page_start = 0;
-			binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-				     "binder: %d: merge free, buffer"
-				     " %p share page with %p\n", proc->pid,
-				     buffer, prev);
 		}
 	}
 	list_del(&buffer->entry);
 	if (free_page_start || free_page_end) {
-		binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-			     "binder: %d: merge free, buffer %p do "
-			     "not share page%s%s with with %p or %p\n",
-			     proc->pid, buffer, free_page_start ? "" : " end",
-			     free_page_end ? "" : " start", prev, next);
 		binder_update_page_range(proc, 0, free_page_start ?
 			buffer_start_page(buffer) : buffer_end_page(buffer),
 			(free_page_end ? buffer_end_page(buffer) :
@@ -884,10 +835,6 @@ static void binder_free_buf(struct binder_proc *proc,
 	size = ALIGN(buffer->data_size, sizeof(void *)) +
 		ALIGN(buffer->offsets_size, sizeof(void *));
 
-	binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-		     "binder: %d: binder_free_buf %p size %zd buffer"
-		     "_size %zd\n", proc->pid, buffer, size, buffer_size);
-
 	BUG_ON(buffer->free);
 	BUG_ON(size > buffer_size);
 	BUG_ON(buffer->transaction != NULL);
@@ -896,11 +843,6 @@ static void binder_free_buf(struct binder_proc *proc,
 
 	if (buffer->async_transaction) {
 		proc->free_async_space += size + sizeof(struct binder_buffer);
-
-		binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,
-			     "binder: %d: binder_free_buf size %zd "
-			     "async free %zd\n", proc->pid, size,
-			     proc->free_async_space);
 	}
 
 	binder_update_page_range(proc, 0,
@@ -981,10 +923,6 @@ static struct binder_node *binder_new_node(struct binder_proc *proc,
 	node->work.type = BINDER_WORK_NODE;
 	INIT_LIST_HEAD(&node->work.entry);
 	INIT_LIST_HEAD(&node->async_todo);
-	binder_debug(BINDER_DEBUG_INTERNAL_REFS,
-		     "binder: %d:%d node %d u%p c%p created\n",
-		     proc->pid, current->pid, node->debug_id,
-		     node->ptr, node->cookie);
 	return node;
 }
 
@@ -997,8 +935,6 @@ static int binder_inc_node(struct binder_node *node, int strong, int internal,
 			    node->internal_strong_refs == 0 &&
 			    !(node == binder_context_mgr_node &&
 			    node->has_strong_ref)) {
-				printk(KERN_ERR "binder: invalid inc strong "
-					"node for %d\n", node->debug_id);
 				return -EINVAL;
 			}
 			node->internal_strong_refs++;
@@ -1013,8 +949,6 @@ static int binder_inc_node(struct binder_node *node, int strong, int internal,
 			node->local_weak_refs++;
 		if (!node->has_weak_ref && list_empty(&node->work.entry)) {
 			if (target_list == NULL) {
-				printk(KERN_ERR "binder: invalid inc weak node "
-					"for %d\n", node->debug_id);
 				return -EINVAL;
 			}
 			list_add_tail(&node->work.entry, target_list);
@@ -1049,14 +983,8 @@ static int binder_dec_node(struct binder_node *node, int strong, int internal)
 			list_del_init(&node->work.entry);
 			if (node->proc) {
 				rb_erase(&node->rb_node, &node->proc->nodes);
-				binder_debug(BINDER_DEBUG_INTERNAL_REFS,
-					     "binder: refless node %d deleted\n",
-					     node->debug_id);
 			} else {
 				hlist_del(&node->dead_node);
-				binder_debug(BINDER_DEBUG_INTERNAL_REFS,
-					     "binder: dead node %d deleted\n",
-					     node->debug_id);
 			}
 			kfree(node);
 			binder_stats_deleted(BINDER_STAT_NODE);
@@ -1066,7 +994,6 @@ static int binder_dec_node(struct binder_node *node, int strong, int internal)
 	return 0;
 }
 
-
 static struct binder_ref *binder_get_ref(struct binder_proc *proc,
 					 uint32_t desc)
 {
@@ -1139,26 +1066,12 @@ static struct binder_ref *binder_get_ref_for_node(struct binder_proc *proc,
 	rb_insert_color(&new_ref->rb_node_desc, &proc->refs_by_desc);
 	if (node) {
 		hlist_add_head(&new_ref->node_entry, &node->refs);
-
-		binder_debug(BINDER_DEBUG_INTERNAL_REFS,
-			     "binder: %d new ref %d desc %d for "
-			     "node %d\n", proc->pid, new_ref->debug_id,
-			     new_ref->desc, node->debug_id);
-	} else {
-		binder_debug(BINDER_DEBUG_INTERNAL_REFS,
-			     "binder: %d new ref %d desc %d for "
-			     "dead node\n", proc->pid, new_ref->debug_id,
-			      new_ref->desc);
 	}
 	return new_ref;
 }
 
 static void binder_delete_ref(struct binder_ref *ref)
 {
-	binder_debug(BINDER_DEBUG_INTERNAL_REFS,
-		     "binder: %d delete ref %d desc %d for "
-		     "node %d\n", ref->proc->pid, ref->debug_id,
-		     ref->desc, ref->node->debug_id);
 
 	rb_erase(&ref->rb_node_desc, &ref->proc->refs_by_desc);
 	rb_erase(&ref->rb_node_node, &ref->proc->refs_by_node);
@@ -1167,10 +1080,6 @@ static void binder_delete_ref(struct binder_ref *ref)
 	hlist_del(&ref->node_entry);
 	binder_dec_node(ref->node, 0, 1);
 	if (ref->death) {
-		binder_debug(BINDER_DEBUG_DEAD_BINDER,
-			     "binder: %d delete ref %d desc %d "
-			     "has death notification\n", ref->proc->pid,
-			     ref->debug_id, ref->desc);
 		list_del(&ref->death->work.entry);
 		kfree(ref->death);
 		binder_stats_deleted(BINDER_STAT_DEATH);
@@ -1201,7 +1110,6 @@ static int binder_inc_ref(struct binder_ref *ref, int strong,
 	return 0;
 }
 
-
 static int binder_dec_ref(struct binder_ref *ref, int strong)
 {
 	if (strong) {
@@ -1266,42 +1174,18 @@ static void binder_send_failed_reply(struct binder_transaction *t,
 				target_thread->return_error = BR_OK;
 			}
 			if (target_thread->return_error == BR_OK) {
-				binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
-					     "binder: send failed reply for "
-					     "transaction %d to %d:%d\n",
-					      t->debug_id, target_thread->proc->pid,
-					      target_thread->pid);
-
 				binder_pop_transaction(target_thread, t);
 				target_thread->return_error = error_code;
 				wake_up_interruptible(&target_thread->wait);
-			} else {
-				printk(KERN_ERR "binder: reply failed, target "
-					"thread, %d:%d, has error code %d "
-					"already\n", target_thread->proc->pid,
-					target_thread->pid,
-					target_thread->return_error);
 			}
 			return;
 		} else {
 			struct binder_transaction *next = t->from_parent;
-
-			binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
-				     "binder: send failed reply "
-				     "for transaction %d, target dead\n",
-				     t->debug_id);
-
 			binder_pop_transaction(target_thread, t);
 			if (next == NULL) {
-				binder_debug(BINDER_DEBUG_DEAD_BINDER,
-					     "binder: reply failed,"
-					     " no target thread at root\n");
 				return;
 			}
 			t = next;
-			binder_debug(BINDER_DEBUG_DEAD_BINDER,
-				     "binder: reply failed, no target "
-				     "thread -- retry %d\n", t->debug_id);
 		}
 	}
 }
@@ -1311,12 +1195,6 @@ static void binder_transaction_buffer_release(struct binder_proc *proc,
 					      size_t *failed_at)
 {
 	size_t *offp, *off_end;
-	int debug_id = buffer->debug_id;
-
-	binder_debug(BINDER_DEBUG_TRANSACTION,
-		     "binder: %d buffer release %d, size %zd-%zd, failed at %p\n",
-		     proc->pid, buffer->debug_id,
-		     buffer->data_size, buffer->offsets_size, failed_at);
 
 	if (buffer->target_node)
 		binder_dec_node(buffer->target_node, 1, 0);
@@ -1331,9 +1209,6 @@ static void binder_transaction_buffer_release(struct binder_proc *proc,
 		if (*offp > buffer->data_size - sizeof(*fp) ||
 		    buffer->data_size < sizeof(*fp) ||
 		    !IS_ALIGNED(*offp, sizeof(void *))) {
-			printk(KERN_ERR "binder: transaction release %d bad"
-					"offset %zd, size %zd\n", debug_id,
-					*offp, buffer->data_size);
 			continue;
 		}
 		fp = (struct flat_binder_object *)(buffer->data + *offp);
@@ -1342,40 +1217,25 @@ static void binder_transaction_buffer_release(struct binder_proc *proc,
 		case BINDER_TYPE_WEAK_BINDER: {
 			struct binder_node *node = binder_get_node(proc, fp->binder);
 			if (node == NULL) {
-				printk(KERN_ERR "binder: transaction release %d"
-				       " bad node %p\n", debug_id, fp->binder);
 				break;
 			}
-			binder_debug(BINDER_DEBUG_TRANSACTION,
-				     "        node %d u%p\n",
-				     node->debug_id, node->ptr);
 			binder_dec_node(node, fp->type == BINDER_TYPE_BINDER, 0);
 		} break;
 		case BINDER_TYPE_HANDLE:
 		case BINDER_TYPE_WEAK_HANDLE: {
 			struct binder_ref *ref = binder_get_ref(proc, fp->handle);
 			if (ref == NULL) {
-				printk(KERN_ERR "binder: transaction release %d"
-				       " bad handle %ld\n", debug_id,
-				       fp->handle);
 				break;
 			}
-			binder_debug(BINDER_DEBUG_TRANSACTION,
-				     "        ref %d desc %d (node %d)\n",
-				     ref->debug_id, ref->desc, ref->node->debug_id);
 			binder_dec_ref(ref, fp->type == BINDER_TYPE_HANDLE);
 		} break;
 
 		case BINDER_TYPE_FD:
-			binder_debug(BINDER_DEBUG_TRANSACTION,
-				     "        fd %ld\n", fp->handle);
 			if (failed_at)
 				task_close_fd(proc, fp->handle);
 			break;
 
 		default:
-			printk(KERN_ERR "binder: transaction release %d bad "
-			       "object type %lx\n", debug_id, fp->type);
 			break;
 		}
 	}
@@ -1522,23 +1382,6 @@ static void binder_transaction(struct binder_proc *proc,
 	t->debug_id = ++binder_last_id;
 	e->debug_id = t->debug_id;
 
-	if (reply)
-		binder_debug(BINDER_DEBUG_TRANSACTION,
-			     "binder: %d:%d BC_REPLY %d -> %d:%d, "
-			     "data %p-%p size %zd-%zd\n",
-			     proc->pid, thread->pid, t->debug_id,
-			     target_proc->pid, target_thread->pid,
-			     tr->data.ptr.buffer, tr->data.ptr.offsets,
-			     tr->data_size, tr->offsets_size);
-	else
-		binder_debug(BINDER_DEBUG_TRANSACTION,
-			     "binder: %d:%d BC_TRANSACTION %d -> "
-			     "%d - node %d, data %p-%p size %zd-%zd\n",
-			     proc->pid, thread->pid, t->debug_id,
-			     target_proc->pid, target_node->debug_id,
-			     tr->data.ptr.buffer, tr->data.ptr.offsets,
-			     tr->data_size, tr->offsets_size);
-
 	if (!reply && !(tr->flags & TF_ONE_WAY))
 		t->from = thread;
 	else
@@ -1631,10 +1474,6 @@ static void binder_transaction(struct binder_proc *proc,
 			binder_inc_ref(ref, fp->type == BINDER_TYPE_HANDLE,
 				       &thread->todo);
 
-			binder_debug(BINDER_DEBUG_TRANSACTION,
-				     "        node %d u%p -> ref %d desc %d\n",
-				     node->debug_id, node->ptr, ref->debug_id,
-				     ref->desc);
 		} break;
 		case BINDER_TYPE_HANDLE:
 		case BINDER_TYPE_WEAK_HANDLE: {
@@ -1655,10 +1494,6 @@ static void binder_transaction(struct binder_proc *proc,
 				fp->binder = ref->node->ptr;
 				fp->cookie = ref->node->cookie;
 				binder_inc_node(ref->node, fp->type == BINDER_TYPE_BINDER, 0, NULL);
-				binder_debug(BINDER_DEBUG_TRANSACTION,
-					     "        ref %d desc %d -> node %d u%p\n",
-					     ref->debug_id, ref->desc, ref->node->debug_id,
-					     ref->node->ptr);
 			} else {
 				struct binder_ref *new_ref;
 				new_ref = binder_get_ref_for_node(target_proc, ref->node);
@@ -1668,10 +1503,6 @@ static void binder_transaction(struct binder_proc *proc,
 				}
 				fp->handle = new_ref->desc;
 				binder_inc_ref(new_ref, fp->type == BINDER_TYPE_HANDLE, NULL);
-				binder_debug(BINDER_DEBUG_TRANSACTION,
-					     "        ref %d desc %d -> ref %d desc %d (node %d)\n",
-					     ref->debug_id, ref->desc, new_ref->debug_id,
-					     new_ref->desc, ref->node->debug_id);
 			}
 		} break;
 
@@ -1707,9 +1538,6 @@ static void binder_transaction(struct binder_proc *proc,
 				goto err_get_unused_fd_failed;
 			}
 			task_fd_install(target_proc, target_fd, file);
-			binder_debug(BINDER_DEBUG_TRANSACTION,
-				     "        fd %ld -> %d\n", fp->handle, target_fd);
-			/* TODO: fput? */
 			fp->handle = target_fd;
 		} break;
 
@@ -1770,10 +1598,6 @@ err_empty_call_stack:
 err_dead_binder:
 err_invalid_target_handle:
 err_no_context_mgr_node:
-	binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
-		     "binder: %d:%d transaction failed %d, size %zd-%zd\n",
-		     proc->pid, thread->pid, return_error,
-		     tr->data_size, tr->offsets_size);
 
 	{
 		struct binder_transaction_log_entry *fe;
@@ -1856,10 +1680,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 				binder_dec_ref(ref, 0);
 				break;
 			}
-			binder_debug(BINDER_DEBUG_USER_REFS,
-				     "binder: %d:%d %s ref %d desc %d s %d w %d for node %d\n",
-				     proc->pid, thread->pid, debug_string, ref->debug_id,
-				     ref->desc, ref->strong, ref->weak, ref->node->debug_id);
 			break;
 		}
 		case BC_INCREFS_DONE:
@@ -1917,18 +1737,11 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 				node->pending_weak_ref = 0;
 			}
 			binder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0);
-			binder_debug(BINDER_DEBUG_USER_REFS,
-				     "binder: %d:%d %s node %d ls %d lw %d\n",
-				     proc->pid, thread->pid,
-				     cmd == BC_INCREFS_DONE ? "BC_INCREFS_DONE" : "BC_ACQUIRE_DONE",
-				     node->debug_id, node->local_strong_refs, node->local_weak_refs);
 			break;
 		}
 		case BC_ATTEMPT_ACQUIRE:
-			printk(KERN_ERR "binder: BC_ATTEMPT_ACQUIRE not supported\n");
 			return -EINVAL;
 		case BC_ACQUIRE_RESULT:
-			printk(KERN_ERR "binder: BC_ACQUIRE_RESULT not supported\n");
 			return -EINVAL;
 
 		case BC_FREE_BUFFER: {
@@ -1953,10 +1766,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 					proc->pid, thread->pid, data_ptr);
 				break;
 			}
-			binder_debug(BINDER_DEBUG_FREE_BUFFER,
-				     "binder: %d:%d BC_FREE_BUFFER u%p found buffer %d for %s transaction\n",
-				     proc->pid, thread->pid, data_ptr, buffer->debug_id,
-				     buffer->transaction ? "active" : "finished");
 
 			if (buffer->transaction) {
 				buffer->transaction->buffer = NULL;
@@ -1986,9 +1795,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 		}
 
 		case BC_REGISTER_LOOPER:
-			binder_debug(BINDER_DEBUG_THREADS,
-				     "binder: %d:%d BC_REGISTER_LOOPER\n",
-				     proc->pid, thread->pid);
 			if (thread->looper & BINDER_LOOPER_STATE_ENTERED) {
 				thread->looper |= BINDER_LOOPER_STATE_INVALID;
 				binder_user_error("binder: %d:%d ERROR:"
@@ -2008,9 +1814,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 			thread->looper |= BINDER_LOOPER_STATE_REGISTERED;
 			break;
 		case BC_ENTER_LOOPER:
-			binder_debug(BINDER_DEBUG_THREADS,
-				     "binder: %d:%d BC_ENTER_LOOPER\n",
-				     proc->pid, thread->pid);
 			if (thread->looper & BINDER_LOOPER_STATE_REGISTERED) {
 				thread->looper |= BINDER_LOOPER_STATE_INVALID;
 				binder_user_error("binder: %d:%d ERROR:"
@@ -2021,9 +1824,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 			thread->looper |= BINDER_LOOPER_STATE_ENTERED;
 			break;
 		case BC_EXIT_LOOPER:
-			binder_debug(BINDER_DEBUG_THREADS,
-				     "binder: %d:%d BC_EXIT_LOOPER\n",
-				     proc->pid, thread->pid);
 			thread->looper |= BINDER_LOOPER_STATE_EXITED;
 			break;
 
@@ -2052,15 +1852,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 				break;
 			}
 
-			binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,
-				     "binder: %d:%d %s %p ref %d desc %d s %d w %d for node %d\n",
-				     proc->pid, thread->pid,
-				     cmd == BC_REQUEST_DEATH_NOTIFICATION ?
-				     "BC_REQUEST_DEATH_NOTIFICATION" :
-				     "BC_CLEAR_DEATH_NOTIFICATION",
-				     cookie, ref->debug_id, ref->desc,
-				     ref->strong, ref->weak, ref->node->debug_id);
-
 			if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
 				if (ref->death) {
 					binder_user_error("binder: %d:%"
@@ -2073,10 +1864,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 				death = kzalloc(sizeof(*death), GFP_KERNEL);
 				if (death == NULL) {
 					thread->return_error = BR_ERROR;
-					binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
-						     "binder: %d:%d "
-						     "BC_REQUEST_DEATH_NOTIFICATION failed\n",
-						     proc->pid, thread->pid);
 					break;
 				}
 				binder_stats_created(BINDER_STAT_DEATH);
@@ -2142,9 +1929,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 					break;
 				}
 			}
-			binder_debug(BINDER_DEBUG_DEAD_BINDER,
-				     "binder: %d:%d BC_DEAD_BINDER_DONE %p found %p\n",
-				     proc->pid, thread->pid, cookie, death);
 			if (death == NULL) {
 				binder_user_error("binder: %d:%d BC_DEAD"
 					"_BINDER_DONE %p not found\n",
@@ -2165,8 +1949,6 @@ int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
 		} break;
 
 		default:
-			printk(KERN_ERR "binder: %d:%d unknown command %d\n",
-			       proc->pid, thread->pid, cmd);
 			return -EINVAL;
 		}
 		*consumed = ptr - buffer;
@@ -2234,7 +2016,6 @@ retry:
 		goto done;
 	}
 
-
 	thread->looper |= BINDER_LOOPER_STATE_WAITING;
 	if (wait_for_proc_work)
 		proc->ready_threads++;
@@ -2300,9 +2081,6 @@ retry:
 			ptr += sizeof(uint32_t);
 
 			binder_stat_br(proc, thread, cmd);
-			binder_debug(BINDER_DEBUG_TRANSACTION_COMPLETE,
-				     "binder: %d:%d BR_TRANSACTION_COMPLETE\n",
-				     proc->pid, thread->pid);
 
 			list_del(&w->entry);
 			kfree(w);
@@ -2347,24 +2125,12 @@ retry:
 				ptr += sizeof(void *);
 
 				binder_stat_br(proc, thread, cmd);
-				binder_debug(BINDER_DEBUG_USER_REFS,
-					     "binder: %d:%d %s %d u%p c%p\n",
-					     proc->pid, thread->pid, cmd_name, node->debug_id, node->ptr, node->cookie);
 			} else {
 				list_del_init(&w->entry);
 				if (!weak && !strong) {
-					binder_debug(BINDER_DEBUG_INTERNAL_REFS,
-						     "binder: %d:%d node %d u%p c%p deleted\n",
-						     proc->pid, thread->pid, node->debug_id,
-						     node->ptr, node->cookie);
 					rb_erase(&node->rb_node, &proc->nodes);
 					kfree(node);
 					binder_stats_deleted(BINDER_STAT_NODE);
-				} else {
-					binder_debug(BINDER_DEBUG_INTERNAL_REFS,
-						     "binder: %d:%d node %d u%p c%p state unchanged\n",
-						     proc->pid, thread->pid, node->debug_id, node->ptr,
-						     node->cookie);
 				}
 			}
 		} break;
@@ -2385,13 +2151,6 @@ retry:
 			if (put_user(death->cookie, (void * __user *)ptr))
 				return -EFAULT;
 			ptr += sizeof(void *);
-			binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,
-				     "binder: %d:%d %s %p\n",
-				      proc->pid, thread->pid,
-				      cmd == BR_DEAD_BINDER ?
-				      "BR_DEAD_BINDER" :
-				      "BR_CLEAR_DEATH_NOTIFICATION_DONE",
-				      death->cookie);
 
 			if (w->type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {
 				list_del(&w->entry);
@@ -2453,16 +2212,6 @@ retry:
 		ptr += sizeof(tr);
 
 		binder_stat_br(proc, thread, cmd);
-		binder_debug(BINDER_DEBUG_TRANSACTION,
-			     "binder: %d:%d %s %d %d:%d, cmd %d"
-			     "size %zd-%zd ptr %p-%p\n",
-			     proc->pid, thread->pid,
-			     (cmd == BR_TRANSACTION) ? "BR_TRANSACTION" :
-			     "BR_REPLY",
-			     t->debug_id, t->from ? t->from->proc->pid : 0,
-			     t->from ? t->from->pid : 0, cmd,
-			     t->buffer->data_size, t->buffer->offsets_size,
-			     tr.data.ptr.buffer, tr.data.ptr.offsets);
 
 		list_del(&t->work.entry);
 		t->buffer->allow_user_free = 1;
@@ -2487,9 +2236,6 @@ done:
 	     BINDER_LOOPER_STATE_ENTERED)) /* the user-space code fails to */
 	     /*spawn a new thread if we leave this out */) {
 		proc->requested_threads++;
-		binder_debug(BINDER_DEBUG_THREADS,
-			     "binder: %d:%d BR_SPAWN_LOOPER\n",
-			     proc->pid, thread->pid);
 		if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))
 			return -EFAULT;
 	}
@@ -2503,19 +2249,26 @@ static void binder_release_work(struct list_head *list)
 		w = list_first_entry(list, struct binder_work, entry);
 		list_del_init(&w->entry);
 		switch (w->type) {
-		case BINDER_WORK_TRANSACTION: {
-			struct binder_transaction *t;
-
-			t = container_of(w, struct binder_transaction, work);
-			if (t->buffer->target_node && !(t->flags & TF_ONE_WAY))
-				binder_send_failed_reply(t, BR_DEAD_REPLY);
-		} break;
-		case BINDER_WORK_TRANSACTION_COMPLETE: {
-			kfree(w);
-			binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
-		} break;
-		default:
-			break;
+			case BINDER_WORK_TRANSACTION: {
+				struct binder_transaction *t;
+				t = container_of(w, struct binder_transaction, work);
+				if (t->buffer->target_node && !(t->flags & TF_ONE_WAY))
+						binder_send_failed_reply(t, BR_DEAD_REPLY);
+			} break;
+			case BINDER_WORK_TRANSACTION_COMPLETE: {
+				kfree(w);
+				binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
+			} break;
+			case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
+			case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {
+			    struct binder_ref_death *death;
+			    death = container_of(w, struct binder_ref_death, work);
+				kfree(death);
+				binder_stats_deleted(BINDER_STAT_DEATH);
+			} break;
+			default:
+			    pr_err("binder: unexpected work type, %d, not freed\n", w->type);
+				break;
 		}
 	}
 
@@ -2569,11 +2322,6 @@ static int binder_free_thread(struct binder_proc *proc,
 		send_reply = t;
 	while (t) {
 		active_transactions++;
-		binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
-			     "binder: release %d:%d transaction %d "
-			     "%s, still active\n", proc->pid, thread->pid,
-			     t->debug_id,
-			     (t->to_thread == thread) ? "in" : "out");
 
 		if (t->to_thread == thread) {
 			t->to_proc = NULL;
@@ -2659,10 +2407,6 @@ static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			ret = -EFAULT;
 			goto err;
 		}
-		binder_debug(BINDER_DEBUG_READ_WRITE,
-			     "binder: %d:%d write %ld at %08lx, read %ld at %08lx\n",
-			     proc->pid, thread->pid, bwr.write_size, bwr.write_buffer,
-			     bwr.read_size, bwr.read_buffer);
 
 		if (bwr.write_size > 0) {
 			ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &bwr.write_consumed);
@@ -2683,10 +2427,6 @@ static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 				goto err;
 			}
 		}
-		binder_debug(BINDER_DEBUG_READ_WRITE,
-			     "binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n",
-			     proc->pid, thread->pid, bwr.write_consumed, bwr.write_size,
-			     bwr.read_consumed, bwr.read_size);
 		if (copy_to_user(ubuf, &bwr, sizeof(bwr))) {
 			ret = -EFAULT;
 			goto err;
@@ -2727,8 +2467,6 @@ static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		binder_context_mgr_node->has_weak_ref = 1;
 		break;
 	case BINDER_THREAD_EXIT:
-		binder_debug(BINDER_DEBUG_THREADS, "binder: %d:%d exit\n",
-			     proc->pid, thread->pid);
 		binder_free_thread(proc, thread);
 		thread = NULL;
 		break;
@@ -2760,22 +2498,12 @@ err:
 static void binder_vma_open(struct vm_area_struct *vma)
 {
 	struct binder_proc *proc = vma->vm_private_data;
-	binder_debug(BINDER_DEBUG_OPEN_CLOSE,
-		     "binder: %d open vm area %lx-%lx (%ld K) vma %lx pagep %lx\n",
-		     proc->pid, vma->vm_start, vma->vm_end,
-		     (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,
-		     (unsigned long)pgprot_val(vma->vm_page_prot));
 	dump_stack();
 }
 
 static void binder_vma_close(struct vm_area_struct *vma)
 {
 	struct binder_proc *proc = vma->vm_private_data;
-	binder_debug(BINDER_DEBUG_OPEN_CLOSE,
-		     "binder: %d close vm area %lx-%lx (%ld K) vma %lx pagep %lx\n",
-		     proc->pid, vma->vm_start, vma->vm_end,
-		     (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,
-		     (unsigned long)pgprot_val(vma->vm_page_prot));
 	proc->vma = NULL;
 	binder_defer_work(proc, BINDER_DEFERRED_PUT_FILES);
 }
@@ -2796,12 +2524,6 @@ static int binder_mmap(struct file *filp, struct vm_area_struct *vma)
 	if ((vma->vm_end - vma->vm_start) > SZ_4M)
 		vma->vm_end = vma->vm_start + SZ_4M;
 
-	binder_debug(BINDER_DEBUG_OPEN_CLOSE,
-		     "binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx\n",
-		     proc->pid, vma->vm_start, vma->vm_end,
-		     (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,
-		     (unsigned long)pgprot_val(vma->vm_page_prot));
-
 	if (vma->vm_flags & FORBIDDEN_MMAP_FLAGS) {
 		ret = -EPERM;
 		failure_string = "bad vm_flags";
@@ -2884,9 +2606,6 @@ static int binder_open(struct inode *nodp, struct file *filp)
 {
 	struct binder_proc *proc;
 
-	binder_debug(BINDER_DEBUG_OPEN_CLOSE, "binder_open: %d:%d\n",
-		     current->group_leader->pid, current->pid);
-
 	proc = kzalloc(sizeof(*proc), GFP_KERNEL);
 	if (proc == NULL)
 		return -ENOMEM;
@@ -2936,9 +2655,6 @@ static void binder_deferred_flush(struct binder_proc *proc)
 	}
 	wake_up_interruptible_all(&proc->wait);
 
-	binder_debug(BINDER_DEBUG_OPEN_CLOSE,
-		     "binder_flush: %d woke %d threads\n", proc->pid,
-		     wake_count);
 }
 
 static int binder_release(struct inode *nodp, struct file *filp)
@@ -2962,9 +2678,6 @@ static void binder_deferred_release(struct binder_proc *proc)
 
 	hlist_del(&proc->proc_node);
 	if (binder_context_mgr_node && binder_context_mgr_node->proc == proc) {
-		binder_debug(BINDER_DEBUG_DEAD_BINDER,
-			     "binder_release: %d context_mgr_node gone\n",
-			     proc->pid);
 		binder_context_mgr_node = NULL;
 	}
 
@@ -2983,6 +2696,7 @@ static void binder_deferred_release(struct binder_proc *proc)
 		nodes++;
 		rb_erase(&node->rb_node, &proc->nodes);
 		list_del_init(&node->work.entry);
+		binder_release_work(&node->async_todo);
 		if (hlist_empty(&node->refs)) {
 			kfree(node);
 			binder_stats_deleted(BINDER_STAT_NODE);
@@ -3007,10 +2721,6 @@ static void binder_deferred_release(struct binder_proc *proc)
 						BUG();
 				}
 			}
-			binder_debug(BINDER_DEBUG_DEAD_BINDER,
-				     "binder: node %d now dead, "
-				     "refs %d, death %d\n", node->debug_id,
-				     incoming_refs, death);
 		}
 	}
 	outgoing_refs = 0;
@@ -3021,6 +2731,7 @@ static void binder_deferred_release(struct binder_proc *proc)
 		binder_delete_ref(ref);
 	}
 	binder_release_work(&proc->todo);
+	binder_release_work(&proc->delivered_death);
 	buffers = 0;
 
 	while ((n = rb_first(&proc->allocated_buffers))) {
@@ -3030,10 +2741,6 @@ static void binder_deferred_release(struct binder_proc *proc)
 		if (t) {
 			t->buffer = NULL;
 			buffer->transaction = NULL;
-			printk(KERN_ERR "binder: release proc %d, "
-			       "transaction %d, not freed\n",
-			       proc->pid, t->debug_id);
-			/*BUG();*/
 		}
 		binder_free_buf(proc, buffer);
 		buffers++;
@@ -3047,21 +2754,13 @@ static void binder_deferred_release(struct binder_proc *proc)
 		for (i = 0; i < proc->buffer_size / PAGE_SIZE; i++) {
 			if (proc->pages[i]) {
 				void *page_addr = proc->buffer + i * PAGE_SIZE;
-				binder_debug(BINDER_DEBUG_BUFFER_ALLOC,
-					     "binder_release: %d: "
-					     "page %d at %p not freed\n",
-					     proc->pid, i,
-					     page_addr);
 				unmap_kernel_range((unsigned long)page_addr,
 					PAGE_SIZE);
 				if (IS_ALIGNED((unsigned long)proc->pages[i],
 						4))
 					__free_page(proc->pages[i]);
 				else
-					printk(KERN_ERR "binder_release: %d: "
-						"page %d addr %p is invalid\n",
-						proc->pid, i, proc->pages[i]);
-				page_count++;
+					page_count++;
 			}
 		}
 		kfree(proc->pages);
@@ -3070,13 +2769,6 @@ static void binder_deferred_release(struct binder_proc *proc)
 
 	put_task_struct(proc->tsk);
 
-	binder_debug(BINDER_DEBUG_OPEN_CLOSE,
-		     "binder_release: %d threads %d, nodes %d (ref %d), "
-		     "refs %d, active transactions %d, buffers %d, "
-		     "pages %d\n",
-		     proc->pid, threads, nodes, incoming_refs, outgoing_refs,
-		     active_transactions, buffers, page_count);
-
 	kfree(proc);
 }
 
@@ -3308,7 +3000,7 @@ static void print_binder_proc(struct seq_file *m,
 		m->count = start_pos;
 }
 
-static const char *binder_return_strings[] = {
+static const char * const binder_return_strings[] = {
 	"BR_ERROR",
 	"BR_OK",
 	"BR_TRANSACTION",
@@ -3329,7 +3021,7 @@ static const char *binder_return_strings[] = {
 	"BR_FAILED_REPLY"
 };
 
-static const char *binder_command_strings[] = {
+static const char * const binder_command_strings[] = {
 	"BC_TRANSACTION",
 	"BC_REPLY",
 	"BC_ACQUIRE_RESULT",
@@ -3349,7 +3041,7 @@ static const char *binder_command_strings[] = {
 	"BC_DEAD_BINDER_DONE"
 };
 
-static const char *binder_objstat_strings[] = {
+static const char * const binder_objstat_strings[] = {
 	"proc",
 	"thread",
 	"node",
diff --git a/drivers/staging/android/logger.c b/drivers/staging/android/logger.c
index 53d0190..3963187 100644
--- a/drivers/staging/android/logger.c
+++ b/drivers/staging/android/logger.c
@@ -737,9 +732,6 @@ static int __init init_log(struct logger_log *log)
 		return ret;
 	}
 
-	printk(KERN_INFO "logger: created %luK log '%s'\n",
-	       (unsigned long) log->size >> 10, log->misc.name);
-
 	return 0;
 }
 
diff --git a/drivers/staging/android/lowmemorykiller.c b/drivers/staging/android/lowmemorykiller.c
index 74957fc..d0666a1 100644
--- a/drivers/staging/android/lowmemorykiller.c
+++ b/drivers/staging/android/lowmemorykiller.c
@@ -86,21 +49,27 @@ static uint32_t minimum_interval_time = MIN_CSWAP_INTERVAL;
 static uint32_t lmk_count = 0;
 #endif
 
-static uint32_t lowmem_debug_level = 2;
+static uint32_t lowmem_debug_level = 1;
+
 static int lowmem_adj[6] = {
 	0,
-	1,
-	6,
+	2,
+	4,
+	9,
 	12,
+	15,
 };
-static int lowmem_adj_size = 4;
+static int lowmem_adj_size = 6;
+
 static size_t lowmem_minfree[6] = {
 	3 * 512,	/* 6MB */
 	2 * 1024,	/* 8MB */
 	4 * 1024,	/* 16MB */
+	8 * 1024,	/* 32MB */
 	16 * 1024,	/* 64MB */
+	32 * 1024,	/* 128MB */
 };
-static int lowmem_minfree_size = 4;
+static int lowmem_minfree_size = 6;
 
 #ifdef CONFIG_ENHANCED_LMK_ROUTINE
 static struct task_struct *lowmem_deathpending[LOWMEM_DEATHPENDING_DEPTH] = {
@@ -111,12 +80,6 @@ static struct task_struct *lowmem_deathpending;
 #endif
 static unsigned long lowmem_deathpending_timeout;
 
-#define lowmem_print(level, x...)			\
-	do {						\
-		if (lowmem_debug_level >= (level))	\
-			printk(x);			\
-	} while (0)
-
 static int
 task_notify_func(struct notifier_block *self, unsigned long val, void *data);
 
@@ -208,17 +167,11 @@ static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 			break;
 		}
 	}
-	if (sc->nr_to_scan > 0)
-		lowmem_print(3, "lowmem_shrink %lu, %x, ofree %d %d, ma %d\n",
-			     sc->nr_to_scan, sc->gfp_mask, other_free, other_file,
-			     min_adj);
 	rem = global_page_state(NR_ACTIVE_ANON) +
 		global_page_state(NR_ACTIVE_FILE) +
 		global_page_state(NR_INACTIVE_ANON) +
 		global_page_state(NR_INACTIVE_FILE);
 	if (sc->nr_to_scan <= 0 || min_adj == OOM_ADJUST_MAX + 1) {
-		lowmem_print(5, "lowmem_shrink %lu, %x, return %d\n",
-			     sc->nr_to_scan, sc->gfp_mask, rem);
 		return rem;
 	}
 
@@ -272,9 +222,6 @@ static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 
 			if (all_selected_oom < LOWMEM_DEATHPENDING_DEPTH)
 				all_selected_oom++;
-			lowmem_print(2, "select %d (%s), adj %d, size %d,"
-			     "to kill\n",
-			     p->pid, p->comm, oom_adj, tasksize);
 
 			break;
 		}
@@ -289,18 +236,12 @@ static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 		selected = p;
 		selected_tasksize = tasksize;
 		selected_oom_adj = oom_adj;
-		lowmem_print(2, "select %d (%s), adj %d, size %d, to kill\n",
-			     p->pid, p->comm, oom_adj, tasksize);
 
 #endif
 	}
 #ifdef CONFIG_ENHANCED_LMK_ROUTINE
 	for (i = 0; i < LOWMEM_DEATHPENDING_DEPTH; i++) {
 		if (selected[i]) {
-			lowmem_print(1, "send sigkill to %d (%s), adj %d,"
-				     "size %d\n",
-				     selected[i]->pid, selected[i]->comm,
-				     selected_oom_adj[i], selected_tasksize[i]);
 			lowmem_deathpending[i] = selected[i];
 			lowmem_deathpending_timeout = jiffies + HZ;
 			force_sig(SIGKILL, selected[i]);
@@ -312,9 +253,6 @@ static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 	}
 #else
 	if (selected) {
-		lowmem_print(1, "send sigkill to %d (%s), adj %d, size %d\n",
-			     selected->pid, selected->comm,
-			     selected_oom_adj, selected_tasksize);
 		lowmem_deathpending = selected;
 		lowmem_deathpending_timeout = jiffies + HZ;
 		force_sig(SIGKILL, selected);
@@ -324,109 +262,10 @@ static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 #endif
 	}
 #endif
-	lowmem_print(4, "lowmem_shrink %lu, %x, return %d\n",
-		     sc->nr_to_scan, sc->gfp_mask, rem);
 	read_unlock(&tasklist_lock);
 	return rem;
 }
 

diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index 33d71c6..beef0ff 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -212,10 +212,6 @@ static void android_work(struct work_struct *data)
 
 	if (uevent_envp) {
 		kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, uevent_envp);
-		pr_info("%s: sent uevent %s\n", __func__, uevent_envp[0]);
-	} else {
-		pr_info("%s: did not send uevent (%d %d %p)\n", __func__,
-			 dev->connected, dev->sw_connected, cdev->config);
 	}
 }
 
@@ -338,7 +334,6 @@ static void adb_closed_callback(void)
 	mutex_unlock(&dev->mutex);
 }
 
-
 #define MAX_ACM_INSTANCES 4
 struct acm_function_config {
 	int instances;
@@ -420,16 +415,15 @@ static struct android_usb_function acm_function = {
 	.attributes	= acm_function_attributes,
 };
 
-
 static int mtp_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
 {
 	return mtp_setup();
 }
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static int mtp3sung_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
+static int mtpSsung_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
 {
-	return mtp3sung_setup();
+	return mtpSsung_setup();
 }
 #endif
 
@@ -439,9 +433,9 @@ static void mtp_function_cleanup(struct android_usb_function *f)
 }
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static void mtp3sung_function_cleanup(struct android_usb_function *f)
+static void mtpSsung_function_cleanup(struct android_usb_function *f)
 {
-	mtp3sung_cleanup();
+	mtpSsung_cleanup();
 }
 #endif
 
@@ -451,9 +445,9 @@ static int mtp_function_bind_config(struct android_usb_function *f, struct usb_c
 }
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static int mtp3sung_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
+static int mtpSsung_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
 {
-	return mtp3sung_bind_config(c, false);
+	return mtpSsung_bind_config(c, false);
 }
 #endif
 
@@ -464,7 +458,7 @@ static int ptp_function_init(struct android_usb_function *f, struct usb_composit
 }
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static int ptp3sung_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
+static int ptpSsung_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
 {
 	/* nothing to do - initialization is handled by mtp_function_init */
 	return 0;
@@ -477,7 +471,7 @@ static void ptp_function_cleanup(struct android_usb_function *f)
 }
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static void ptp3sung_function_cleanup(struct android_usb_function *f)
+static void ptpSsung_function_cleanup(struct android_usb_function *f)
 {
 	/* nothing to do - cleanup is handled by mtp_function_cleanup */
 }
@@ -489,9 +483,9 @@ static int ptp_function_bind_config(struct android_usb_function *f, struct usb_c
 }
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static int ptp3sung_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
+static int ptpSsung_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
 {
-	return mtp3sung_bind_config(c, true);
+	return mtpSsung_bind_config(c, true);
 }
 #endif
 
@@ -503,11 +497,11 @@ static int mtp_function_ctrlrequest(struct android_usb_function *f,
 }
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static int mtp3sung_function_ctrlrequest(struct android_usb_function *f,
+static int mtpSsung_function_ctrlrequest(struct android_usb_function *f,
 						struct usb_composite_dev *cdev,
 						const struct usb_ctrlrequest *c)
 {
-	return mtp3sung_ctrlrequest(cdev, c);
+	return mtpSsung_ctrlrequest(cdev, c);
 }
 #endif
 
@@ -520,12 +514,12 @@ static struct android_usb_function mtp_function = {
 };
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static struct android_usb_function mtp3sung_function = {
+static struct android_usb_function mtpSsung_function = {
 	.name		= "mtp",
-	.init		= mtp3sung_function_init,
-	.cleanup	= mtp3sung_function_cleanup,
-	.bind_config	= mtp3sung_function_bind_config,
-	.ctrlrequest	= mtp3sung_function_ctrlrequest,
+	.init		= mtpSsung_function_init,
+	.cleanup	= mtpSsung_function_cleanup,
+	.bind_config	= mtpSsung_function_bind_config,
+	.ctrlrequest	= mtpSsung_function_ctrlrequest,
 };
 #endif
 
@@ -538,15 +532,14 @@ static struct android_usb_function ptp_function = {
 };
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static struct android_usb_function ptp3sung_function = {
+static struct android_usb_function ptpSsung_function = {
 	.name		= "ptp",
-	.init		= ptp3sung_function_init,
-	.cleanup	= ptp3sung_function_cleanup,
-	.bind_config	= ptp3sung_function_bind_config,
+	.init		= ptpSsung_function_init,
+	.cleanup	= ptpSsung_function_cleanup,
+	.bind_config	= ptpSsung_function_bind_config,
 };
 #endif
 
-
 struct rndis_function_config {
 	u8      ethaddr[ETH_ALEN];
 	u32     vendorID;
@@ -579,10 +572,6 @@ static int rndis_function_bind_config(struct android_usb_function *f,
 		return -1;
 	}
 
-	pr_info("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
-		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
-		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
-
 	ret = gether_setup_name(c->cdev->gadget, rndis->ethaddr, "rndis");
 	if (ret) {
 		pr_err("%s: gether_setup failed\n", __func__);
@@ -729,7 +718,6 @@ static struct android_usb_function rndis_function = {
 	.attributes	= rndis_function_attributes,
 };
 
-
 struct mass_storage_function_config {
 	struct fsg_config fsg;
 	struct fsg_common *common;
@@ -740,7 +728,7 @@ static int mass_storage_function_init(struct android_usb_function *f,
 {
 	struct mass_storage_function_config *config;
 	struct fsg_common *common;
-	int err, i;
+	int err;
 
 	config = kzalloc(sizeof(struct mass_storage_function_config),
 								GFP_KERNEL);
@@ -755,8 +743,7 @@ static int mass_storage_function_init(struct android_usb_function *f,
 		 * Please do not modify nluns directly in this function.
 		 * Every model uses same android file.
 		 */
-		printk(KERN_DEBUG "usb: %s pdata->nluns=%d\n", __func__,
-				android_usb_pdata->nluns);
+		printk(KERN_DEBUG "usb: %s pdata->nluns=%d\n", __func__, android_usb_pdata->nluns);
 		config->fsg.nluns = android_usb_pdata->nluns;
 		for (i = 0; i < android_usb_pdata->nluns; i++) {
 			config->fsg.luns[i].removable = 1;
@@ -772,8 +759,7 @@ static int mass_storage_function_init(struct android_usb_function *f,
 			char luns[5];
 			err = snprintf(luns, 5, "lun%d", i);
 			if (err == 0) {
-				printk(KERN_ERR "usb: %s snprintf error\n",
-						__func__);
+				printk(KERN_ERR "usb: %s snprintf error\n", __func__);
 				return err;
 			}
 			err = sysfs_create_link(&f->dev->kobj,
@@ -868,8 +854,6 @@ static ssize_t mass_storage_vendor_store(struct device *dev,
 	if (sscanf(buf, "%s", config->common->vendor_string) != 1)
 		return -EINVAL;
 
-	printk(KERN_DEBUG "%s: vendor %s", __func__,
-			config->common->vendor_string);
 	return size;
 }
 
@@ -896,8 +880,6 @@ static ssize_t mass_storage_product_store(struct device *dev,
 	if (sscanf(buf, "%s", config->common->product_string) != 1)
 		return -EINVAL;
 
-	printk(KERN_DEBUG "%s: product %s", __func__,
-			config->common->product_string);
 	return size;
 }
 
@@ -1017,7 +999,6 @@ static struct android_usb_function accessory_function = {
 	.ctrlrequest	= accessory_function_ctrlrequest,
 };
 
-
 static int dm_function_bind_config(struct android_usb_function *f,
 					struct usb_configuration *c)
 {
@@ -1046,11 +1027,11 @@ static struct android_usb_function *supported_functions[] = {
 };
 
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-static struct android_usb_function *supported3sung_functions[] = {
+static struct android_usb_function *supportedSsung_functions[] = {
 	&adb_function,
 	&acm_function,
-	&mtp3sung_function,
-	&ptp3sung_function,
+	&mtpSsung_function,
+	&ptpSsung_function,
 	&rndis_function,
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 	&ncm_function,
@@ -1063,7 +1044,6 @@ static struct android_usb_function *supported3sung_functions[] = {
 };
 #endif
 
-
 static int android_init_functions(struct android_usb_function **functions,
 				  struct usb_composite_dev *cdev)
 {
@@ -1079,8 +1059,7 @@ static int android_init_functions(struct android_usb_function **functions,
 		f->dev = device_create(android_class, dev->dev,
 				MKDEV(0, index), f, f->dev_name);
 		if (IS_ERR(f->dev)) {
-			pr_err("%s: Failed to create dev %s", __func__,
-							f->dev_name);
+			pr_err("%s: Failed to create dev %s", __func__, f->dev_name);
 			err = PTR_ERR(f->dev);
 			goto err_create;
 		}
@@ -1088,8 +1067,7 @@ static int android_init_functions(struct android_usb_function **functions,
 		if (f->init) {
 			err = f->init(f, cdev);
 			if (err) {
-				pr_err("%s: Failed to init %s", __func__,
-								f->name);
+				pr_err("%s: Failed to init %s", __func__, f->name);
 				goto err_out;
 			}
 		}
@@ -1100,8 +1078,7 @@ static int android_init_functions(struct android_usb_function **functions,
 				err = device_create_file(f->dev, attr);
 		}
 		if (err) {
-			pr_err("%s: Failed to create function %s attributes",
-					__func__, f->name);
+			pr_err("%s: Failed to create function %s attributes", __func__, f->name);
 			goto err_out;
 		}
 	}
@@ -1222,10 +1199,7 @@ functions_store(struct device *pdev, struct device_attribute *attr,
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 			/* Enable ncm function */
 			if (is_ncm_ready(name)) {
-				printk(KERN_DEBUG "usb: %s ncm on\n",
-						__func__);
-				err = android_enable_function(dev,
-						"ncm");
+				err = android_enable_function(dev, "ncm");
 				continue;
 			}
 #endif
@@ -1237,9 +1211,7 @@ functions_store(struct device *pdev, struct device_attribute *attr,
 			if (!strcmp(name, "mtp")) {
 				err = android_enable_function(dev, "acm");
 				if (err)
-					pr_err(
-					"android_usb: Cannot enable '%s'",
-					name);
+					pr_err("android_usb: Cannot enable '%s'", name);
 			}
 #endif
 		}
@@ -1311,8 +1283,7 @@ static ssize_t enable_store(struct device *pdev, struct device_attribute *attr,
 		dev->enabled = false;
 #endif
 	} else {
-		pr_err("android_usb: already %s\n",
-				dev->enabled ? "enabled" : "disabled");
+		pr_err("android_usb: already %s\n", dev->enabled ? "enabled" : "disabled");
 	}
 
 	mutex_unlock(&dev->mutex);
@@ -1376,7 +1347,6 @@ field ## _store(struct device *dev, struct device_attribute *attr,	\
 }									\
 static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
 
-
 DESCRIPTOR_ATTR(idVendor, "%04x\n")
 DESCRIPTOR_ATTR(idProduct, "%04x\n")
 DESCRIPTOR_ATTR(bcdDevice, "%04x\n")
@@ -1458,12 +1428,9 @@ static int android_bind(struct usb_composite_dev *cdev)
 
 	/* Default strings - should be updated by userspace */
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	strncpy(manufacturer_string, "SAMSUNG",
-			sizeof(manufacturer_string) - 1);
-	strncpy(product_string, "SAMSUNG_Android",
-			sizeof(product_string) - 1);
-	sprintf(serial_string,
-			"%08X%08X", system_serial_high, system_serial_low);
+	strncpy(manufacturer_string, "SAMSUNG", sizeof(manufacturer_string) - 1);
+	strncpy(product_string, "SAMSUNG_Android", sizeof(product_string) - 1);
+	sprintf(serial_string, "%08X%08X", system_serial_high, system_serial_low);
 #else
 	strncpy(manufacturer_string, "Android", sizeof(manufacturer_string) - 1);
 	strncpy(product_string, "Android", sizeof(product_string) - 1);
@@ -1487,8 +1454,7 @@ static int android_bind(struct usb_composite_dev *cdev)
 		 * things like configuration and altsetting numbering
 		 * can need hardware-specific attention though.
 		 */
-		pr_warning("%s: controller '%s' not recognized\n",
-			longname, gadget->name);
+		pr_warning("%s: controller '%s' not recognized\n", longname, gadget->name);
 		device_desc.bcdDevice = __constant_cpu_to_le16(0x9999);
 	}
 
@@ -1575,19 +1541,15 @@ static void android_disconnect(struct usb_gadget *gadget)
 	composite_disconnect(gadget);
 	/* accessory HID support can be active while the
 	   accessory function is not actually enabled,
-	   so we need to inform it when we are disconnected.
-	 */
+	   so we need to inform it when we are disconnected. */
 	acc_disconnect();
 
 	spin_lock_irqsave(&cdev->lock, flags);
 	dev->connected = 0;
 #ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 	set_ncm_ready(false);
-	printk(KERN_DEBUG "usb: %s schedule_work\n", __func__);
-	schedule_work(&dev->work);
-#else
-	schedule_work(&dev->work);
 #endif
+	schedule_work(&dev->work);
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 
@@ -1597,8 +1559,7 @@ static int android_create_device(struct android_dev *dev)
 	struct device_attribute *attr;
 	int err;
 
-	dev->dev = device_create(android_class, NULL,
-					MKDEV(0, 0), NULL, "android0");
+	dev->dev = device_create(android_class, NULL, MKDEV(0, 0), NULL, "android0");
 	if (IS_ERR(dev->dev))
 		return PTR_ERR(dev->dev);
 
@@ -1619,13 +1580,7 @@ static int android_probe(struct platform_device *pdev)
 {
 	android_usb_pdata = pdev->dev.platform_data;
 
-	pr_debug(KERN_INFO "usb: %s pdata: %p\n", __func__, android_usb_pdata);
-
-	if (android_usb_pdata) {
-		printk(KERN_INFO "usb: %s nluns=%d\n", __func__,
-				android_usb_pdata->nluns);
-	} else {
-		printk(KERN_INFO "usb: %s pdata is not available\n", __func__);
+	if (!android_usb_pdata) {
 		return -ENODATA;
 	}
 	return 0;
@@ -1653,19 +1608,15 @@ int late_init_android_gadget(int romtype)
 	dev->disable_depth = 1;
 #ifdef CONFIG_USB_ANDROID_MTP_LATE_INIT
 	if (!romtype) {
-		dev->functions = supported3sung_functions;
-		printk("Late initializing Samsung Android USB\n");
+		dev->functions = supportedSsung_functions;
 	}
 	else {
 		dev->functions = supported_functions;
-		printk("Late initializing standard Android USB\n");
 	}
 #elif defined(CONFIG_USB_ANDROID_SAMSUNG_MTP)
-	dev->functions = supported3sung_functions;
-	printk("Initializing Samsung Android USB\n");
+	dev->functions = supportedSsung_functions;
 #else
 	dev->functions = supported_functions;
-	printk("Initializing standard Android USB\n");
 #endif
 	INIT_LIST_HEAD(&dev->enabled_functions);
 	INIT_WORK(&dev->work, android_work);
diff --git a/drivers/video/omap2/displays/panel-ltn070nl01.c b/drivers/video/omap2/displays/panel-ltn070nl01.c
index 9696d7a..df37837 100644
--- a/drivers/video/omap2/displays/panel-ltn070nl01.c
+++ b/drivers/video/omap2/displays/panel-ltn070nl01.c
@@ -39,8 +39,6 @@
 
 #include <plat/dmtimer.h>
 
-#define DEBUG_PRINT 0
-
 #define PWM_DUTY_MAX			1200 /* 32kHz */
 
 struct ltn070nl01 {
@@ -82,8 +80,6 @@ static void backlight_gptimer_stop(struct omap_dss_device *dssdev)
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret;
 	ret = omap_dm_timer_stop(lcd->gptimer);
-	if (ret)
-		pr_err("failed to stop pwm timer. ret=%d\n", ret);
 }
 
 static int backlight_gptimer_init(struct omap_dss_device *dssdev)
@@ -91,8 +87,6 @@ static int backlight_gptimer_init(struct omap_dss_device *dssdev)
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret;
 
-	pr_info("(%s): called (@%d)\n", __func__, __LINE__);
-
 	if (lcd->pdata->set_gptimer_idle)
 			lcd->pdata->set_gptimer_idle();
 
@@ -121,7 +115,6 @@ err_dm_timer_request:
 static int ltn070nl01_hw_reset(struct omap_dss_device *dssdev)
 {
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
-	pr_info("(%s): called (@%d)\n", __func__, __LINE__);
 
 	gpio_set_value(lcd->pdata->led_backlight_reset_gpio, 0);
 	mdelay(1);
@@ -181,8 +174,6 @@ static int ltn070nl01_power_on(struct omap_dss_device *dssdev)
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret = 0;
 
-	pr_info("(%s): called (@%d)\n", __func__, __LINE__);
-
 	if (lcd->enabled != 1) {
 		if (lcd->pdata->set_power)
 			lcd->pdata->set_power(true);
@@ -214,7 +205,6 @@ err:
 	return ret;
 }
 
-
 static int ltn070nl01_power_off(struct omap_dss_device *dssdev)
 {
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
@@ -263,10 +253,6 @@ static int ltn070nl01_set_brightness(struct backlight_device *bd)
 		(lcd->enabled) &&
 		(lcd->current_brightness != lcd->bl)) {
 		update_brightness(dssdev);
-#if DEBUG_PRINT
-		dev_info(&bd->dev, "[%d] brightness=%d, bl=%d\n",
-			 lcd->pdata->panel_id, bd->props.brightness, lcd->bl);
-#endif
 	}
 	mutex_unlock(&lcd->lock);
 	return ret;
@@ -306,10 +292,6 @@ static ssize_t ltn070nl01_sysfs_store_lcd_power(struct device *dev,
 	if (rc < 0)
 		return rc;
 
-#if DEBUG_PRINT
-	dev_info(dev, "ltn070nl01_sysfs_store_lcd_power - %d\n", lcd_enable);
-#endif
-
 	mutex_lock(&lcd->lock);
 	if (lcd_enable) {
 		if (dssdev->state != OMAP_DSS_DISPLAY_SUSPENDED) {
@@ -345,8 +327,6 @@ static int ltn070nl01_panel_probe(struct omap_dss_device *dssdev)
 		.max_brightness = 255,
 		.type = BACKLIGHT_RAW,
 	};
-	pr_info("(%s): called (@%d)\n", __func__, __LINE__);
-	dev_dbg(&dssdev->dev, "ltn070nl01_probe\n");
 
 	lcd = kzalloc(sizeof(*lcd), GFP_KERNEL);
 	if (!lcd)
@@ -453,7 +433,6 @@ static int ltn070nl01_panel_probe(struct omap_dss_device *dssdev)
 
 	update_brightness(dssdev);
 
-	dev_dbg(&dssdev->dev, "%s\n", __func__);
 	return ret;
 
 err_gptimer_init:
@@ -502,7 +481,6 @@ static int ltn070nl01_start(struct omap_dss_device *dssdev)
 	r = ltn070nl01_power_on(dssdev);
 
 	if (r) {
-		dev_dbg(&dssdev->dev, "enable failed\n");
 		dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
 	} else {
 		dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
@@ -524,8 +502,6 @@ static int ltn070nl01_panel_enable(struct omap_dss_device *dssdev)
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret;
 
-	dev_dbg(&dssdev->dev, "enable\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state != OMAP_DSS_DISPLAY_DISABLED) {
 		ret = -EINVAL;
@@ -542,8 +518,6 @@ static void ltn070nl01_panel_disable(struct omap_dss_device *dssdev)
 {
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
 
-	dev_dbg(&dssdev->dev, "disable\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)
 		ltn070nl01_stop(dssdev);
@@ -558,8 +532,6 @@ static void ltn070nl01_panel_shutdown_worker(struct work_struct *work)
 			panel_delayed_work.work);
 	struct omap_dss_device *dssdev = lcd->dssdev;
 
-	dev_dbg(&dssdev->dev, "ltn070nl01_panel_shutdown\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state == OMAP_DSS_DISPLAY_DISABLED) {
 		mutex_unlock(&lcd->lock);
@@ -572,7 +544,6 @@ static void ltn070nl01_panel_shutdown_worker(struct work_struct *work)
 	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
 	mutex_unlock(&lcd->lock);
 
-
 }
 static int ltn070nl01_panel_shutdown(struct omap_dss_device *dssdev)
 {
@@ -589,8 +560,6 @@ static int ltn070nl01_panel_suspend(struct omap_dss_device *dssdev)
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret = 0;
 
-	pr_info("Enter ltn070nl01_panel_suspend\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE) {
 		ret = -EINVAL;
@@ -609,8 +578,6 @@ static int ltn070nl01_panel_resume(struct omap_dss_device *dssdev)
 	struct ltn070nl01 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret;
 
-	pr_info("Enter ltn070nl01_panel_resume\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state != OMAP_DSS_DISPLAY_SUSPENDED) {
 		ret = -EINVAL;
diff --git a/drivers/video/omap2/displays/panel-ltn101al03.c b/drivers/video/omap2/displays/panel-ltn101al03.c
index 47c97c2..564399d 100644
--- a/drivers/video/omap2/displays/panel-ltn101al03.c
+++ b/drivers/video/omap2/displays/panel-ltn101al03.c
@@ -39,8 +39,6 @@
 
 #include <plat/dmtimer.h>
 
-#define DEBUG_PRINT 0
-
 #define BRIGHTNESS_OFF			0
 #define BRIGHTNESS_DIM			20
 #define BRIGHTNESS_MIN			30
@@ -94,8 +92,6 @@ static void backlight_gptimer_stop(struct omap_dss_device *dssdev)
 	struct ltn101al03 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret;
 	ret = omap_dm_timer_stop(lcd->gptimer);
-	if (ret)
-		pr_err("failed to stop pwm timer. ret=%d\n", ret);
 }
 
 static int backlight_gptimer_init(struct omap_dss_device *dssdev)
@@ -103,8 +99,6 @@ static int backlight_gptimer_init(struct omap_dss_device *dssdev)
 	struct ltn101al03 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret;
 
-	pr_info("(%s): called (@%d)\n", __func__, __LINE__);
-
 	if (lcd->pdata->set_gptimer_idle)
 		lcd->pdata->set_gptimer_idle();
 
@@ -133,7 +127,6 @@ err_dm_timer_request:
 static int ltn101al03_hw_reset(struct omap_dss_device *dssdev)
 {
 	struct ltn101al03 *lcd = dev_get_drvdata(&dssdev->dev);
-	pr_info("(%s): called (@%d)\n", __func__, __LINE__);
 
 	gpio_set_value(lcd->pdata->lvds_nshdn_gpio, 0);
 	mdelay(1);
@@ -189,8 +182,6 @@ static int ltn101al03_power_on(struct omap_dss_device *dssdev)
 	struct ltn101al03 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret = 0;
 
-	pr_info("(%s): called (@%d)\n", __func__, __LINE__);
-
 	if (lcd->enabled != 1) {
 		if (lcd->pdata->set_power)
 			lcd->pdata->set_power(true);
@@ -272,10 +263,6 @@ static int ltn101al03_set_brightness(struct backlight_device *bd)
 		(lcd->enabled) &&
 		(lcd->current_brightness != lcd->bl)) {
 		update_brightness(dssdev);
-#if DEBUG_PRINT
-		dev_info(&bd->dev, "[%d] brightness=%d, bl=%d\n",
-			 lcd->pdata->panel_id, bd->props.brightness, lcd->bl);
-#endif
 	}
 	mutex_unlock(&lcd->lock);
 	return ret;
@@ -315,10 +302,6 @@ static ssize_t ltn101al03_sysfs_store_lcd_power(struct device *dev,
 	if (rc < 0)
 		return rc;
 
-#if DEBUG_PRINT
-	dev_info(dev, "ltn101al03_sysfs_store_lcd_power - %d\n", lcd_enable);
-#endif
-
 	mutex_lock(&lcd->lock);
 	if (lcd_enable) {
 		if (dssdev->state != OMAP_DSS_DISPLAY_SUSPENDED) {
@@ -354,8 +337,6 @@ static int ltn101al03_panel_probe(struct omap_dss_device *dssdev)
 		.max_brightness = 255,
 		.type = BACKLIGHT_RAW,
 	};
-	pr_info("(%s): called (@%d)\n", __func__, __LINE__);
-	dev_dbg(&dssdev->dev, "ltn101al03_probe\n");
 
 	lcd = kzalloc(sizeof(*lcd), GFP_KERNEL);
 	if (!lcd)
@@ -403,7 +384,6 @@ static int ltn101al03_panel_probe(struct omap_dss_device *dssdev)
 	mutex_init(&lcd->lock);
 	lcd->workqueue = create_singlethread_workqueue("panel_shutdown");
 	if (lcd->workqueue == NULL) {
-		dev_err(&dssdev->dev, "can't create panel shutdown workqueue\n");
 		ret = -ENOMEM;
 		goto err_wq;
 
@@ -462,7 +442,6 @@ static int ltn101al03_panel_probe(struct omap_dss_device *dssdev)
 
 	update_brightness(dssdev);
 
-	dev_dbg(&dssdev->dev, "%s\n", __func__);
 	return ret;
 
 err_gptimer_init:
@@ -511,7 +490,6 @@ static int ltn101al03_start(struct omap_dss_device *dssdev)
 	r = ltn101al03_power_on(dssdev);
 
 	if (r) {
-		dev_dbg(&dssdev->dev, "enable failed\n");
 		dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
 	} else {
 		dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
@@ -533,8 +511,6 @@ static int ltn101al03_panel_enable(struct omap_dss_device *dssdev)
 	struct ltn101al03 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret;
 
-	dev_dbg(&dssdev->dev, "enable\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state != OMAP_DSS_DISPLAY_DISABLED) {
 		ret = -EINVAL;
@@ -551,8 +527,6 @@ static void ltn101al03_panel_disable(struct omap_dss_device *dssdev)
 {
 	struct ltn101al03 *lcd = dev_get_drvdata(&dssdev->dev);
 
-	dev_dbg(&dssdev->dev, "disable\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)
 		ltn101al03_stop(dssdev);
@@ -566,8 +540,6 @@ static void ltn101al03_panel_shutdown_worker(struct work_struct *work)
 			panel_delayed_work.work);
 	struct omap_dss_device *dssdev = lcd->dssdev;
 
-	dev_dbg(&dssdev->dev, "ltn101al03_panel_shutdown\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state == OMAP_DSS_DISPLAY_DISABLED) {
 		mutex_unlock(&lcd->lock);
@@ -580,7 +552,6 @@ static void ltn101al03_panel_shutdown_worker(struct work_struct *work)
 	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
 	mutex_unlock(&lcd->lock);
 
-
 }
 static int ltn101al03_panel_shutdown(struct omap_dss_device *dssdev)
 {
@@ -597,8 +568,6 @@ static int ltn101al03_panel_suspend(struct omap_dss_device *dssdev)
 	struct ltn101al03 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret = 0;
 
-	pr_info("Enter ltn101al03_panel_suspend\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE) {
 		ret = -EINVAL;
@@ -617,8 +586,6 @@ static int ltn101al03_panel_resume(struct omap_dss_device *dssdev)
 	struct ltn101al03 *lcd = dev_get_drvdata(&dssdev->dev);
 	int ret;
 
-	pr_info("Enter ltn101al03_panel_resume\n");
-
 	mutex_lock(&lcd->lock);
 	if (dssdev->state != OMAP_DSS_DISPLAY_SUSPENDED) {
 		ret = -EINVAL;
diff --git a/drivers/video/omap2/dss/core.c b/drivers/video/omap2/dss/core.c
index 0ae8524..cb1c6ca 100644
--- a/drivers/video/omap2/dss/core.c
+++ b/drivers/video/omap2/dss/core.c
@@ -190,7 +190,6 @@ void omap_dss_request_high_bandwidth(struct device *dss_dev)
 	else if (!omap_pm_set_min_bus_tput(dss_dev,
 					OCP_INITIATOR_AGENT, HIGH_RES_TPUT))
 		return;
-	DSSDBG("Failed to set high L3 bus speed\n");
 }
 
 void omap_dss_reset_high_bandwidth(struct device *dss_dev)
@@ -696,4 +694,3 @@ device_initcall(omap_dss_init2);
 MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@nokia.com>");
 MODULE_DESCRIPTION("OMAP2/3 Display Subsystem");
 MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/video/omap2/dss/dispc.c b/drivers/video/omap2/dss/dispc.c
index a723a22..bb1b13b 100644
--- a/drivers/video/omap2/dss/dispc.c
+++ b/drivers/video/omap2/dss/dispc.c
@@ -392,7 +392,6 @@ static void dispc_restore_context(void)
 	if (dss_has_feature(FEAT_PRELOAD))
 		RR(OVL_PRELOAD(OMAP_DSS_GFX));
 
-
 	/* VID1-3 */
 	for (o = OMAP_DSS_VIDEO1; o <= OMAP_DSS_VIDEO3; o++) {
 		if (o == OMAP_DSS_VIDEO3 && !dss_has_feature(FEAT_OVL_VID3))
@@ -648,7 +647,6 @@ void dispc_runtime_put(void)
 	mutex_unlock(&dispc.runtime_lock);
 }
 
-
 bool dispc_go_busy(enum omap_channel channel)
 {
 	int bit;
@@ -2571,7 +2569,6 @@ int dispc_setup_plane(enum omap_plane plane,
 		_dispc_set_plane_ba1_uv(plane, puv_addr + offset1);
 	}
 
-
 	_dispc_set_row_inc(plane, row_inc);
 	_dispc_set_pix_inc(plane, pix_inc);
 
@@ -3051,7 +3048,6 @@ void dispc_enable_fifohandcheck(enum omap_channel channel, bool enable)
 		REG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 16, 16);
 }
 
-
 void dispc_set_lcd_display_type(enum omap_channel channel,
 		enum omap_lcd_display_type type)
 {
@@ -3082,7 +3078,6 @@ void dispc_set_loadmode(enum omap_dss_load_mode mode)
 	REG_FLD_MOD(DISPC_CONFIG, mode, 2, 1);
 }
 
-
 void dispc_set_default_color(enum omap_channel channel, u32 color)
 {
 	dispc_write_reg(DISPC_DEFAULT_COLOR(channel), color);
@@ -3173,7 +3168,6 @@ bool dispc_alpha_blending_enabled(enum omap_channel ch)
 	return enabled;
 }
 
-
 bool dispc_trans_key_enabled(enum omap_channel ch)
 {
 	bool enabled;
@@ -3190,7 +3184,6 @@ bool dispc_trans_key_enabled(enum omap_channel ch)
 	return enabled;
 }
 
-
 void dispc_set_tft_data_lines(enum omap_channel channel, u8 data_lines)
 {
 	int code;
@@ -4470,7 +4463,6 @@ static void _omap_dispc_initial_config(void)
 		u16 sizey = ((size_reg >> 16) & 0x7ff) + 1;
 		u32 tot_size = sizex * sizey;
 
-
 		if (tot_size <= RESOLUTION_1280_720)
 			/* Disable the Display sub system global MFLAG */
 			dispc_write_reg(DISPC_GLOBAL_MFLAG, 0);
@@ -4497,7 +4489,6 @@ static int omap_dispchw_probe(struct platform_device *pdev)
 		goto err_get_clk;
 	}
 
-
 	dispc.dss_clk = clk;
 
 	spin_lock_init(&dispc.irq_lock);
@@ -4548,8 +4539,6 @@ static int omap_dispchw_probe(struct platform_device *pdev)
 	_omap_dispc_initialize_irq();
 
 	rev = dispc_read_reg(DISPC_REVISION);
-	dev_dbg(&pdev->dev, "OMAP DISPC rev %d.%d\n",
-	       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));
 #ifndef CONFIG_FB_OMAP_BOOTLOADER_INIT
 	dispc_runtime_put();
 #endif
diff --git a/drivers/video/omap2/dss/dpi.c b/drivers/video/omap2/dss/dpi.c
index d57b804..a6c111c 100644
--- a/drivers/video/omap2/dss/dpi.c
+++ b/drivers/video/omap2/dss/dpi.c
@@ -44,7 +44,6 @@ static struct {
 #endif
 } dpi;
 
-
 static struct platform_device *dpi_get_dsidev(enum omap_dss_clk_source clk)
 {
 	int dsi_module;
@@ -151,13 +150,8 @@ static int dpi_set_mode(struct omap_dss_device *dssdev)
 
 	pck = fck / lck_div / pck_div / 1000;
 
-	if (pck != t->pixel_clock) {
-		DSSWARN("Could not find exact pixel clock. "
-				"Requested %d kHz, got %lu kHz\n",
-				t->pixel_clock, pck);
-
+	if (pck != t->pixel_clock)
 		t->pixel_clock = pck;
-	}
 
 	dispc_set_lcd_timings(dssdev->manager->id, t);
 
@@ -387,4 +381,3 @@ int dpi_init(void)
 void dpi_exit(void)
 {
 }
-
diff --git a/drivers/video/omap2/dss/dsi.c b/drivers/video/omap2/dss/dsi.c
index 88066af..24a9be5 100644
--- a/drivers/video/omap2/dss/dsi.c
+++ b/drivers/video/omap2/dss/dsi.c
@@ -532,7 +532,6 @@ static void print_irq_status(u32 status)
 	if ((status & ~DSI_IRQ_CHANNEL_MASK) == 0)
 		return;
 #endif
-	printk(KERN_DEBUG "DSI IRQ: 0x%x: ", status);
 
 #define PIS(x) \
 	if (status & DSI_IRQ_##x) \
@@ -570,7 +569,6 @@ static void print_irq_status_vc(int channel, u32 status)
 	if ((status & ~DSI_VC_IRQ_PACKET_SENT) == 0)
 		return;
 #endif
-	printk(KERN_DEBUG "DSI VC(%d) IRQ 0x%x: ", channel, status);
 
 #define PIS(x) \
 	if (status & DSI_VC_IRQ_##x) \
@@ -595,8 +593,6 @@ static void print_irq_status_cio(u32 status)
 	if (status == 0)
 		return;
 
-	printk(KERN_DEBUG "DSI CIO IRQ 0x%x: ", status);
-
 #define PIS(x) \
 	if (status & DSI_CIO_IRQ_##x) \
 		printk(#x " ");
diff --git a/drivers/video/omap2/dss/hdmi.c b/drivers/video/omap2/dss/hdmi.c
index 3386839..9136473 100644
--- a/drivers/video/omap2/dss/hdmi.c
+++ b/drivers/video/omap2/dss/hdmi.c
@@ -684,7 +684,6 @@ int omapdss_hdmi_register_hdcp_callbacks(void (*hdmi_start_frame_cb)(void),
 					 bool (*hdmi_power_on_cb)(void))
 {
 	if (!hdmi.dssdev) {
-		DSSERR("HDMI is not active\n");
 		return 0;
 	}
 
@@ -876,8 +875,7 @@ int omapdss_hdmi_display_enable(struct omap_dss_device *dssdev)
 		DSSERR("failed to enable hdmi_vref regulator\n");
 		goto err3;
 	}
-	/* don't power on HDMI , if we are in LPM mode...
-	 * It looks buggy to do so, but there is no easy way. */
+	/* don't power on HDMI , if we are in LPM mode */
 	if (sec_bootmode != 5) {
 		r = hdmi_power_on(dssdev);
 		if (r) {
@@ -1000,7 +998,6 @@ static int omapdss_hdmihw_probe(struct platform_device *pdev)
 			hdmi.dssdev = board_data->devices[r];
 	}
 	if (!hdmi.dssdev) {
-		DSSERR("can't get HDMI device\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/video/omap2/dss/manager.c b/drivers/video/omap2/dss/manager.c
index e208318..d1d87dc 100644
--- a/drivers/video/omap2/dss/manager.c
+++ b/drivers/video/omap2/dss/manager.c
@@ -74,13 +74,9 @@ static ssize_t manager_display_store(struct omap_overlay_manager *mgr,
 	if (len > 0 && dssdev == NULL)
 		return -EINVAL;
 
-	if (dssdev)
-		DSSDBG("display %s found\n", dssdev->name);
-
 	if (mgr->device) {
 		r = mgr->unset_device(mgr);
 		if (r) {
-			DSSERR("failed to unset display\n");
 			goto put_device;
 		}
 	}
@@ -88,13 +84,11 @@ static ssize_t manager_display_store(struct omap_overlay_manager *mgr,
 	if (dssdev) {
 		r = mgr->set_device(mgr, dssdev);
 		if (r) {
-			DSSERR("failed to set manager\n");
 			goto put_device;
 		}
 
 		r = mgr->apply(mgr);
 		if (r) {
-			DSSERR("failed to apply dispc config\n");
 			goto put_device;
 		}
 	}
@@ -416,7 +410,6 @@ static MANAGER_ATTR(cpr_coef, S_IRUGO|S_IWUSR,
 		manager_cpr_coef_show,
 		manager_cpr_coef_store);
 
-
 static struct attribute *manager_sysfs_attrs[] = {
 	&manager_attr_name.attr,
 	&manager_attr_display.attr,
@@ -1777,8 +1770,6 @@ static int omap_dss_mgr_blank(struct omap_overlay_manager *mgr,
 	int r, r_get, i;
 	bool update = false;
 
-	DSSDBG("omap_dss_mgr_blank(%s,wait=%d)\n", mgr->name, wait_for_go);
-
 	r_get = r = dispc_runtime_get();
 	/* still clear cache even if failed to get clocks, just don't config */
 
@@ -1802,7 +1793,6 @@ static int omap_dss_mgr_blank(struct omap_overlay_manager *mgr,
 
 		oc = &dss_cache.overlay_cache[ovl->id];
 
-
 		/* complete unconfigured info in cache */
 		if (ovl->info_dirty)
 			dss_ovl_cb(&ovl->info.cb, i,
@@ -1844,8 +1834,6 @@ static int omap_dss_mgr_blank(struct omap_overlay_manager *mgr,
 
 	if (!r_get) {
 		r = configure_dispc();
-		if (r)
-			pr_info("mgr_blank while GO is set");
 	}
 
 	if (r_get || !wait_for_go) {
@@ -1924,7 +1912,6 @@ static int omap_dss_mgr_apply(struct omap_overlay_manager *mgr)
 
 	spin_lock_irqsave(&dss_cache.lock, flags);
 
-
 	if (!mgr->device || (mgr->device->state != OMAP_DSS_DISPLAY_ACTIVE &&
 							!mgr->info.wb_only)) {
 		struct writeback_cache_data *wbc;
@@ -1947,8 +1934,6 @@ static int omap_dss_mgr_apply(struct omap_overlay_manager *mgr)
 			goto done;
 		}
 
-		pr_info_ratelimited("cannot apply mgr(%s) on inactive device\n",
-								mgr->name);
 		r = -ENODEV;
 		goto done;
 	}
diff --git a/drivers/video/omap2/dss/overlay.c b/drivers/video/omap2/dss/overlay.c
index 957e680..f86a757 100644
--- a/drivers/video/omap2/dss/overlay.c
+++ b/drivers/video/omap2/dss/overlay.c
@@ -603,13 +603,11 @@ int dss_check_overlay(struct omap_overlay *ovl, struct omap_dss_device *dssdev)
 	}
 
 	if ((ovl->supported_modes & info->color_mode) == 0) {
-		DSSERR("overlay doesn't support mode %d\n", info->color_mode);
 		return -EINVAL;
 	}
 
 	if ((info->zorder < OMAP_DSS_OVL_ZORDER_0) ||
 			(info->zorder > OMAP_DSS_OVL_ZORDER_3)) {
-		DSSERR("overlay doesn't support zorder %d\n", info->zorder);
 		return -EINVAL;
 	}
 
@@ -955,4 +953,3 @@ void dss_uninit_overlays(struct platform_device *pdev)
 
 	num_overlays = 0;
 }
-
diff --git a/drivers/video/omap2/dss/sdi.c b/drivers/video/omap2/dss/sdi.c
index 3a688c8..518c87d 100644
--- a/drivers/video/omap2/dss/sdi.c
+++ b/drivers/video/omap2/dss/sdi.c
@@ -92,14 +92,8 @@ int omapdss_sdi_display_enable(struct omap_dss_device *dssdev)
 
 	pck = fck / lck_div / pck_div / 1000;
 
-	if (pck != t->pixel_clock) {
-		DSSWARN("Could not find exact pixel clock. Requested %d kHz, "
-				"got %lu kHz\n",
-				t->pixel_clock, pck);
-
+	if (pck != t->pixel_clock)
 		t->pixel_clock = pck;
-	}
-
 
 	dispc_set_lcd_timings(dssdev->manager->id, t);
 
diff --git a/drivers/video/omap2/dsscomp/Kconfig b/drivers/video/omap2/dsscomp/Kconfig
index 991c69b..98f7dfb 100644
--- a/drivers/video/omap2/dsscomp/Kconfig
+++ b/drivers/video/omap2/dsscomp/Kconfig
@@ -10,7 +10,7 @@ menuconfig DSSCOMP
 
 config DSSCOMP_DEBUG_LOG
 	bool "Log event timestamps in debugfs"
-	default y
+	default n
 	depends on DEBUG_FS
 
 	help
diff --git a/drivers/video/omap2/dsscomp/base.c b/drivers/video/omap2/dsscomp/base.c
index 72a2199..e4ca616 100644
--- a/drivers/video/omap2/dsscomp/base.c
+++ b/drivers/video/omap2/dsscomp/base.c
@@ -327,47 +327,10 @@ int set_dss_ovl_info(struct dss2_ovl_info *oi)
 	info.max_y_decim = cfg->decim.max_y ? : 255;
 	info.min_x_decim = cfg->decim.min_x ? : 1;
 	info.min_y_decim = cfg->decim.min_y ? : 1;
-#if 0
-	info.pic_height = cfg->height;
-
-	info.field = 0;
-	if (cfg->ilace & OMAP_DSS_ILACE_SEQ)
-		info.field |= OMAP_FLAG_IBUF;
-	if (cfg->ilace & OMAP_DSS_ILACE_SWAP)
-		info.field |= OMAP_FLAG_ISWAP;
-	/*
-	 * Ignore OMAP_DSS_ILACE as there is no real support yet for
-	 * interlaced interleaved vs progressive buffers
-	 */
-	if (ovl->manager &&
-	    ovl->manager->device &&
-	    !strcmp(ovl->manager->device->name, "hdmi") &&
-	    is_hdmi_interlaced())
-		info.field |= OMAP_FLAG_IDEV;
-
-	info.out_wb = 0;
-#endif
 
 	info.cconv = cfg->cconv;
 
 done:
-#if 0
-	pr_debug("ovl%d: en=%d %x/%x (%dx%d|%d) => (%dx%d) @ (%d,%d) rot=%d "
-		"mir=%d col=%x z=%d al=%02x prem=%d pich=%d ilace=%d\n",
-		ovl->id, info.enabled, info.paddr, info.p_uv_addr, info.width,
-		info.height, info.screen_width, info.out_width, info.out_height,
-		info.pos_x, info.pos_y, info.rotation, info.mirror,
-		info.color_mode, info.zorder, info.global_alpha,
-		info.pre_mult_alpha, info.pic_height, info.field);
-#else
-	pr_debug("ovl%d: en=%d %x/%x (%dx%d|%d) => (%dx%d) @ (%d,%d) rot=%d "
-		"mir=%d col=%x z=%d al=%02x prem=%d\n",
-		ovl->id, info.enabled, info.paddr, info.p_uv_addr, info.width,
-		info.height, info.screen_width, info.out_width, info.out_height,
-		info.pos_x, info.pos_y, info.rotation, info.mirror,
-		info.color_mode, info.zorder, info.global_alpha,
-		info.pre_mult_alpha);
-#endif
 	/* set overlay info */
 	return ovl->set_overlay_info(ovl, &info);
 }
@@ -421,12 +384,6 @@ int set_dss_wb_info(struct dss2_ovl_info *oi)
 		info.rotation_type = OMAP_DSS_ROT_DMA;
 done:
 
-	pr_debug("Writeback: en=%d %x/%x (%dx%d => (%dx%d) "
-		"col=%x src=%d mode=%d capt=%d\n",
-		info.enabled, info.paddr, info.p_uv_addr, info.width,
-		info.height, info.out_width, info.out_height, info.dss_mode,
-		info.source, info.mode, info.capturemode);
-
 	/* set overlay info */
 	return wb->set_wb_info(wb, &info);
 }
@@ -518,21 +475,8 @@ void dump_ovl_info(struct dsscomp_dev *cdev, struct dss2_ovl_info *oi)
 
 	ci = get_color_info(c->color_mode);
 	if (c->zonly) {
-		dev_info(DEV(cdev), "ovl%d(%s z%d)\n",
-			c->ix, c->enabled ? "ON" : "off", c->zorder);
 		return;
 	}
-	dev_info(DEV(cdev), "ovl%d(%s z%d %s%s *%d%% %d*%d:%d,%d+%d,%d rot%d%s"
-						" => %d,%d+%d,%d %p/%p|%d)\n",
-		c->ix, c->enabled ? "ON" : "off", c->zorder,
-		ci->name ? : "(none)",
-		c->pre_mult_alpha ? " premult" : "",
-		(c->global_alpha * 100 + 128) / 255,
-		c->width, c->height, c->crop.x, c->crop.y,
-		c->crop.w, c->crop.h,
-		c->rotation, c->mirror ? "+mir" : "",
-		c->win.x, c->win.y, c->win.w, c->win.h,
-		(void *) oi->ba, (void *) oi->uv, c->stride);
 }
 
 static void print_mgr_info(struct dsscomp_dev *cdev,
@@ -552,11 +496,6 @@ void dump_comp_info(struct dsscomp_dev *cdev, struct dsscomp_setup_mgr_data *d,
 	if (!(debug & DEBUG_COMPOSITIONS))
 		return;
 
-	dev_info(DEV(cdev), "[%p] %s: %c%c%c ",
-		 *phase == 'q' ? (void *) d->sync_id : d, phase,
-		 (d->mode & DSSCOMP_SETUP_MODE_APPLY) ? 'A' : '-',
-		 (d->mode & DSSCOMP_SETUP_MODE_DISPLAY) ? 'D' : '-',
-		 (d->mode & DSSCOMP_SETUP_MODE_CAPTURE) ? 'C' : '-');
 	print_mgr_info(cdev, &d->mgr);
 	printk("n=%d\n", d->num_ovls);
 }
@@ -570,12 +509,6 @@ void dump_total_comp_info(struct dsscomp_dev *cdev,
 	if (!(debug & DEBUG_COMPOSITIONS))
 		return;
 
-	dev_info(DEV(cdev), "[%p] %s: %c%c%c ",
-		 *phase == 'q' ? (void *) d->sync_id : d, phase,
-		 (d->mode & DSSCOMP_SETUP_MODE_APPLY) ? 'A' : '-',
-		 (d->mode & DSSCOMP_SETUP_MODE_DISPLAY) ? 'D' : '-',
-		 (d->mode & DSSCOMP_SETUP_MODE_CAPTURE) ? 'C' : '-');
-
 	for (i = 0; i < d->num_mgrs && i < ARRAY_SIZE(d->mgrs); i++)
 		print_mgr_info(cdev, d->mgrs + i);
 	printk("n=%d\n", d->num_ovls);
diff --git a/drivers/video/omap2/dsscomp/device.c b/drivers/video/omap2/dsscomp/device.c
old mode 100755
new mode 100644
index c5fc946..a1c167d
--- a/drivers/video/omap2/dsscomp/device.c
+++ b/drivers/video/omap2/dsscomp/device.c
@@ -80,12 +80,8 @@ static u32 hwc_virt_to_phys(u32 arg)
 
 static void sync_drop(struct dsscomp_sync_obj *sync)
 {
-	if (sync && atomic_dec_and_test(&sync->refs)) {
-		if (debug & DEBUG_WAITS)
-			pr_info("free sync [%p]\n", sync);
-
+	if (sync && atomic_dec_and_test(&sync->refs))
 		kfree(sync);
-	}
 }
 
 static int sync_setup(const char *name, const struct file_operations *fops,
@@ -117,22 +113,12 @@ int dsscomp_wait(struct dsscomp_sync_obj *sync, enum dsscomp_wait_phase phase,
 								int timeout)
 {
 	mutex_lock(&wait_mtx);
-	if (debug & DEBUG_WAITS)
-		pr_info("wait %s on [%p]\n",
-			phase == DSSCOMP_WAIT_DISPLAYED ? "display" :
-			phase == DSSCOMP_WAIT_PROGRAMMED ? "program" :
-			"release", sync);
 
 	if (sync->state < phase) {
 		mutex_unlock(&wait_mtx);
 
 		timeout = wait_event_interruptible_timeout(waitq,
 			sync->state >= phase, timeout);
-		if (debug & DEBUG_WAITS)
-			pr_info("wait over [%p]: %s %d\n", sync,
-				 timeout < 0 ? "signal" :
-				 timeout > 0 ? "ok" : "timeout",
-				 timeout);
 		if (timeout <= 0)
 			return timeout ? : -ETIME;
 
@@ -257,9 +243,6 @@ static long setup_mgr(struct dsscomp_dev *cdev,
 	if (d->get_sync_obj) {
 		sync = kzalloc(sizeof(*sync), GFP_KERNEL);
 		r = sync_setup("dsscomp_sync", &sync_fops, sync, O_RDONLY);
-		if (sync && (debug & DEBUG_WAITS))
-			dev_info(DEV(cdev), "new sync [%p] on #%d\n", sync,
-								sync->fd);
 		if (r)
 			sync_drop(sync);
 	}
@@ -411,15 +394,11 @@ static void fill_cache(struct dsscomp_dev *cdev)
 			cdev->num_displays = i + 1;
 
 		cdev->displays[i] = dssdev;
-		dev_dbg(DEV(cdev), "display%lu=%s\n", i, dssdev->driver_name);
 
 		cdev->state_notifiers[i].notifier_call = dsscomp_state_notifier;
 		blocking_notifier_chain_register(&dssdev->state_notifiers,
 						cdev->state_notifiers + i);
 	}
-	dev_info(DEV(cdev), "found %d displays and %d overlays, WB overlay %d\n",
-				cdev->num_displays, cdev->num_ovls,
-				cdev->wb_ovl ? 1 : 0);
 }
 
 static void fill_platform_info(struct dsscomp_dev *cdev)
diff --git a/drivers/video/omap2/dsscomp/gralloc.c b/drivers/video/omap2/dsscomp/gralloc.c
index 726e53c..1838f7f 100644
--- a/drivers/video/omap2/dsscomp/gralloc.c
+++ b/drivers/video/omap2/dsscomp/gralloc.c
@@ -100,9 +100,6 @@ static void dsscomp_gralloc_cb(void *data, int status)
 		if (atomic_dec_and_test(&gsync->refs))
 			unpin_tiler_blocks(&gsync->slots);
 
-		log_event(0, 0, gsync, "--refs=%d on %s",
-				atomic_read(&gsync->refs),
-				(u32) log_status_str(status));
 	}
 
 	/* get completed list items in order, if any */
@@ -123,11 +120,6 @@ static void dsscomp_gralloc_cb(void *data, int status)
 
 	/* call back for completed composition with mutex unlocked */
 	list_for_each_entry_safe(gsync, gsync_, &done, q) {
-		if (debug & DEBUG_GRALLOC_PHASES)
-			dev_info(DEV(cdev), "[%p] completed flip\n", gsync);
-
-		log_event(0, 0, gsync, "calling %pf [%p]",
-				(u32) gsync->cb_fn, (u32) gsync->cb_arg);
 
 		if (gsync->cb_fn)
 			gsync->cb_fn(gsync->cb_arg, 1);
@@ -244,20 +236,11 @@ transfer_done:
 
 static void dsscomp_gralloc_do_clone(struct work_struct *work)
 {
-#ifdef CONFIG_DEBUG_FS
-	u32 ms1, ms2;
-#endif
 	struct dsscomp_clone_work *wk = container_of(work, typeof(*wk), work);
 
 	BUG_ON(wk->comp->state != DSSCOMP_STATE_ACTIVE);
-#ifdef CONFIG_DEBUG_FS
-	ms1 = ktime_to_ms(ktime_get());
-#endif
+
 	dsscomp_gralloc_transfer_dmabuf(wk->dma_cfg);
-#ifdef CONFIG_DEBUG_FS
-	ms2 = ktime_to_ms(ktime_get());
-	dev_info(DEV(cdev), "DMA latency(msec) = %d\n", ms2-ms1);
-#endif
 
 	wk->comp->state = DSSCOMP_STATE_APPLYING;
 	if (dsscomp_apply(wk->comp))
@@ -305,9 +288,6 @@ int dsscomp_gralloc_queue(struct dsscomp_setup_dispc_data *d,
 	u32 ovl_set_mask = 0;
 	struct tiler1d_slot *slot = NULL;
 	u32 slot_used = 0;
-#ifdef CONFIG_DEBUG_FS
-	u32 ms = ktime_to_ms(ktime_get());
-#endif
 	u32 channels[MAX_MANAGERS], ch;
 	int skip;
 	struct dsscomp_gralloc_t *gsync;
@@ -344,16 +324,9 @@ int dsscomp_gralloc_queue(struct dsscomp_setup_dispc_data *d,
 	gsync->early_callback = early_callback;
 	INIT_LIST_HEAD(&gsync->slots);
 	list_add_tail(&gsync->q, &flip_queue);
-	if (debug & DEBUG_GRALLOC_PHASES)
-		dev_info(DEV(cdev), "[%p] queuing flip\n", gsync);
-
-	log_event(0, ms, gsync, "new in %pf (refs=1)",
-			(u32) dsscomp_gralloc_queue, 0);
 
 	/* ignore frames while we are blanked */
 	skip = blanked;
-	if (skip && (debug & DEBUG_PHASES))
-		dev_info(DEV(cdev), "[%p,%08x] ignored\n", gsync, d->sync_id);
 
 	/* mark blank frame by NULL tiler pa pointer */
 	if (!skip && pas == NULL)
@@ -378,17 +351,13 @@ int dsscomp_gralloc_queue(struct dsscomp_setup_dispc_data *d,
 		if (d->mgrs[i].ix >= cdev->num_displays)
 			continue;
 		dev = cdev->displays[d->mgrs[i].ix];
-		if (!dev) {
-			dev_warn(DEV(cdev), "failed to get display%d\n",
-								d->mgrs[i].ix);
+		if (!dev)
 			continue;
-		}
+
 		mgr = dev->manager;
-		if (!mgr) {
-			dev_warn(DEV(cdev), "no manager for display%d\n",
-								d->mgrs[i].ix);
+		if (!mgr)
 			continue;
-		}
+
 		channels[i] = ch = mgr->id;
 		mgr_set_mask |= 1 << ch;
 
@@ -445,7 +414,6 @@ int dsscomp_gralloc_queue(struct dsscomp_setup_dispc_data *d,
 			 continue;
 		}
 
-
 		/* skip overlays on compositions we could not create */
 		ch = channels[j];
 		if (!comp[ch])
@@ -454,7 +422,6 @@ int dsscomp_gralloc_queue(struct dsscomp_setup_dispc_data *d,
 		if (oi->addressing == OMAP_DSS_BUFADDR_OVL_IX) {
 			unsigned int j = oi->ba;
 			if (j >= i) {
-				WARN(1, "Invalid clone layer (%u)", j);
 				goto skip_buffer;
 			}
 
@@ -470,7 +437,6 @@ int dsscomp_gralloc_queue(struct dsscomp_setup_dispc_data *d,
 			if (fb_ix >= num_registered_fb ||
 			    (oi->cfg.color_mode == OMAP_DSS_COLOR_NV12 &&
 			     fb_uv_ix >= num_registered_fb)) {
-				WARN(1, "display has no framebuffer");
 				goto skip_buffer;
 			}
 
@@ -481,7 +447,6 @@ int dsscomp_gralloc_queue(struct dsscomp_setup_dispc_data *d,
 			if (size + oi->ba > fbi->fix.smem_len ||
 			    (oi->cfg.color_mode == OMAP_DSS_COLOR_NV12 &&
 			     (size >> 1) + oi->uv > fbi_uv->fix.smem_len)) {
-				WARN(1, "image outside of framebuffer memory");
 				goto skip_buffer;
 			}
 
@@ -507,11 +472,9 @@ int dsscomp_gralloc_queue(struct dsscomp_setup_dispc_data *d,
 			goto skip_map1d;
 
 		if (!slot) {
-			if (down_timeout(&free_slots_sem,
-						msecs_to_jiffies(100))) {
-				dev_warn(DEV(cdev), "could not obtain tiler slot");
+			if (down_timeout(&free_slots_sem, msecs_to_jiffies(100)))
 				goto skip_buffer;
-			}
+
 			mutex_lock(&mtx);
 			slot = list_first_entry(&free_slots, typeof(*slot), q);
 			list_move(&slot->q, &gsync->slots);
@@ -582,8 +545,6 @@ skip_map1d:
 		comp[ch]->extra_cb = dsscomp_gralloc_cb;
 		comp[ch]->extra_cb_data = gsync;
 		atomic_inc(&gsync->refs);
-		log_event(0, ms, gsync, "++refs=%d for [%p]",
-				atomic_read(&gsync->refs), (u32) comp[ch]);
 
 		if (ch == 1 && clone_wq && phys) {
 			/* start work-queue */
@@ -645,8 +606,6 @@ static void dsscomp_early_suspend(struct early_suspend *h)
 
 	int err, mgr_ix;
 
-	pr_info("DSSCOMP: %s\n", __func__);
-
 	/*dsscomp_gralloc_queue() expects all blanking mgrs set up in comp */
 	for (mgr_ix = 0 ; mgr_ix < cdev->num_mgrs ; mgr_ix++) {
 		struct omap_dss_device *dssdev = cdev->mgrs[mgr_ix]->device;
@@ -664,15 +623,10 @@ static void dsscomp_early_suspend(struct early_suspend *h)
 	/* wait until composition is displayed */
 	err = wait_event_timeout(early_suspend_wq, blank_complete,
 				 msecs_to_jiffies(500));
-	if (err == 0)
-		pr_warn("DSSCOMP: timeout blanking screen\n");
-	else
-		pr_info("DSSCOMP: blanked screen\n");
 }
 
 static void dsscomp_late_resume(struct early_suspend *h)
 {
-	pr_info("DSSCOMP: %s\n", __func__);
 	blanked = false;
 }
 
@@ -689,8 +643,9 @@ void dsscomp_dbg_gralloc(struct seq_file *s)
 	struct dsscomp_gralloc_t *g;
 	struct tiler1d_slot *t;
 	dsscomp_t c;
+#ifdef CONFIG_DSSCOMP_DEBUG_LOG
 	int i;
-
+#endif
 	mutex_lock(&dbg_mtx);
 	seq_printf(s, "ACTIVE GRALLOC FLIPS\n\n");
 	list_for_each_entry(g, &flip_queue, q) {
diff --git a/drivers/video/omap2/dsscomp/queue.c b/drivers/video/omap2/dsscomp/queue.c
index c70a5a3..5017dc8 100644
--- a/drivers/video/omap2/dsscomp/queue.c
+++ b/drivers/video/omap2/dsscomp/queue.c
@@ -406,9 +406,6 @@ void dsscomp_drop(dsscomp_t comp)
 		maskref_decmask(&mgrq[comp->ix].ovl_qmask, comp->ovl_mask);
 	comp->state = 0;
 
-	if (debug & DEBUG_COMPOSITIONS)
-		dev_info(DEV(cdev), "[%p] released\n", comp);
-
 	DO_IF_DEBUG_FS(list_del(&comp->dbg_q));
 
 	kfree(comp);
@@ -442,20 +439,13 @@ static void dsscomp_mgr_delayed_cb(struct work_struct *work)
 		mgrq[ix].ovl_mask = comp->ovl_mask & ~comp->ovl_dmask;
 		maskref_decmask(&mgrq[ix].ovl_qmask, comp->ovl_mask);
 
-		if (debug & DEBUG_PHASES)
-			dev_info(DEV(cdev), "[%p] programmed\n", comp);
 	} else if ((status == DSS_COMPLETION_DISPLAYED) &&
 		   comp->state == DSSCOMP_STATE_PROGRAMMED) {
 		/* composition is 1st displayed */
 		comp->state = DSSCOMP_STATE_DISPLAYED;
 		log_state(comp, dsscomp_mgr_delayed_cb, status);
-		if (debug & DEBUG_PHASES)
-			dev_info(DEV(cdev), "[%p] displayed\n", comp);
 	} else if (status & DSS_COMPLETION_RELEASED) {
 		/* composition is no longer displayed */
-		log_event(20 * comp->ix + 20, 0, comp, "%pf on %s",
-				(u32) dsscomp_mgr_delayed_cb,
-				(u32) log_status_str(status));
 		dsscomp_drop(comp);
 	}
 	mutex_unlock(&mtx);
@@ -474,8 +464,7 @@ u32 dsscomp_mgr_callback(void *data, int id, int status)
 		/* allocate work object from cache */
 		wk = kmem_cache_zalloc(dsscomp_cb_wk_cachep, GFP_ATOMIC);
 		if (!wk) {
-			pr_err("DSSCOMP: %s: can't allocate cache object\n",
-								__func__);
+			pr_err("DSSCOMP: %s: can't allocate cache object\n", __func__);
 			BUG();
 		}
 
@@ -565,13 +554,6 @@ int dsscomp_apply(dsscomp_t comp)
 
 			wb = omap_dss_get_wb(0);
 			wb->get_wb_info(wb, &wb_info);
-			/* if prev comp was with M2M WB */
-			if (wb_info.mode == OMAP_WB_MEM2MEM_MODE &&
-							wb_info.enabled) {
-				if (wb->wait_framedone(wb))
-					dev_warn(DEV(cdev),
-						"WB Framedone expired\n");
-			}
 
 			/* if wb is disabled and wb was enabled in prev
 			 * comp - set m2m flag. */
@@ -622,23 +604,15 @@ int dsscomp_apply(dsscomp_t comp)
 				mutex_lock(&mtx);
 				if (!mgrq[comp->ix].blanking || m2m_mgr_mode) {
 					/*
-					 * Ideally, we should call
-					 * ovl->unset_manager(ovl),
-					 * but it may block on go
-					 * even though the disabling
-					 * of the overlay already
-					 * went through. So instead,
+					 * Ideally, we should call ovl->unset_manager(ovl),
+					 * but it may block on go even though the disabling
+					 * of the overlay already went through. So instead,
 					 * we are just clearing the manager.
 					 */
 					ovl->manager = NULL;
 					r = ovl->set_manager(ovl, mgr);
 				} else	{
-					/* Ignoring manager change
-					during blanking. */
-					pr_info_ratelimited("dsscomp_apply "
-						"skip set_manager(%s) for "
-						"ovl%d while blank."
-						, mgr->name, oi->cfg.ix);
+					/* Ignoring manager change during blanking. */
 					r = -ENODEV;
 				}
 				mutex_unlock(&mtx);
@@ -673,9 +647,6 @@ skip_ovl_set:
 		dev_err(DEV(cdev), "[%p] set failed %d\n", comp, r);
 		goto done;
 	} else {
-		if (r)
-			dev_warn(DEV(cdev), "[%p] ignoring set failure %d\n",
-								comp, r);
 		comp->blank = dmask == comp->ovl_mask;
 		comp->ovl_dmask = dmask;
 
@@ -738,8 +709,6 @@ skip_ovl_set:
 
 	mutex_lock(&mtx);
 	if (mgrq[comp->ix].blanking && !m2m_mgr_mode) {
-		pr_info_ratelimited("ignoring apply mgr(%s) while blanking\n",
-								mgr->name);
 		r = -ENODEV;
 	} else {
 		if (wb_apply) {
@@ -849,11 +818,8 @@ int dsscomp_delayed_apply(dsscomp_t comp)
 
 	/* allocate work object from cache */
 	wk = kmem_cache_zalloc(dsscomp_app_wk_cachep, GFP_NOWAIT);
-	if (!wk) {
-		pr_warn("DSSCOMP: %s: can't allocate object from cache\n",
-								__func__);
+	if (!wk)
 		return -ENOMEM;
-	}
 
 	mutex_lock(&mtx);
 
@@ -861,8 +827,6 @@ int dsscomp_delayed_apply(dsscomp_t comp)
 	comp->state = DSSCOMP_STATE_APPLYING;
 	log_state(comp, dsscomp_delayed_apply, 0);
 
-	if (debug & DEBUG_PHASES)
-		dev_info(DEV(cdev), "[%p] applying\n", comp);
 	mutex_unlock(&mtx);
 
 	wk->comp = comp;
diff --git a/drivers/video/omap2/hdcp/hdcp_top.c b/drivers/video/omap2/hdcp/hdcp_top.c
index 29ffda0..10dc02d 100644
--- a/drivers/video/omap2/hdcp/hdcp_top.c
+++ b/drivers/video/omap2/hdcp/hdcp_top.c
@@ -36,7 +36,6 @@ struct hdcp hdcp;
 struct hdcp_sha_in sha_input;
 
 /* State machine / workqueue */
-/*static void hdcp_wq_disable(void);*/ /*temporary commenting*/
 static void hdcp_wq_start_authentication(void);
 static void hdcp_wq_check_r0(void);
 static void hdcp_wq_step2_authentication(void);
@@ -110,22 +109,6 @@ static void hdcp_release_dss(void)
 #endif
 }
 
-/* commenting this func as we r not using it currently */
-#if 0
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_disable
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_disable(void)
-{
-	printk(KERN_INFO "HDCP: disabled\n");
-
-	hdcp_cancel_work(&hdcp.pending_wq_event);
-	hdcp_lib_disable();
-	hdcp.pending_disable = 0;
-}
-#endif
-
 /*-----------------------------------------------------------------------------
  * Function: hdcp_wq_start_authentication
  *-----------------------------------------------------------------------------
diff --git a/drivers/video/omap2/omapfb/Kconfig b/drivers/video/omap2/omapfb/Kconfig
index d4c5d83..369e85f 100644
--- a/drivers/video/omap2/omapfb/Kconfig
+++ b/drivers/video/omap2/omapfb/Kconfig
@@ -41,4 +41,3 @@ config FB_OMAP2_VSYNC_SYSFS
 	depends on FB_OMAP2
 	help
 	  Pass vsync via sysfs to userspace.
-
diff --git a/drivers/video/omap2/omapfb/omapfb-ioctl.c b/drivers/video/omap2/omapfb/omapfb-ioctl.c
index 26d4b35..3d0fe69 100644
--- a/drivers/video/omap2/omapfb/omapfb-ioctl.c
+++ b/drivers/video/omap2/omapfb/omapfb-ioctl.c
@@ -67,8 +67,6 @@ static int omapfb_setup_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)
 	struct omapfb2_mem_region *old_rg, *new_rg;
 	int r = 0;
 
-	DBG("omapfb_setup_plane\n");
-
 	if (ofbi->num_overlays != 1) {
 		r = -EINVAL;
 		goto out;
@@ -510,10 +508,8 @@ static int omapfb_memory_read(struct fb_info *fbi,
 		return -EINVAL;
 
 	buf = vmalloc(mr->buffer_size);
-	if (!buf) {
-		DBG("vmalloc failed\n");
+	if (!buf)
 		return -ENOMEM;
-	}
 
 	r = display->driver->memory_read(display, buf, mr->buffer_size,
 			mr->x, mr->y, mr->w, mr->h);
@@ -617,7 +613,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 
 	switch (cmd) {
 	case OMAPFB_SYNC_GFX:
-		DBG("ioctl SYNC_GFX\n");
 		if (!display || !display->driver->sync) {
 			/* DSS1 never returns an error here, so we neither */
 			/*r = -EINVAL;*/
@@ -628,7 +623,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_UPDATE_WINDOW_OLD:
-		DBG("ioctl UPDATE_WINDOW_OLD\n");
 		if (!display || !display->driver->update) {
 			r = -EINVAL;
 			break;
@@ -646,7 +640,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_UPDATE_WINDOW:
-		DBG("ioctl UPDATE_WINDOW\n");
 		if (!display || !display->driver->update) {
 			r = -EINVAL;
 			break;
@@ -663,7 +656,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_SETUP_PLANE:
-		DBG("ioctl SETUP_PLANE\n");
 		if (copy_from_user(&p.plane_info, (void __user *)arg,
 					sizeof(p.plane_info)))
 			r = -EFAULT;
@@ -672,7 +664,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_QUERY_PLANE:
-		DBG("ioctl QUERY_PLANE\n");
 		r = omapfb_query_plane(fbi, &p.plane_info);
 		if (r < 0)
 			break;
@@ -682,7 +673,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_SETUP_MEM:
-		DBG("ioctl SETUP_MEM\n");
 		if (copy_from_user(&p.mem_info, (void __user *)arg,
 					sizeof(p.mem_info)))
 			r = -EFAULT;
@@ -691,7 +681,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_QUERY_MEM:
-		DBG("ioctl QUERY_MEM\n");
 		r = omapfb_query_mem(fbi, &p.mem_info);
 		if (r < 0)
 			break;
@@ -701,7 +690,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_GET_CAPS:
-		DBG("ioctl GET_CAPS\n");
 		if (!display) {
 			r = -EINVAL;
 			break;
@@ -718,7 +706,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_GET_OVERLAY_COLORMODE:
-		DBG("ioctl GET_OVERLAY_COLORMODE\n");
 		if (copy_from_user(&p.ovl_colormode, (void __user *)arg,
 				   sizeof(p.ovl_colormode))) {
 			r = -EFAULT;
@@ -733,7 +720,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_SET_UPDATE_MODE:
-		DBG("ioctl SET_UPDATE_MODE\n");
 		if (get_user(p.update_mode, (int __user *)arg))
 			r = -EFAULT;
 		else
@@ -741,7 +727,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_GET_UPDATE_MODE:
-		DBG("ioctl GET_UPDATE_MODE\n");
 		r = omapfb_get_update_mode(fbi, &p.update_mode);
 		if (r)
 			break;
@@ -751,7 +736,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_SET_COLOR_KEY:
-		DBG("ioctl SET_COLOR_KEY\n");
 		if (copy_from_user(&p.color_key, (void __user *)arg,
 				   sizeof(p.color_key)))
 			r = -EFAULT;
@@ -760,7 +744,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_GET_COLOR_KEY:
-		DBG("ioctl GET_COLOR_KEY\n");
 		r = omapfb_get_color_key(fbi, &p.color_key);
 		if (r)
 			break;
@@ -781,7 +764,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		/* FALLTHROUGH */
 
 	case OMAPFB_WAITFORVSYNC:
-		DBG("ioctl WAITFORVSYNC\n");
 		if (!display) {
 			r = -EINVAL;
 			break;
@@ -791,7 +773,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_WAITFORGO:
-		DBG("ioctl WAITFORGO\n");
 		if (!display) {
 			r = -EINVAL;
 			break;
@@ -803,7 +784,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 	/* LCD and CTRL tests do the same thing for backward
 	 * compatibility */
 	case OMAPFB_LCD_TEST:
-		DBG("ioctl LCD_TEST\n");
 		if (get_user(p.test_num, (int __user *)arg)) {
 			r = -EFAULT;
 			break;
@@ -818,7 +798,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_CTRL_TEST:
-		DBG("ioctl CTRL_TEST\n");
 		if (get_user(p.test_num, (int __user *)arg)) {
 			r = -EFAULT;
 			break;
@@ -833,7 +812,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		break;
 
 	case OMAPFB_MEMORY_READ:
-		DBG("ioctl MEMORY_READ\n");
 
 		if (copy_from_user(&p.memory_read, (void __user *)arg,
 					sizeof(p.memory_read))) {
@@ -848,8 +826,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 	case OMAPFB_GET_VRAM_INFO: {
 		unsigned long vram, free, largest;
 
-		DBG("ioctl GET_VRAM_INFO\n");
-
 		omap_vram_get_info(&vram, &free, &largest);
 		p.vram_info.total = vram;
 		p.vram_info.free = free;
@@ -862,7 +838,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 	}
 
 	case OMAPFB_SET_TEARSYNC: {
-		DBG("ioctl SET_TEARSYNC\n");
 
 		if (copy_from_user(&p.tearsync_info, (void __user *)arg,
 					sizeof(p.tearsync_info))) {
@@ -885,8 +860,6 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		u16 xres, yres;
 		u32 w, h;
 
-		DBG("ioctl GET_DISPLAY_INFO\n");
-
 		if (display == NULL) {
 			r = -ENODEV;
 			break;
@@ -922,8 +895,7 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 			else
 				r = -EBUSY;
 		else
-			omapfb_enable_vsync(fbdev, display->channel,
-					false);
+			omapfb_enable_vsync(fbdev, display->channel, false);
 
 		omapfb_unlock(fbdev);
 		break;
@@ -933,10 +905,5 @@ int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 		r = -EINVAL;
 	}
 
-	if (r < 0)
-		DBG("ioctl failed: %d\n", r);
-
 	return r;
 }
-
-
diff --git a/drivers/video/omap2/omapfb/omapfb-main.c b/drivers/video/omap2/omapfb/omapfb-main.c
index e5bbe55..9b2253f 100644
--- a/drivers/video/omap2/omapfb/omapfb-main.c
+++ b/drivers/video/omap2/omapfb/omapfb-main.c
@@ -83,9 +83,6 @@ static int initialize_dev_fb_resolution(u16 display_ix,
 
 	pfb_opt = (struct fb_options *)&fb_opt[display_ix*ELEMENT_COUNT];
 
-	DBG("cmd line dev ix %d - W %d - H %d\n",
-		pfb_opt->ix, pfb_opt->width , pfb_opt->height);
-
 	if (pfb_opt->ix != -1) {
 		dssdev->panel.fb_xres = pfb_opt->width;
 		dssdev->panel.fb_yres = pfb_opt->height;
@@ -93,8 +90,6 @@ static int initialize_dev_fb_resolution(u16 display_ix,
 		dssdev->panel.fb_xres = dssdev->panel.timings.x_res;
 		dssdev->panel.fb_yres = dssdev->panel.timings.y_res;
 	}
-	DBG("init dev %s dev-%d:w-%d:h-%d\n", dssdev->name, display_ix,
-			dssdev->panel.fb_xres, dssdev->panel.fb_yres);
 	return 0;
 }
 
@@ -102,7 +97,6 @@ void get_fb_resolution(struct omap_dss_device *dssdev, u16 *xres, u16 *yres)
 {
 	*xres = dssdev->panel.fb_xres;
 	*yres = dssdev->panel.fb_yres;
-	DBG("%s %s %d x %d", __func__, dssdev->name, *xres, *yres);
 	return;
 }
 
@@ -466,7 +460,6 @@ static int check_fb_res_bounds(struct fb_var_screeninfo *var)
 static void shrink_height(unsigned long max_frame_size,
 		struct fb_var_screeninfo *var)
 {
-	DBG("can't fit FB into memory, reducing y\n");
 	var->yres_virtual = max_frame_size /
 		(var->xres_virtual * var->bits_per_pixel >> 3);
 
@@ -480,7 +473,6 @@ static void shrink_height(unsigned long max_frame_size,
 static void shrink_width(unsigned long max_frame_size,
 		struct fb_var_screeninfo *var)
 {
-	DBG("can't fit FB into memory, reducing x\n");
 	var->xres_virtual = max_frame_size / var->yres_virtual /
 		(var->bits_per_pixel >> 3);
 
@@ -515,15 +507,12 @@ static int check_fb_size(const struct omapfb_info *ofbi,
 				line_size, var);
 
 		if (check_vrfb_fb_size(max_frame_size, var)) {
-			DBG("cannot fit FB to memory\n");
 			return -EINVAL;
 		}
 
 		return 0;
 	}
 
-	DBG("max frame size %lu, line size %lu\n", max_frame_size, line_size);
-
 	if (line_size * var->yres_virtual > max_frame_size)
 		shrink_height(max_frame_size, var);
 
@@ -533,7 +522,6 @@ static int check_fb_size(const struct omapfb_info *ofbi,
 	}
 
 	if (line_size * var->yres_virtual > max_frame_size) {
-		DBG("cannot fit FB to memory\n");
 		return -EINVAL;
 	}
 
@@ -563,8 +551,6 @@ static int setup_vrfb_rotation(struct fb_info *fbi)
 	if (!rg->size || ofbi->rotation_type != OMAP_DSS_ROT_VRFB)
 		return 0;
 
-	DBG("setup_vrfb_rotation\n");
-
 	r = omapfb_mode_to_dss_mode(var, &mode);
 	if (r)
 		return r;
@@ -594,7 +580,6 @@ static int setup_vrfb_rotation(struct fb_info *fbi)
 		fix->smem_len = 0;
 		iounmap(vrfb->vaddr[0]);
 		vrfb->vaddr[0] = NULL;
-		DBG("setup_vrfb_rotation: reset fb\n");
 	}
 
 	if (vrfb->vaddr[0])
@@ -654,8 +639,6 @@ void set_fb_fix(struct fb_info *fbi)
 	struct omapfb_info *ofbi = FB2OFB(fbi);
 	struct omapfb2_mem_region *rg = ofbi->region;
 
-	DBG("set_fb_fix\n");
-
 	/* used by open/write in fbmem.c */
 	fbi->screen_base = (char __iomem *)omapfb_get_region_vaddr(ofbi);
 
@@ -721,19 +704,13 @@ int check_fb_var(struct fb_info *fbi, struct fb_var_screeninfo *var)
 	int r;
 	u32 w = 0, h = 0;
 
-	DBG("check_fb_var %d\n", ofbi->id);
-
-	WARN_ON(!atomic_read(&ofbi->region->lock_count));
-
 	r = omapfb_mode_to_dss_mode(var, &mode);
 	if (r) {
-		DBG("cannot convert var to omap dss mode\n");
 		return r;
 	}
 
 	for (i = 0; i < ofbi->num_overlays; ++i) {
 		if ((ofbi->overlays[i]->supported_modes & mode) == 0) {
-			DBG("invalid mode\n");
 			return -EINVAL;
 		}
 	}
@@ -753,10 +730,6 @@ int check_fb_var(struct fb_info *fbi, struct fb_var_screeninfo *var)
 	if (var->yres + var->yoffset > var->yres_virtual)
 		var->yoffset = var->yres_virtual - var->yres;
 
-	DBG("xres = %d, yres = %d, vxres = %d, vyres = %d\n",
-			var->xres, var->yres,
-			var->xres_virtual, var->yres_virtual);
-
 	if (display)
 		omapdss_display_get_dimensions(display, &w, &h);
 
@@ -801,7 +774,6 @@ int check_fb_var(struct fb_info *fbi, struct fb_var_screeninfo *var)
 	return 0;
 }
 
-
 bool check_fb_scale(struct omap_dss_device *dssdev)
 {
 	u16 fb_w, fb_h , pn_w , pn_h;
@@ -915,12 +887,6 @@ static void omapfb_calc_addr(const struct omapfb_info *ofbi,
 	data_start_p += offset;
 	data_start_v += offset;
 
-	if (offset)
-		DBG("offset %d, %d = %d\n",
-		    var->xoffset, var->yoffset, offset);
-
-	DBG("paddr %x, vaddr %p\n", data_start_p, data_start_v);
-
 	*paddr = data_start_p;
 	*vaddr = data_start_v;
 }
@@ -943,8 +909,6 @@ int omapfb_setup_overlay(struct fb_info *fbi, struct omap_overlay *ovl,
 	int rotation = var->rotate;
 	int i;
 
-	WARN_ON(!atomic_read(&ofbi->region->lock_count));
-
 	for (i = 0; i < ofbi->num_overlays; i++) {
 		if (ovl != ofbi->overlays[i])
 			continue;
@@ -953,9 +917,6 @@ int omapfb_setup_overlay(struct fb_info *fbi, struct omap_overlay *ovl,
 		break;
 	}
 
-	DBG("setup_overlay %d, posx %d, posy %d, outw %d, outh %d\n", ofbi->id,
-			posx, posy, outw, outh);
-
 	if (rotation == FB_ROTATE_CW || rotation == FB_ROTATE_CCW) {
 		xres = var->yres;
 		yres = var->xres;
@@ -969,10 +930,8 @@ int omapfb_setup_overlay(struct fb_info *fbi, struct omap_overlay *ovl,
 				 &data_start_p, &data_start_v);
 
 	r = omapfb_mode_to_dss_mode(var, &mode);
-	if (r) {
-		DBG("omapfb_mode_to_dss_mode failed");
+	if (r)
 		goto err;
-	}
 
 	switch (var->nonstd) {
 	case OMAPFB_COLOR_YUV422:
@@ -1010,15 +969,12 @@ int omapfb_setup_overlay(struct fb_info *fbi, struct omap_overlay *ovl,
 	info.out_height = outh;
 
 	r = ovl->set_overlay_info(ovl, &info);
-	if (r) {
-		DBG("ovl->setup_overlay_info failed\n");
+	if (r)
 		goto err;
-	}
 
 	return 0;
 
 err:
-	DBG("setup_overlay failed\n");
 	return r;
 }
 
@@ -1044,8 +1000,6 @@ int omapfb_apply_changes(struct fb_info *fbi, int init)
 	for (i = 0; i < ofbi->num_overlays; i++) {
 		ovl = ofbi->overlays[i];
 
-		DBG("apply_changes, fb %d, ovl %d\n", ofbi->id, ovl->id);
-
 		if (ofbi->region->size == 0) {
 			/* the fb is not available. disable the overlay */
 			omapfb_overlay_enable(ovl, 0);
@@ -1106,7 +1060,6 @@ int omapfb_apply_changes(struct fb_info *fbi, int init)
 	}
 	return 0;
 err:
-	DBG("apply_changes failed\n");
 	return r;
 }
 
@@ -1117,8 +1070,6 @@ static int omapfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
 	struct omapfb_info *ofbi = FB2OFB(fbi);
 	int r;
 
-	DBG("check_var(%d)\n", FB2OFB(fbi)->id);
-
 	omapfb_get_mem_region(ofbi->region);
 
 	r = check_fb_var(fbi, var);
@@ -1169,8 +1120,6 @@ static int omapfb_set_par(struct fb_info *fbi)
 	struct omapfb_info *ofbi = FB2OFB(fbi);
 	int r;
 
-	DBG("set_par(%d)\n", FB2OFB(fbi)->id);
-
 	omapfb_get_mem_region(ofbi->region);
 
 	set_fb_fix(fbi);
@@ -1194,8 +1143,6 @@ static int omapfb_pan_display(struct fb_var_screeninfo *var,
 	struct fb_var_screeninfo new_var;
 	int r;
 
-	DBG("pan_display(%d)\n", FB2OFB(fbi)->id);
-
 	if (var->xoffset == fbi->var.xoffset &&
 	    var->yoffset == fbi->var.yoffset)
 		return 0;
@@ -1265,8 +1212,6 @@ static int omapfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
 
 	off += start;
 
-	DBG("user mmap region start %lx, len %d, off %lx\n", start, len, off);
-
 	vma->vm_pgoff = off >> PAGE_SHIFT;
 	vma->vm_flags |= VM_IO | VM_RESERVED;
 	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
@@ -1351,8 +1296,6 @@ static int _setcolreg(struct fb_info *fbi, u_int regno, u_int red, u_int green,
 static int omapfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
 		u_int transp, struct fb_info *info)
 {
-	DBG("setcolreg\n");
-
 	return _setcolreg(info, regno, red, green, blue, transp, 1);
 }
 
@@ -1362,8 +1305,6 @@ static int omapfb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
 	u16 *red, *green, *blue, *transp;
 	u16 trans = 0xffff;
 
-	DBG("setcmap\n");
-
 	red     = cmap->red;
 	green   = cmap->green;
 	blue    = cmap->blue;
@@ -1440,17 +1381,6 @@ exit:
 	return r;
 }
 
-#if 0
-/* XXX fb_read and fb_write are needed for VRFB */
-ssize_t omapfb_write(struct fb_info *info, const char __user *buf,
-		size_t count, loff_t *ppos)
-{
-	DBG("omapfb_write %d, %lu\n", count, (unsigned long)*ppos);
-	/* XXX needed for VRFB */
-	return count;
-}
-#endif
-
 static struct fb_ops omapfb_ops = {
 	.owner          = THIS_MODULE,
 	.fb_open        = omapfb_open,
@@ -1477,8 +1407,6 @@ static void omapfb_free_fbmem(struct fb_info *fbi)
 
 	rg = ofbi->region;
 
-	WARN_ON(atomic_read(&rg->map_count));
-
 	if (rg->paddr)
 		if (omap_vram_free(rg->paddr, rg->size))
 			dev_err(fbdev->dev, "VRAM FREE failed\n");
@@ -1512,8 +1440,6 @@ static int omapfb_free_all_fbmem(struct omapfb2_device *fbdev)
 {
 	int i;
 
-	DBG("free all fbmem\n");
-
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct fb_info *fbi = fbdev->fbs[i];
 		omapfb_free_fbmem(fbi);
@@ -1545,11 +1471,8 @@ static int omapfb_alloc_fbmem(struct fb_info *fbi, unsigned long size,
 	size = PAGE_ALIGN(size);
 
 	if (!paddr) {
-		DBG("allocating %lu bytes for fb %d\n", size, ofbi->id);
 		r = omap_vram_alloc(OMAP_VRAM_MEMTYPE_SDRAM, size, &paddr);
 	} else {
-		DBG("reserving %lu bytes at %lx for fb %d\n", size, paddr,
-				ofbi->id);
 		r = omap_vram_reserve(paddr, size);
 	}
 
@@ -1567,7 +1490,6 @@ static int omapfb_alloc_fbmem(struct fb_info *fbi, unsigned long size,
 			return -ENOMEM;
 		}
 
-		DBG("allocated VRAM paddr %lx, vaddr %p\n", paddr, vaddr);
 	} else {
 		r = omap_vrfb_request_ctx(&rg->vrfb);
 		if (r) {
@@ -1620,8 +1542,6 @@ static int omapfb_alloc_fbmem_display(struct fb_info *fbi, unsigned long size,
 			size = max(omap_vrfb_min_phys_size(w, h, bytespp),
 					omap_vrfb_min_phys_size(h, w, bytespp));
 
-			DBG("adjusting fb mem size for VRFB, %u -> %lu\n",
-					w * h * bytespp, size);
 		} else {
 			size = w * h * bytespp;
 		}
@@ -1793,12 +1713,6 @@ static int omapfb_allocate_all_fbs(struct omapfb2_device *fbdev)
 		struct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);
 		struct omapfb2_mem_region *rg;
 		rg = ofbi->region;
-
-		DBG("region%d phys %08x virt %p size=%lu\n",
-				i,
-				rg->paddr,
-				rg->vaddr,
-				rg->size);
 	}
 
 	return 0;
@@ -1849,17 +1763,12 @@ int omapfb_realloc_fbmem(struct fb_info *fbi, unsigned long size, int type)
 		return 0;
 
 	if (old_size == 0) {
-		DBG("initializing fb %d\n", ofbi->id);
 		r = omapfb_fb_init(fbdev, fbi);
-		if (r) {
-			DBG("omapfb_fb_init failed\n");
+		if (r)
 			goto err;
-		}
 		r = omapfb_apply_changes(fbi, 1);
-		if (r) {
-			DBG("omapfb_apply_changes failed\n");
+		if (r)
 			goto err;
-		}
 	} else {
 		struct fb_var_screeninfo new_var;
 		memcpy(&new_var, &fbi->var, sizeof(new_var));
@@ -1991,13 +1900,10 @@ static void fbinfo_cleanup(struct omapfb2_device *fbdev, struct fb_info *fbi)
 	fb_dealloc_cmap(&fbi->cmap);
 }
 
-
 static void omapfb_free_resources(struct omapfb2_device *fbdev)
 {
 	int i;
 
-	DBG("free_resources\n");
-
 	if (fbdev == NULL)
 		return;
 
@@ -2029,8 +1935,6 @@ static int omapfb_create_framebuffers(struct omapfb2_device *fbdev)
 
 	fbdev->num_fbs = 0;
 
-	DBG("create %d framebuffers\n",	CONFIG_FB_OMAP2_NUM_FBS);
-
 	/* allocate fb_infos */
 	for (i = 0; i < CONFIG_FB_OMAP2_NUM_FBS; i++) {
 		struct fb_info *fbi;
@@ -2065,8 +1969,6 @@ static int omapfb_create_framebuffers(struct omapfb2_device *fbdev)
 		fbdev->num_fbs++;
 	}
 
-	DBG("fb_infos allocated\n");
-
 	/* assign overlays for the fbs */
 	for (i = 0; i < min(fbdev->num_fbs, fbdev->num_overlays); i++) {
 		struct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);
@@ -2082,8 +1984,6 @@ static int omapfb_create_framebuffers(struct omapfb2_device *fbdev)
 		return r;
 	}
 
-	DBG("fbmems allocated\n");
-
 	/* setup fb_infos */
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct fb_info *fbi = fbdev->fbs[i];
@@ -2099,19 +1999,14 @@ static int omapfb_create_framebuffers(struct omapfb2_device *fbdev)
 		}
 	}
 
-	DBG("fb_infos initialized\n");
-
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		r = register_framebuffer(fbdev->fbs[i]);
 		if (r != 0) {
-			dev_err(fbdev->dev,
-				"registering framebuffer %d failed\n", i);
+			dev_err(fbdev->dev, "registering framebuffer %d failed\n", i);
 			return r;
 		}
 	}
 
-	DBG("framebuffers registered\n");
-
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct fb_info *fbi = fbdev->fbs[i];
 		struct omapfb_info *ofbi = FB2OFB(fbi);
@@ -2136,15 +2031,12 @@ static int omapfb_create_framebuffers(struct omapfb2_device *fbdev)
 			r = omapfb_overlay_enable(ovl, 1);
 
 			if (r) {
-				dev_err(fbdev->dev,
-						"failed to enable overlay\n");
+				dev_err(fbdev->dev,	"failed to enable overlay\n");
 				return r;
 			}
 		}
 	}
 
-	DBG("create_framebuffers done\n");
-
 	return 0;
 }
 
@@ -2449,10 +2341,8 @@ int omapfb_enable_vsync(struct omapfb2_device *fbdev, enum omap_channel ch,
 				masks[ch]);
 	return r;
 
-
 }
 
-
 static int omapfb_probe(struct platform_device *pdev)
 {
 	struct omapfb2_device *fbdev = NULL;
@@ -2463,8 +2353,6 @@ static int omapfb_probe(struct platform_device *pdev)
 	struct omap_dss_device *dssdev;
 	u16 fb_ov_start_ix = 0;
 
-	DBG("omapfb_probe\n");
-
 	if (pdev->num_resources != 0) {
 		dev_err(&pdev->dev, "probed for an unknown device\n");
 		r = -ENODEV;
@@ -2486,7 +2374,6 @@ static int omapfb_probe(struct platform_device *pdev)
 				"ignoring the module parameter vrfb=y\n");
 	}
 
-
 	mutex_init(&fbdev->mtx);
 
 	fbdev->dev = &pdev->dev;
@@ -2553,12 +2440,8 @@ static int omapfb_probe(struct platform_device *pdev)
 		struct omap_overlay_manager *mgr;
 		mgr = fbdev->managers[i];
 		r = mgr->apply(mgr);
-		if (r)
-			dev_warn(fbdev->dev, "failed to apply dispc config\n");
 	}
 
-	DBG("mgr->apply'ed\n");
-
 	if (def_display) {
 		r = omapfb_init_display(fbdev, def_display);
 		if (r) {
@@ -2571,7 +2454,6 @@ static int omapfb_probe(struct platform_device *pdev)
 
 	sec_getlog_supply_fbinfo(fbdev->fbs[0]);
 
-	DBG("create sysfs for fbs\n");
 	r = omapfb_create_sysfs(fbdev);
 	if (r) {
 		dev_err(fbdev->dev, "failed to create sysfs entries\n");
@@ -2621,8 +2503,6 @@ static struct platform_driver omapfb_driver = {
 
 static int __init omapfb_init(void)
 {
-	DBG("omapfb_init\n");
-
 	if (platform_driver_register(&omapfb_driver)) {
 		printk(KERN_ERR "failed to register omapfb driver\n");
 		return -ENODEV;
@@ -2633,7 +2513,6 @@ static int __init omapfb_init(void)
 
 static void __exit omapfb_exit(void)
 {
-	DBG("omapfb_exit\n");
 	platform_driver_unregister(&omapfb_driver);
 }
 
diff --git a/drivers/video/omap2/omapfb/omapfb-sysfs.c b/drivers/video/omap2/omapfb/omapfb-sysfs.c
index 2f5e817..9922e35 100644
--- a/drivers/video/omap2/omapfb/omapfb-sysfs.c
+++ b/drivers/video/omap2/omapfb/omapfb-sysfs.c
@@ -88,7 +88,6 @@ out:
 	return r ? r : count;
 }
 
-
 static ssize_t show_mirror(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -273,8 +272,6 @@ static ssize_t store_overlays(struct device *dev, struct device_attribute *attr,
 		if (found)
 			continue;
 
-		DBG("detaching %d\n", ofbi->overlays[i]->id);
-
 		omapfb_get_mem_region(ofbi->region);
 
 		omapfb_overlay_enable(ovl, 0);
@@ -535,7 +532,6 @@ int omapfb_create_sysfs(struct omapfb2_device *fbdev)
 	int i;
 	int r;
 
-	DBG("create sysfs for fbs\n");
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		int t;
 		for (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++) {
@@ -557,11 +553,9 @@ void omapfb_remove_sysfs(struct omapfb2_device *fbdev)
 {
 	int i, t;
 
-	DBG("remove sysfs for fbs\n");
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		for (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++)
 			device_remove_file(fbdev->fbs[i]->dev,
 					&omapfb_attrs[t]);
 	}
 }
-
diff --git a/drivers/video/omap2/omaplfb/omaplfb_bv.c b/drivers/video/omap2/omaplfb/omaplfb_bv.c
old mode 100755
new mode 100644
index c13196c..74de269
--- a/drivers/video/omap2/omaplfb/omaplfb_bv.c
+++ b/drivers/video/omap2/omaplfb/omaplfb_bv.c
@@ -65,56 +65,13 @@ static void print_bvparams(struct bvbltparams *bltparams,
                            unsigned int pSrc1DescInfo, unsigned int pSrc2DescInfo)
 {
 	struct bvphysdesc *physdesc = NULL;
-	if (bltparams->flags & BVFLAG_BLEND)
-	{
-		printk(KERN_INFO "%s: param %s %x (%s), flags %ld\n",
-			"bv", "blend", bltparams->op.blend,
-			bltparams->op.blend == BVBLEND_SRC1OVER ? "src1over" : "??",
-			bltparams->flags);
-	}
-
-	if (bltparams->flags & BVFLAG_ROP)
-	{
-		printk(KERN_INFO "%s: param %s %x (%s), flags %ld\n",
-			"bv", "rop", bltparams->op.rop,
-			bltparams->op.rop == 0xCCCC ? "srccopy" : "??",
-			bltparams->flags);
-	}
 
 	if (bltparams->dstdesc->auxtype == BVAT_PHYSDESC)
 		physdesc = bltparams->dstdesc->auxptr;
 
-	printk(KERN_INFO "%s: dst %d,%d rect{%d,%d sz %d,%d}"
-		" stride %ld desc 0x%p\n", "bv",
-		bltparams->dstgeom->width,
-		bltparams->dstgeom->height,
-		bltparams->dstrect.left, bltparams->dstrect.top,
-		bltparams->dstrect.width, bltparams->dstrect.height,
-		bltparams->dstgeom->virtstride,
-		physdesc ? physdesc->pagearray : NULL);
-
-	printk(KERN_INFO "%s: src1 %d,%d rect{%d,%d sz %d,%d}"
-		" stride %ld, %s 0x%x (0x%x)\n", "bv",
-		bltparams->src1geom->width,
-		bltparams->src1geom->height, bltparams->src1rect.left,
-		bltparams->src1rect.top, bltparams->src1rect.width,
-		bltparams->src1rect.height, bltparams->src1geom->virtstride,
-		bltparams->src1.desc->auxtype == BVAT_PHYSDESC ? "phys" : "unk",
-		bltparams->src1.desc->auxtype == BVAT_PHYSDESC ? (unsigned int)bltparams->src1.desc : 0,
-		pSrc1DescInfo);
-
 	if (!(bltparams->flags & BVFLAG_BLEND))
 		return;
 
-	printk(KERN_INFO "%s: src2 %d,%d rect{%d,%d sz %d,%d}"
-		" stride %ld, %s 0x%x (0x%x)\n", "bv",
-		bltparams->src2geom->width,
-		bltparams->src2geom->height, bltparams->src2rect.left,
-		bltparams->src2rect.top, bltparams->src2rect.width,
-		bltparams->src2rect.height, bltparams->src2geom->virtstride,
-		bltparams->src2.desc->auxtype == BVAT_PHYSDESC ? "phys" : "unk",
-		bltparams->src2.desc->auxtype == BVAT_PHYSDESC ? (unsigned int)bltparams->src2.desc : 0,
-		pSrc2DescInfo);
 }
 
 void OMAPLFBGetBltFBsBvHndl(OMAPLFB_FBINFO *psPVRFBInfo, IMG_UINTPTR_T *ppPhysAddr)
@@ -231,8 +188,6 @@ static OMAPLFB_ERROR InitBltFBsVram(OMAPLFB_DEVINFO *psDevInfo)
 		iBvErr = gsBvInterface.bv_map(pBvDesc);
 		if (iBvErr)
 		{
-			WARN(1, "%s: BV map Blt FB buffer failed %d\n",
-					__func__, iBvErr);
 			kfree(pBvDesc);
 			kfree(pBvPhysDesc);
 			kfree(pPaddrs);
@@ -273,9 +228,6 @@ static PVRSRV_ERROR InitBltFBsMapTiler2D(OMAPLFB_DEVINFO *psDevInfo)
 				wpages * h * sizeof(*pPageList),
 		                GFP_KERNEL);
 		if ( !pPageList) {
-			printk(KERN_WARNING DRIVER_PREFIX
-					": %s: Could not allocate page list\n",
-					__FUNCTION__);
 			return OMAPLFB_ERROR_INIT_FAILURE;
 		}
 		tilview_create(&view, phys, psLINFBInfo->var.xres, h);
@@ -302,7 +254,6 @@ static PVRSRV_ERROR InitBltFBsMapTiler2D(OMAPLFB_DEVINFO *psDevInfo)
 
 		if (eBvErr)
 		{
-			WARN(1, "%s: BV map blt buffer failed %d\n",__func__, eBvErr);
 			psPVRFBInfo->psBltFBsBvHndl[iFB]= NULL;
 			kfree(pBvDesc);
 			kfree(pBvPhysDesc);
@@ -351,14 +302,9 @@ static OMAPLFB_ERROR InitBltFBsTiler2D(OMAPLFB_DEVINFO *psDevInfo)
 	sAllocData.h = h;
 	sAllocData.w = psPVRFBInfo->psBltFBsNo * w;
 
-	printk(KERN_INFO DRIVER_PREFIX
-		":BltFBs alloc %d x (%d x %d) [stride %d]\n",
-		psPVRFBInfo->psBltFBsNo, w, h, psPVRFBInfo->uiBltFBsByteStride);
 	res = omap_ion_nonsecure_tiler_alloc(gpsIONClient, &sAllocData);
 	if (res < 0)
 	{
-		printk(KERN_ERR DRIVER_PREFIX
-			"Could not allocate BltFBs\n");
 		return OMAPLFB_ERROR_INIT_FAILURE;
 	}
 
@@ -376,12 +322,10 @@ static struct bvbuffdesc *GetBvDescriptor(OMAPLFB_DEVINFO *psDevInfo, PDC_MEM_IN
 {
 	struct bvbuffdesc *pBvDesc;
 	if (!meminfo_idx_valid(ui32Idx, ui32NumMemInfos)) {
-		WARN(1, "%s: index out of range\n", __func__);
 		return NULL;
 	}
 
 	psDevInfo->sPVRJTable.pfnPVRSRVDCMemInfoGetBvHandle(ppsMemInfos[ui32Idx], (IMG_VOID**)&pBvDesc);
-	WARN(!pBvDesc, "%s: null handle\n", __func__);
 	return pBvDesc;
 }
 
@@ -440,8 +384,6 @@ void OMAPLFBDoBlits(OMAPLFB_DEVINFO *psDevInfo, PDC_MEM_INFO *ppsMemInfos, struc
 			}
 			else
 			{
-				WARN(1, "%s: Unable to determine scr1 buffer\n",
-						__func__);
 				continue;
 			}
 		}
@@ -475,8 +417,6 @@ void OMAPLFBDoBlits(OMAPLFB_DEVINFO *psDevInfo, PDC_MEM_INFO *ppsMemInfos, struc
 				}
 				else
 				{
-					WARN(1, "%s: Unable to determine scr2 buffer\n",
-							__func__);
 					continue;
 				}
 			}
diff --git a/drivers/video/omap2/omaplfb/omaplfb_displayclass.c b/drivers/video/omap2/omaplfb/omaplfb_displayclass.c
old mode 100755
new mode 100644
index b874233..91b712a
--- a/drivers/video/omap2/omaplfb/omaplfb_displayclass.c
+++ b/drivers/video/omap2/omaplfb/omaplfb_displayclass.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright (C) Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -204,25 +204,19 @@ static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 uiPVRDevID,
 	}
 	if (i == uiMaxFBDevIDPlusOne)
 	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
-			": %s: PVR Device %u not found\n", __FUNCTION__, uiPVRDevID));
 		return PVRSRV_ERROR_INVALID_DEVICE;
 	}
 
-	
 	psDevInfo->sSystemBuffer.psSyncData = psSystemBufferSyncData;
-	
+
 	eError = OMAPLFBUnblankDisplay(psDevInfo);
 	if (eError != OMAPLFB_OK)
 	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
-			": %s: Device %u: OMAPLFBUnblankDisplay failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, eError));
 		return PVRSRV_ERROR_UNBLANK_DISPLAY_FAILED;
 	}
 
-	
 	*phDevice = (IMG_HANDLE)psDevInfo;
-	
+
 	return PVRSRV_OK;
 }
 
@@ -244,16 +238,16 @@ static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
                                   DISPLAY_FORMAT *psFormat)
 {
 	OMAPLFB_DEVINFO	*psDevInfo;
-	
+
 	if(!hDevice || !pui32NumFormats)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	
+
 	*pui32NumFormats = 1;
-	
+
 	if(psFormat)
 	{
 		psFormat[0] = psDevInfo->sDisplayFormat;
@@ -262,7 +256,7 @@ static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice, 
+static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice,
                                DISPLAY_FORMAT *psFormat,
                                IMG_UINT32 *pui32NumDims,
                                DISPLAY_DIMS *psDim)
@@ -278,20 +272,18 @@ static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice,
 
 	*pui32NumDims = 1;
 
-	
 	if(psDim)
 	{
 		psDim[0] = psDevInfo->sDisplayDim;
 	}
-	
+
 	return PVRSRV_OK;
 }
 
-
 static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE *phBuffer)
 {
 	OMAPLFB_DEVINFO	*psDevInfo;
-	
+
 	if(!hDevice || !phBuffer)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
@@ -304,11 +296,10 @@ static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE *phBuffer)
 	return PVRSRV_OK;
 }
 
-
 static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO *psDCInfo)
 {
 	OMAPLFB_DEVINFO	*psDevInfo;
-	
+
 	if(!hDevice || !psDCInfo)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
@@ -322,7 +313,7 @@ static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO *psDCInfo)
 }
 
 static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE        hDevice,
-                                    IMG_HANDLE        hBuffer, 
+                                    IMG_HANDLE        hBuffer,
                                     IMG_SYS_PHYADDR   **ppsSysAddr,
                                     IMG_UINT32        *pui32ByteSize,
                                     IMG_VOID          **ppvCpuVAddr,
@@ -405,8 +396,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	PVRSRV_ERROR eError;
 
 	UNREFERENCED_PARAMETER(ui32OEMFlags);
-	
-	
+
 	if(!hDevice
 	|| !psDstSurfAttrib
 	|| !psSrcSurfAttrib
@@ -417,8 +407,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	}
 
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
-	
-	
+
 	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0)
 	{
 		return PVRSRV_ERROR_NOT_SUPPORTED;
@@ -426,55 +415,46 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 
 	OMAPLFBCreateSwapChainLock(psDevInfo);
 
-	
 	if(psDevInfo->psSwapChain != NULL)
 	{
 		eError = PVRSRV_ERROR_FLIP_CHAIN_EXISTS;
 		goto ExitUnLock;
 	}
-	
-	
+
 	if(ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers)
 	{
 		eError = PVRSRV_ERROR_TOOMANYBUFFERS;
 		goto ExitUnLock;
 	}
-	
+
 	if ((psDevInfo->sFBInfo.ulRoundedBufferSize * (unsigned long)ui32BufferCount) > psDevInfo->sFBInfo.ulFBSize)
 	{
 		eError = PVRSRV_ERROR_TOOMANYBUFFERS;
 		goto ExitUnLock;
 	}
-	
+
 	if(psDstSurfAttrib->pixelformat != psDevInfo->sDisplayFormat.pixelformat
 	|| psDstSurfAttrib->sDims.ui32ByteStride != psDevInfo->sDisplayDim.ui32ByteStride
 	|| psDstSurfAttrib->sDims.ui32Width != psDevInfo->sDisplayDim.ui32Width
 	|| psDstSurfAttrib->sDims.ui32Height != psDevInfo->sDisplayDim.ui32Height)
 	{
-		
+
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 		goto ExitUnLock;
-	}		
+	}
 
 	if(psDstSurfAttrib->pixelformat != psSrcSurfAttrib->pixelformat
 	|| psDstSurfAttrib->sDims.ui32ByteStride != psSrcSurfAttrib->sDims.ui32ByteStride
 	|| psDstSurfAttrib->sDims.ui32Width != psSrcSurfAttrib->sDims.ui32Width
 	|| psDstSurfAttrib->sDims.ui32Height != psSrcSurfAttrib->sDims.ui32Height)
 	{
-		
+
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 		goto ExitUnLock;
-	}		
+	}
 
 	UNREFERENCED_PARAMETER(ui32Flags);
-	
-#if defined(PVR_OMAPFB3_UPDATE_MODE)
-	if (!OMAPLFBSetUpdateMode(psDevInfo, PVR_OMAPFB3_UPDATE_MODE))
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't set frame buffer update mode %d\n", __FUNCTION__, psDevInfo->uiFBDevID, PVR_OMAPFB3_UPDATE_MODE);
-	}
-#endif
-	
+
 	psSwapChain = (OMAPLFB_SWAPCHAIN*)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_SWAPCHAIN));
 	if(!psSwapChain)
 	{
@@ -494,12 +474,11 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	psSwapChain->bNotVSynced = OMAPLFB_TRUE;
 	psSwapChain->uiFBDevID = psDevInfo->uiFBDevID;
 
-	
 	for(i=0; i<ui32BufferCount-1; i++)
 	{
 		psBuffer[i].psNext = &psBuffer[i+1];
 	}
-	
+
 	psBuffer[i].psNext = &psBuffer[0];
 
 	for(i=0; i<ui32BufferCount; i++)
@@ -525,10 +504,8 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 		psBuffer[i].bvmap_handle = NULL;
 	}
 
-
 	if (OMAPLFBCreateSwapQueue(psSwapChain) != OMAPLFB_OK)
-	{ 
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Failed to create workqueue\n", __FUNCTION__, psDevInfo->uiFBDevID);
+	{
 		eError = PVRSRV_ERROR_UNABLE_TO_INSTALL_ISR;
 		goto ErrorFreeBuffers;
 	}
@@ -536,7 +513,6 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
 	if (OMAPLFBEnableLFBEventNotification(psDevInfo)!= OMAPLFB_OK)
 	{
 		eError = PVRSRV_ERROR_UNABLE_TO_ENABLE_EVENT;
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't enable framebuffer event notification\n", __FUNCTION__, psDevInfo->uiFBDevID);
 		goto ErrorDestroySwapQueue;
 	}
 
@@ -574,12 +550,12 @@ static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
 	OMAPLFB_DEVINFO	*psDevInfo;
 	OMAPLFB_SWAPCHAIN *psSwapChain;
 	OMAPLFB_ERROR eError;
-	
+
 	if(!hDevice || !hSwapChain)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
-	
+
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
 	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
 
@@ -587,21 +563,13 @@ static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
 
 	if (SwapChainHasChanged(psDevInfo, psSwapChain))
 	{
-		printk(KERN_WARNING DRIVER_PREFIX
-			": %s: Device %u: Swap chain mismatch\n", __FUNCTION__, psDevInfo->uiFBDevID);
-
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 		goto ExitUnLock;
 	}
 
-	
 	OMAPLFBDestroySwapQueue(psSwapChain);
 
 	eError = OMAPLFBDisableLFBEventNotification(psDevInfo);
-	if (eError != OMAPLFB_OK)
-	{
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't disable framebuffer event notification\n", __FUNCTION__, psDevInfo->uiFBDevID);
-	}
 
 	OMAPLFBDeInitBltFBs(psDevInfo);
 	gbBvReady = IMG_FALSE;
@@ -631,8 +599,6 @@ static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
 	UNREFERENCED_PARAMETER(hSwapChain);
 	UNREFERENCED_PARAMETER(psRect);
 
-	
-	
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
@@ -644,8 +610,6 @@ static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
 	UNREFERENCED_PARAMETER(hSwapChain);
 	UNREFERENCED_PARAMETER(psRect);
 
-	
-
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
@@ -657,8 +621,6 @@ static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
 	UNREFERENCED_PARAMETER(hSwapChain);
 	UNREFERENCED_PARAMETER(ui32CKColour);
 
-	
-
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
@@ -670,8 +632,6 @@ static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
 	UNREFERENCED_PARAMETER(hSwapChain);
 	UNREFERENCED_PARAMETER(ui32CKColour);
 
-	
-
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
@@ -684,16 +644,15 @@ static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
 	OMAPLFB_SWAPCHAIN *psSwapChain;
 	PVRSRV_ERROR eError;
 	unsigned i;
-	
-	
-	if(!hDevice 
+
+	if(!hDevice
 	|| !hSwapChain
 	|| !pui32BufferCount
 	|| !phBuffer)
 	{
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
-	
+
 	psDevInfo = (OMAPLFB_DEVINFO*)hDevice;
 	psSwapChain = (OMAPLFB_SWAPCHAIN*)hSwapChain;
 
@@ -701,22 +660,17 @@ static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
 
 	if (SwapChainHasChanged(psDevInfo, psSwapChain))
 	{
-		printk(KERN_WARNING DRIVER_PREFIX
-			": %s: Device %u: Swap chain mismatch\n", __FUNCTION__, psDevInfo->uiFBDevID);
-
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 		goto Exit;
 	}
-	
-	
+
 	*pui32BufferCount = (IMG_UINT32)psSwapChain->ulBufferCount;
-	
-	
+
 	for(i=0; i<psSwapChain->ulBufferCount; i++)
 	{
 		phBuffer[i] = (IMG_HANDLE)&psSwapChain->psBuffer[i];
 	}
-	
+
 	eError = PVRSRV_OK;
 
 Exit:
@@ -738,8 +692,6 @@ static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
 	UNREFERENCED_PARAMETER(hPrivateTag);
 	UNREFERENCED_PARAMETER(ui32ClipRectCount);
 	UNREFERENCED_PARAMETER(psClipRect);
-	
-	
 
 	return PVRSRV_OK;
 }
@@ -798,7 +750,6 @@ void OMAPLFBSwapHandler(OMAPLFB_BUFFER *psBuffer)
 	bPreviouslyNotVSynced = psSwapChain->bNotVSynced;
 	psSwapChain->bNotVSynced = OMAPLFB_TRUE;
 
-
 	if (!DontWaitForVSync(psDevInfo))
 	{
 		OMAPLFB_UPDATE_MODE eMode = OMAPLFBGetUpdateMode(psDevInfo);
@@ -836,7 +787,6 @@ void OMAPLFBSwapHandler(OMAPLFB_BUFFER *psBuffer)
 
 #if defined(CONFIG_DSSCOMP)
 
-
 static void dsscomp_proxy_cmdcomplete(void * cookie, int i)
 {
 	gapsDevInfo[0]->sPVRJTable.pfnPVRSRVCmdComplete(cookie, i);
@@ -850,12 +800,9 @@ static IMG_BOOL ProcessFlipV1(IMG_HANDLE hCmdCookie,
 							  unsigned long ulSwapInterval)
 {
 	OMAPLFBCreateSwapChainLock(psDevInfo);
-	
+
 	if (SwapChainHasChanged(psDevInfo, psSwapChain))
 	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX
-			": %s: Device %u (PVR Device ID %u): The swap chain has been destroyed\n",
-			__FUNCTION__, psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID));
 	}
 	else
 	{
@@ -904,8 +851,6 @@ static IMG_BOOL ProcessFlipV1(IMG_HANDLE hCmdCookie,
 int meminfo_idx_valid(unsigned int meminfo_ix, int num_meminfos)
 {
 	if (meminfo_ix < 0 || meminfo_ix >= num_meminfos) {
-		WARN(1, "%s: Invalid meminfo index %d, max %d\n",
-				__func__, meminfo_ix, num_meminfos);
 		return 0;
 	}
 	return 1;
@@ -943,21 +888,18 @@ static IMG_BOOL ProcessFlipV2(IMG_HANDLE hCmdCookie,
 	else
 		rgz_items = psHwcData->blit_data.rgz_items;
 
-
 	psDssData = &(psHwcData->dsscomp_data);
 	calcsz = sizeof(*psHwcData) +
 		(sizeof(struct rgz_blt_entry) * rgz_items);
 	iUseBltFB = psHwcData->blit_data.rgz_flags & HWC_BLT_FLAG_USE_FB;
 
 	if (!iUseBltFB && rgz_items > 0) {
-		WARN(1, "Trying to blit without a pipe configured for the blit FB");
 		return IMG_FALSE;
 	}
 
 	if (rgz_items > 0 && !gbBvInterfacePresent)
 	{
 		/* We cannot blit if BV GC2D is not present!, likely a bug */
-		WARN(1, "Trying to blit when BV GC2D is not present");
 		rgz_items = 0; /* Prevent blits */
 	}
 
@@ -966,7 +908,6 @@ static IMG_BOOL ProcessFlipV2(IMG_HANDLE hCmdCookie,
 		/* Defer allocation and mapping of blit buffers */
 		if (OMAPLFBInitBltFBs(psDevInfo) != OMAPLFB_OK)
 		{
-			WARN(1, "Could not initialize blit FBs");
 			return IMG_FALSE;
 		}
 
@@ -976,15 +917,9 @@ static IMG_BOOL ProcessFlipV2(IMG_HANDLE hCmdCookie,
 	memset(asMemInfo, 0, sizeof(asMemInfo));
 
 	/* Check the size of private data along with the blit operations */
-	if (uiHwcDataSz != calcsz)
-	{
-		WARN(1, "invalid size of private data (%d vs %d)",
-		     uiHwcDataSz, calcsz);
-	}
 
 	if (ui32NumMemInfos == 0)
 	{
-		WARN(1, "must have at least one layer");
 		return IMG_FALSE;
 	}
 
@@ -1087,7 +1022,6 @@ static IMG_BOOL ProcessFlipV2(IMG_HANDLE hCmdCookie,
 		ix = psDssData->ovls[i].ba;
 		if (ix >= k)
 		{
-			WARN(1, "Invalid Post2 layer (%u)", ix);
 			psDssData->ovls[i].cfg.enabled = false;
 			continue;
 		}
@@ -1201,7 +1135,7 @@ static OMAPLFB_ERROR OMAPLFBInitIonOmap(OMAPLFB_DEVINFO *psDevInfo,
         {
 		printk(KERN_ERR DRIVER_PREFIX
 			" %s: Could not create ion client\n", __FUNCTION__);
-                return OMAPLFB_ERROR_INIT_FAILURE;
+        return OMAPLFB_ERROR_INIT_FAILURE;
         }
 #endif /* defined(CONFIG_ION_OMAP) */
 
@@ -1209,9 +1143,6 @@ static OMAPLFB_ERROR OMAPLFBInitIonOmap(OMAPLFB_DEVINFO *psDevInfo,
 	{
 		/* Set a default swap chain length if it's not present in the platform data */
 		iMaxSwapChainBuffs = 2;
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Swap chain length missing in "
-			"platform data, defaulting to %d\n", __FUNCTION__, psDevInfo->uiFBDevID,
-			iMaxSwapChainBuffs);
 	}
 	else
 	{
@@ -1220,18 +1151,12 @@ static OMAPLFB_ERROR OMAPLFBInitIonOmap(OMAPLFB_DEVINFO *psDevInfo,
 
 	if (psFBPlatConfig->tiler2d_buffers < iMaxSwapChainBuffs)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Trying to use %d tiler "
-			"buffers which is less than the swap chain length of %d, maximum "
-			"swap chain length will be set to %d\n", __FUNCTION__, psDevInfo->uiFBDevID,
-			psFBPlatConfig->tiler2d_buffers, iMaxSwapChainBuffs, psFBPlatConfig->tiler2d_buffers);
 		iMaxSwapChainBuffs = psFBPlatConfig->tiler2d_buffers;
 	}
 
 	psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = iMaxSwapChainBuffs;
 	n = psFBPlatConfig->tiler2d_buffers;
 
-	printk(KERN_DEBUG DRIVER_PREFIX
-		": %s: Device %u: Requesting %d TILER 2D framebuffers\n", __FUNCTION__, uiFBDevID, n);
 	sAllocData.w *= n;
 
 	psPVRFBInfo->uiBytesPerPixel = psLINFBInfo->var.bits_per_pixel >> 3;
@@ -1260,7 +1185,6 @@ static OMAPLFB_ERROR OMAPLFBInitIonOmap(OMAPLFB_DEVINFO *psDevInfo,
 	psPVRFBInfo->psPageList = kzalloc(w * n * psPVRFBInfo->ulHeight * sizeof(*psPVRFBInfo->psPageList), GFP_KERNEL);
 	if (!psPVRFBInfo->psPageList)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Could not allocate page list\n", __FUNCTION__, psDevInfo->uiFBDevID);
 		ion_free(gpsIONClient, sAllocData.handle);
 		return OMAPLFB_ERROR_INIT_FAILURE;
 	}
@@ -1308,9 +1232,6 @@ static OMAPLFB_ERROR OMAPLFBInitFBVRAM(OMAPLFB_DEVINFO *psDevInfo,
 	{
 		/* Set a default swap chain length if it's not present in the platform data */
 		iMaxSwapChainBuffs = 2;
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Swap chain length missing in "
-			"platform data, defaulting to %d\n", __FUNCTION__, psDevInfo->uiFBDevID,
-			iMaxSwapChainBuffs);
 	}
 	else
 	{
@@ -1319,10 +1240,6 @@ static OMAPLFB_ERROR OMAPLFBInitFBVRAM(OMAPLFB_DEVINFO *psDevInfo,
 
 	if (psFBPlatConfig->vram_buffers < iMaxSwapChainBuffs)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Trying to use %d vram "
-			"buffers which is less than the swap chain length of %d, maximum "
-			"swap chain length will be set to %d\n", __FUNCTION__, psDevInfo->uiFBDevID,
-			psFBPlatConfig->vram_buffers, iMaxSwapChainBuffs, psFBPlatConfig->vram_buffers);
 		iMaxSwapChainBuffs = psFBPlatConfig->vram_buffers;
 	}
 
@@ -1347,10 +1264,6 @@ static OMAPLFB_ERROR OMAPLFBInitFBVRAM(OMAPLFB_DEVINFO *psDevInfo,
 	}
 	else if (ui32FBAvailableBuffs < psFBPlatConfig->vram_buffers)
 	{
-		printk(KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Not enough vram to hold "
-			"%d buffers (available %d), swap chain length will be set to %d\n",
-			__FUNCTION__, psDevInfo->uiFBDevID, iMaxSwapChainBuffs, ui32FBAvailableBuffs,
-			ui32FBAvailableBuffs);
 		iMaxSwapChainBuffs = ui32FBAvailableBuffs;
 	}
 	else
@@ -1360,19 +1273,6 @@ static OMAPLFB_ERROR OMAPLFBInitFBVRAM(OMAPLFB_DEVINFO *psDevInfo,
 
 	psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = iMaxSwapChainBuffs;
 
-	printk(KERN_DEBUG DRIVER_PREFIX ": %s: Device %u: Using %d VRAM framebuffers\n", __FUNCTION__,
-		psDevInfo->uiFBDevID, iMaxSwapChainBuffs);
-
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: Framebuffer virtual width: %u\n",
-			psDevInfo->uiFBDevID, psLINFBInfo->var.xres_virtual));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: Framebuffer virtual height: %u\n",
-			psDevInfo->uiFBDevID, psLINFBInfo->var.yres_virtual));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: LCM of stride and page size: %lu\n",
-			psDevInfo->uiFBDevID, ulLCM));
-
 	return OMAPLFB_OK;
 }
 
@@ -1397,9 +1297,6 @@ static OMAPLFB_ERROR OMAPLFBInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 	psLINFBOwner = psLINFBInfo->fbops->owner;
 	if (!try_module_get(psLINFBOwner))
 	{
-		printk(KERN_INFO DRIVER_PREFIX
-			": %s: Device %u: Couldn't get framebuffer module\n", __FUNCTION__, uiFBDevID);
-
 		goto ErrorRelSem;
 	}
 
@@ -1410,9 +1307,6 @@ static OMAPLFB_ERROR OMAPLFBInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 		res = psLINFBInfo->fbops->fb_open(psLINFBInfo, 0);
 		if (res != 0)
 		{
-			printk(KERN_INFO DRIVER_PREFIX
-				" %s: Device %u: Couldn't open framebuffer(%d)\n", __FUNCTION__, uiFBDevID, res);
-
 			goto ErrorModPut;
 		}
 	}
@@ -1452,62 +1346,32 @@ static OMAPLFB_ERROR OMAPLFBInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 	}
 
 	OMAPLFBPrintInfo(psDevInfo);
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: Framebuffer physical address: %p\n",
-			psDevInfo->uiFBDevID, (void *)psPVRFBInfo->sSysAddr.uiAddr));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: Framebuffer virtual address: %p\n",
-			psDevInfo->uiFBDevID, (void *)psPVRFBInfo->sCPUVAddr));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: Framebuffer size: %lu\n",
-			psDevInfo->uiFBDevID, psPVRFBInfo->ulFBSize));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: Framebuffer width: %lu\n",
-			psDevInfo->uiFBDevID, psPVRFBInfo->ulWidth));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: Framebuffer height: %lu\n",
-			psDevInfo->uiFBDevID, psPVRFBInfo->ulHeight));
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			": Device %u: Framebuffer stride: %lu\n",
-			psDevInfo->uiFBDevID, psPVRFBInfo->ulByteStride));
 
 	if(psLINFBInfo->var.bits_per_pixel == 16)
 	{
 		if((psLINFBInfo->var.red.length == 5) &&
-			(psLINFBInfo->var.green.length == 6) && 
-			(psLINFBInfo->var.blue.length == 5) && 
+			(psLINFBInfo->var.green.length == 6) &&
+			(psLINFBInfo->var.blue.length == 5) &&
 			(psLINFBInfo->var.red.offset == 11) &&
-			(psLINFBInfo->var.green.offset == 5) && 
-			(psLINFBInfo->var.blue.offset == 0) && 
+			(psLINFBInfo->var.green.offset == 5) &&
+			(psLINFBInfo->var.blue.offset == 0) &&
 			(psLINFBInfo->var.red.msb_right == 0))
 		{
 			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_RGB565;
 		}
-		else
-		{
-			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
-		}
 	}
 	else if(psLINFBInfo->var.bits_per_pixel == 32)
 	{
 		if((psLINFBInfo->var.red.length == 8) &&
-			(psLINFBInfo->var.green.length == 8) && 
-			(psLINFBInfo->var.blue.length == 8) && 
+			(psLINFBInfo->var.green.length == 8) &&
+			(psLINFBInfo->var.blue.length == 8) &&
 			(psLINFBInfo->var.red.offset == 16) &&
-			(psLINFBInfo->var.green.offset == 8) && 
-			(psLINFBInfo->var.blue.offset == 0) && 
+			(psLINFBInfo->var.green.offset == 8) &&
+			(psLINFBInfo->var.blue.offset == 0) &&
 			(psLINFBInfo->var.red.msb_right == 0))
 		{
 			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_ARGB8888;
 		}
-		else
-		{
-			printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
-		}
-	}	
-	else
-	{
-		printk(KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unknown FB format\n", __FUNCTION__, uiFBDevID);
 	}
 
 	psDevInfo->sFBInfo.ulPhysicalWidthmm =
@@ -1516,7 +1380,6 @@ static OMAPLFB_ERROR OMAPLFBInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 	psDevInfo->sFBInfo.ulPhysicalHeightmm =
 		((int)psLINFBInfo->var.height > 0) ? psLINFBInfo->var.height : 54;
 
-	
 	psDevInfo->sFBInfo.sSysAddr.uiAddr = psPVRFBInfo->sSysAddr.uiAddr;
 	psDevInfo->sFBInfo.sCPUVAddr = psPVRFBInfo->sCPUVAddr;
 
@@ -1565,7 +1428,7 @@ static void OMAPLFBDeInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 		kfree(psPVRFBInfo->psBltFBsBvPhys);
 	}
 #endif
-	if (psLINFBInfo->fbops->fb_release != NULL) 
+	if (psLINFBInfo->fbops->fb_release != NULL)
 	{
 		(void) psLINFBInfo->fbops->fb_release(psLINFBInfo, 0);
 	}
@@ -1581,32 +1444,27 @@ static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
 	IMG_UINT32		aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
 	OMAPLFB_DEVINFO		*psDevInfo = NULL;
 
-	
 	psDevInfo = (OMAPLFB_DEVINFO *)OMAPLFBAllocKernelMem(sizeof(OMAPLFB_DEVINFO));
 
 	if(psDevInfo == NULL)
 	{
 		printk(KERN_ERR DRIVER_PREFIX
 			": %s: Device %u: Couldn't allocate device information structure\n", __FUNCTION__, uiFBDevID);
-
 		goto ErrorExit;
 	}
 
-	
 	memset(psDevInfo, 0, sizeof(OMAPLFB_DEVINFO));
 
 	psDevInfo->uiFBDevID = uiFBDevID;
 
-	
 	if(!(*gpfnGetPVRJTable)(&psDevInfo->sPVRJTable))
 	{
 		goto ErrorFreeDevInfo;
 	}
 
-	
 	if(OMAPLFBInitFBDev(psDevInfo) != OMAPLFB_OK)
 	{
-		
+
 		goto ErrorFreeDevInfo;
 	}
 
@@ -1626,19 +1484,12 @@ static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
 	psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
 	psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
 
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-		": Device %u: Maximum number of swap chain buffers: %u\n",
-		psDevInfo->uiFBDevID, psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
-
-	
 	psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
 	psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
 	psDevInfo->sSystemBuffer.psDevInfo = psDevInfo;
 
 	OMAPLFBInitBufferForSwap(&psDevInfo->sSystemBuffer);
 
-	
-
 	psDevInfo->sDCJTable.ui32TableSize = sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
 	psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
 	psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
@@ -1657,7 +1508,6 @@ static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
 	psDevInfo->sDCJTable.pfnSwapToDCBuffer = SwapToDCBuffer;
 	psDevInfo->sDCJTable.pfnSetDCState = SetDCState;
 
-	
 	if(psDevInfo->sPVRJTable.pfnPVRSRVRegisterDCDevice(
 		&psDevInfo->sDCJTable,
 		&psDevInfo->uiPVRDevID) != PVRSRV_OK)
@@ -1667,15 +1517,10 @@ static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
 
 		goto ErrorDeInitFBDev;
 	}
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-		": Device %u: PVR Device ID: %u\n",
-		psDevInfo->uiFBDevID, psDevInfo->uiPVRDevID));
-	
-	
+
 	pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
 
-	
-	aui32SyncCountList[DC_FLIP_COMMAND][0] = 0; 
+	aui32SyncCountList[DC_FLIP_COMMAND][0] = 0;
 	if (gbBvInterfacePresent)
 	{
 		aui32SyncCountList[DC_FLIP_COMMAND][1] = 32;
@@ -1685,10 +1530,6 @@ static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
 		aui32SyncCountList[DC_FLIP_COMMAND][1] = 10;
 	}
 
-	
-
-
-
 	if (psDevInfo->sPVRJTable.pfnPVRSRVRegisterCmdProcList(psDevInfo->uiPVRDevID,
 			&pfnCmdProcList[0],
 			aui32SyncCountList,
@@ -1753,18 +1594,12 @@ OMAPLFB_ERROR OMAPLFBInit(void)
 
 	gbBvInterfacePresent = OMAPLFBInitBlt();
 
-	if (!gbBvInterfacePresent)
-	{
-		printk(KERN_INFO DRIVER_PREFIX "%s: Blitsville gc2d "
-			"not present, blits disabled\n", __func__);
-	}
 	for(i = uiMaxFBDevIDPlusOne; i-- != 0;)
 	{
 		OMAPLFB_DEVINFO *psDevInfo = OMAPLFBInitDev(i);
 
 		if (psDevInfo != NULL)
 		{
-			
 			OMAPLFBSetDevInfoPtr(psDevInfo->uiFBDevID, psDevInfo);
 			uiDevicesFound++;
 		}
diff --git a/drivers/video/omap2/omaplfb/omaplfb_linux.c b/drivers/video/omap2/omaplfb/omaplfb_linux.c
old mode 100755
new mode 100644
index b4f2faa..e5a7bad
--- a/drivers/video/omap2/omaplfb/omaplfb_linux.c
+++ b/drivers/video/omap2/omaplfb/omaplfb_linux.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright (C) Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -54,7 +54,7 @@
 #if defined(PVR_OMAPLFB_DRM_FB)
 #include <plat/display.h>
 #include <linux/omap_gpu.h>
-#else	
+#else
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
 #define PVR_OMAPFB3_NEEDS_PLAT_VRFB_H
 #endif
@@ -79,7 +79,7 @@
 #define	DEBUG PVR_DEBUG
 #undef PVR_DEBUG
 #endif
-#endif	
+#endif
 
 #include "img_defs.h"
 #include "servicesext.h"
@@ -207,7 +207,6 @@ OMAPLFB_ERROR OMAPLFBGetLibFuncAddr (char *szFunctionName, PFN_DC_GET_PVRJTABLE
 		return (OMAPLFB_ERROR_INVALID_PARAMS);
 	}
 
-	
 	*ppfnFuncTable = PVRGetDisplayClassJTable;
 
 	return (OMAPLFB_OK);
@@ -234,13 +233,13 @@ static void WorkQueueHandler(struct work_struct *psWork)
 OMAPLFB_ERROR OMAPLFBCreateSwapQueue(OMAPLFB_SWAPCHAIN *psSwapChain)
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
-	
+
 	psSwapChain->psWorkQueue = alloc_ordered_workqueue(DEVNAME, WQ_FREEZABLE | WQ_MEM_RECLAIM);
 #else
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	psSwapChain->psWorkQueue = create_freezable_workqueue(DEVNAME);
 #else
-	
+
 	psSwapChain->psWorkQueue = __create_workqueue(DEVNAME, 1, 1, 1);
 #endif
 #endif
@@ -285,7 +284,6 @@ void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer)
 
 	ulYResVirtual = psBuffer->ulYOffset + sFBVar.yres;
 
-	
 #if defined(CONFIG_DSSCOMP)
 	{
 		/*
@@ -326,7 +324,7 @@ void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer)
 	}
 #else
 #if !defined(PVR_OMAPLFB_DONT_USE_FB_PAN_DISPLAY)
-	
+
 	if (sFBVar.xres_virtual != sFBVar.xres || sFBVar.yres_virtual < ulYResVirtual)
 #endif
 	{
@@ -356,21 +354,6 @@ void OMAPLFBFlip(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_BUFFER *psBuffer)
 }
 
 #if !defined(PVR_OMAPLFB_DRM_FB) || defined(DEBUG)
-static OMAPLFB_BOOL OMAPLFBValidUpdateMode(enum OMAP_UPDATE_MODE eMode)
-{
-	switch (eMode)
-	{
-		case OMAP_UPDATE_MODE_AUTO:
-		case OMAP_UPDATE_MODE_MANUAL:
-		case OMAP_UPDATE_MODE_DISABLED:
-			return OMAPLFB_TRUE;
-		default:
-			break;
-	}
-
-	return OMAPLFB_FALSE;
-}
-
 static OMAPLFB_UPDATE_MODE OMAPLFBFromUpdateMode(enum OMAP_UPDATE_MODE eMode)
 {
 	switch (eMode)
@@ -458,16 +441,12 @@ void OMAPLFBPrintInfo(OMAPLFB_DEVINFO *psDevInfo)
 	unsigned uConnectors;
 	unsigned uConnector;
 
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": Device %u: DRM framebuffer\n", psDevInfo->uiFBDevID));
-
 	for (psConnector = NULL, uConnectors = 0;
 		(psConnector = omap_fbdev_get_next_connector(psDevInfo->psLINFBInfo, psConnector)) != NULL;)
 	{
 		uConnectors++;
 	}
 
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": Device %u: Number of screens (DRM connectors): %u\n", psDevInfo->uiFBDevID, uConnectors));
-
 	if (uConnectors == 0)
 	{
 		return;
@@ -477,17 +456,10 @@ void OMAPLFBPrintInfo(OMAPLFB_DEVINFO *psDevInfo)
 		(psConnector = omap_fbdev_get_next_connector(psDevInfo->psLINFBInfo, psConnector)) != NULL; uConnector++)
 	{
 		enum OMAP_UPDATE_MODE eMode = omap_connector_get_update_mode(psConnector);
-
-		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": Device %u: Screen %u: %s (%d)\n", psDevInfo->uiFBDevID, uConnector, OMAPLFBDSSUpdateModeToString(eMode), (int)eMode));
-
 	}
-#else	
+#else
 	OMAPLFB_UPDATE_MODE eMode = OMAPLFBGetUpdateMode(psDevInfo);
-
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": Device %u: non-DRM framebuffer\n", psDevInfo->uiFBDevID));
-
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": Device %u: %s\n", psDevInfo->uiFBDevID, OMAPLFBUpdateModeToString(eMode)));
-#endif	
+#endif
 }
 #endif
 
@@ -497,7 +469,6 @@ OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo)
 	struct drm_connector *psConnector;
 	OMAPLFB_UPDATE_MODE eMode = OMAPLFB_UPDATE_MODE_UNDEFINED;
 
-	
 	for (psConnector = NULL;
 		(psConnector = omap_fbdev_get_next_connector(psDevInfo->psLINFBInfo, psConnector)) != NULL;)
 	{
@@ -513,9 +484,9 @@ OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo)
 				}
 				break;
 			case OMAP_DSS_UPDATE_AUTO:
-				
+
 			default:
-				
+
 				if (eMode != OMAPLFB_UPDATE_MODE_MANUAL)
 				{
 					eMode = OMAPLFB_UPDATE_MODE_AUTO;
@@ -536,7 +507,6 @@ OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MOD
 
 	if (!OMAPLFBValidateUpdateMode(eMode))
 	{
-			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, (int)eMode));
 			return OMAPLFB_FALSE;
 	}
 	eDSSMode = OMAPLFBToUpdateMode(eMode);
@@ -547,35 +517,25 @@ OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MOD
 		int iRes = omap_connector_set_update_mode(psConnector, eDSSMode);
 		OMAPLFB_BOOL bRes = (iRes == 0);
 
-
 		bSuccess |= bRes;
 		bFailure |= !bRes;
 	}
 
 	if (!bFailure)
 	{
-		if (!bSuccess)
-		{
-			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: No screens\n", __FUNCTION__, psDevInfo->uiFBDevID));
-		}
-
 		return OMAPLFB_TRUE;
 	}
 
 	if (!bSuccess)
 	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't set %s for any screen\n", __FUNCTION__, psDevInfo->uiFBDevID, OMAPLFBUpdateModeToString(eMode)));
 		return OMAPLFB_FALSE;
 	}
 
 	if (eMode == OMAPLFB_UPDATE_MODE_AUTO)
 	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Couldn't set %s for all screens\n", __FUNCTION__, psDevInfo->uiFBDevID, OMAPLFBUpdateModeToString(eMode)));
 		return OMAPLFB_FALSE;
 	}
 
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: %s set for some screens\n", __FUNCTION__, psDevInfo->uiFBDevID, OMAPLFBUpdateModeToString(eMode)));
-
 	return OMAPLFB_TRUE;
 }
 
@@ -587,11 +547,6 @@ OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo)
 
 	omapfb_get_update_mode(psDevInfo->psLINFBInfo, &eMode);
 
-	if (!OMAPLFBValidUpdateMode(eMode))
-	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, (int)eMode));
-	}
-
 	return OMAPLFBFromUpdateMode(eMode);
 }
 
@@ -602,17 +557,11 @@ OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MOD
 
 	if (!OMAPLFBValidateUpdateMode(eMode))
 	{
-			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, (int)eMode));
 			return OMAPLFB_FALSE;
 	}
 
 	res = omapfb_set_update_mode(psDevInfo->psLINFBInfo, eUpdateMode);
 
-	if (res != 0)
-	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: set_update_mode (%s) failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, OMAPLFBUpdateModeToString(eUpdateMode), res));
-	}
-
 	return (res == 0);
 }
 
@@ -627,7 +576,6 @@ OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo)
 
 	if (psDSSDrv == NULL)
 	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: No DSS device\n", __FUNCTION__, psDevInfo->uiFBDevID));
 		return OMAPLFB_UPDATE_MODE_UNDEFINED;
 	}
 
@@ -637,17 +585,11 @@ OMAPLFB_UPDATE_MODE OMAPLFBGetUpdateMode(OMAPLFB_DEVINFO *psDevInfo)
 		{
 			return OMAPLFB_UPDATE_MODE_AUTO;
 		}
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: No get_update_mode function\n", __FUNCTION__, psDevInfo->uiFBDevID));
 		return OMAPLFB_UPDATE_MODE_UNDEFINED;
 	}
 
 	eMode = psDSSDrv->get_update_mode(psDSSDev);
 
-	if (!OMAPLFBValidUpdateMode(eMode))
-	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, (int)eMode));
-	}
-
 	return OMAPLFBFromUpdateMode(eMode);
 }
 
@@ -660,25 +602,18 @@ OMAPLFB_BOOL OMAPLFBSetUpdateMode(OMAPLFB_DEVINFO *psDevInfo, OMAPLFB_UPDATE_MOD
 
 	if (psDSSDrv == NULL || psDSSDrv->set_update_mode == NULL)
 	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Can't set update mode\n", __FUNCTION__, psDevInfo->uiFBDevID));
 		return OMAPLFB_FALSE;
 	}
 
 	if (!OMAPLFBValidateUpdateMode(eMode))
 	{
-			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Unknown update mode (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, (int)eMode));
-			return OMAPLFB_FALSE;
+		return OMAPLFB_FALSE;
 	}
 
 	eUpdateMode = OMAPLFBToUpdateMode(eMode);
 
 	res = psDSSDrv->set_update_mode(psDSSDev, eUpdateMode);
 
-	if (res != 0)
-	{
-		DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: set_update_mode (%s) failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, OMAPLFBUpdateModeToString(eUpdateMode), res));
-	}
-
 	return (res == 0);
 }
 #endif
@@ -695,7 +630,7 @@ OMAPLFB_BOOL OMAPLFBWaitForVSync(OMAPLFB_DEVINFO *psDevInfo)
 	}
 
 	return OMAPLFB_TRUE;
-#else	
+#else
 	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
 	OMAP_DSS_MANAGER(psDSSMan, psDSSDev);
 
@@ -704,13 +639,12 @@ OMAPLFB_BOOL OMAPLFBWaitForVSync(OMAPLFB_DEVINFO *psDevInfo)
 		int res = WAIT_FOR_VSYNC(psDSSMan)(psDSSMan);
 		if (res != 0)
 		{
-			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: Device %u: Wait for vsync failed (%d)\n", __FUNCTION__, psDevInfo->uiFBDevID, res));
 			return OMAPLFB_FALSE;
 		}
 	}
 
 	return OMAPLFB_TRUE;
-#endif	
+#endif
 }
 
 OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo)
@@ -721,7 +655,7 @@ OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo)
 	for (psConnector = NULL;
 		(psConnector = omap_fbdev_get_next_connector(psDevInfo->psLINFBInfo, psConnector)) != NULL; )
 	{
-		
+
 		if (omap_connector_sync(psConnector) != 0)
 		{
 			(void) omap_encoder_wait_for_vsync(psConnector->encoder);
@@ -729,7 +663,7 @@ OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo)
 	}
 
 	return OMAPLFB_TRUE;
-#else	
+#else
 	struct omap_dss_device *psDSSDev = fb2display(psDevInfo->psLINFBInfo);
 	OMAP_DSS_DRIVER(psDSSDrv, psDSSDev);
 
@@ -744,7 +678,7 @@ OMAPLFB_BOOL OMAPLFBManualSync(OMAPLFB_DEVINFO *psDevInfo)
 	}
 
 	return OMAPLFB_TRUE;
-#endif	
+#endif
 }
 
 OMAPLFB_BOOL OMAPLFBCheckModeAndSync(OMAPLFB_DEVINFO *psDevInfo)
@@ -771,7 +705,6 @@ static int OMAPLFBFrameBufferEvents(struct notifier_block *psNotif,
 	struct fb_info *psFBInfo = psFBEvent->info;
 	OMAPLFB_BOOL bBlanked;
 
-	
 	if (event != FB_EVENT_BLANK)
 	{
 		return 0;
@@ -781,24 +714,6 @@ static int OMAPLFBFrameBufferEvents(struct notifier_block *psNotif,
 
 	psDevInfo = OMAPLFBGetDevInfoPtr(psFBInfo->node);
 
-#if 0
-	if (psDevInfo != NULL)
-	{
-		if (bBlanked)
-		{
-			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Blank event received\n", __FUNCTION__, psDevInfo->uiFBDevID));
-		}
-		else
-		{
-			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Unblank event received\n", __FUNCTION__, psDevInfo->uiFBDevID));
-		}
-	}
-	else
-	{
-		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": %s: Device %u: Blank/Unblank event for unknown framebuffer\n", __FUNCTION__, psFBInfo->node));
-	}
-#endif
-
 	if (psDevInfo != NULL)
 	{
 		OMAPLFBAtomicBoolSet(&psDevInfo->sBlanked, bBlanked);
@@ -868,14 +783,13 @@ static void OMAPLFBEarlyResumeHandler(struct early_suspend *h)
 	}
 }
 
-#endif 
+#endif
 
 OMAPLFB_ERROR OMAPLFBEnableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
 {
 	int                res;
 	OMAPLFB_ERROR         eError;
 
-	
 	memset(&psDevInfo->sLINNotifBlock, 0, sizeof(psDevInfo->sLINNotifBlock));
 
 	psDevInfo->sLINNotifBlock.notifier_call = OMAPLFBFrameBufferEvents;
@@ -918,7 +832,6 @@ OMAPLFB_ERROR OMAPLFBDisableLFBEventNotification(OMAPLFB_DEVINFO *psDevInfo)
 	unregister_early_suspend(&psDevInfo->sEarlySuspend);
 #endif
 
-	
 	res = fb_unregister_client(&psDevInfo->sLINNotifBlock);
 	if (res != 0)
 	{
@@ -977,19 +890,15 @@ int PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Ioctl)(struct drm_device unref__ *dev,
 		return -EINVAL;
 	}
 
-
 	switch (uiCmd)
 	{
 		case PVR_DRM_DISP_CMD_LEAVE_VT:
 		case PVR_DRM_DISP_CMD_ENTER_VT:
 		{
 			OMAPLFB_BOOL bLeaveVT = (uiCmd == PVR_DRM_DISP_CMD_LEAVE_VT);
-			DEBUG_PRINTK((KERN_WARNING DRIVER_PREFIX ": %s: PVR Device %u: %s\n",
-				__FUNCTION__, uiPVRDevID,
-				bLeaveVT ? "Leave VT" : "Enter VT"));
 
 			OMAPLFBCreateSwapChainLock(psDevInfo);
-			
+
 			OMAPLFBAtomicBoolSet(&psDevInfo->sLeaveVT, bLeaveVT);
 			if (psDevInfo->psSwapChain != NULL)
 			{
@@ -1091,7 +1000,6 @@ struct sgx_omaplfb_config *GetFBPlatConfig(int fbix)
 {
 	if (fbix >= gplatdata->num_configs)
 	{
-		WARN(1, "Invalid FB device index");
 		return NULL;
 	}
 	return &gplatdata->configs[fbix];
@@ -1110,7 +1018,6 @@ static int omaplfb_probe(struct platform_device *pdev)
 
 	if (!gplatdata)
 	{
-		WARN(1, "Platform data is null");
 		return -ENODEV;
 	}
 
diff --git a/drivers/video/sii9234.c b/drivers/video/sii9234.c
index 86c73ae..c7e4711 100644
--- a/drivers/video/sii9234.c
+++ b/drivers/video/sii9234.c
@@ -114,7 +114,6 @@
 #define MHL_TX_MHLTX_CTL6_REG		0xA5
 #define MHL_TX_MHLTX_CTL7_REG		0xA6
 
-
 /* MHL TX SYS STAT Registers */
 #define MHL_TX_SYSSTAT_REG		0x09
 
@@ -526,30 +525,6 @@ static int tpi_write_reg(struct sii9234_data *sii9234, unsigned int offset,
 			value);
 }
 
-/* commenting this func as we r not using it currently */
-#if 0
-static int tpi_read_reg(struct sii9234_data *sii9234, unsigned int offset,
-		u8 *value)
-{
-	int ret;
-
-	if (!value)
-		return -EINVAL;
-
-	ret = i2c_smbus_write_byte(sii9234->pdata->tpi_client, offset);
-	if (ret < 0)
-		return ret;
-
-	ret = i2c_smbus_read_byte(sii9234->pdata->tpi_client);
-	if (ret < 0)
-		return ret;
-
-	*value = ret & 0x000000FF;
-
-	return 0;
-}
-#endif
-
 static int hdmi_rx_write_reg(struct sii9234_data *sii9234, unsigned int offset,
 		u8 value)
 {
diff --git a/fs/cifs/xattr.c b/fs/cifs/xattr.c
index 2a22fb2..6b9e867 100644
--- a/fs/cifs/xattr.c
+++ b/fs/cifs/xattr.c
@@ -36,12 +36,10 @@
 #define CIFS_XATTR_OS2_PREFIX "os2."
 #define CIFS_XATTR_SECURITY_PREFIX "security."
 #define CIFS_XATTR_TRUSTED_PREFIX "trusted."
-#define XATTR_TRUSTED_PREFIX_LEN  8
-#define XATTR_SECURITY_PREFIX_LEN 9
+#define CIFS_XATTR_TRUSTED_PREFIX_LEN  8
+#define CIFS_XATTR_SECURITY_PREFIX_LEN 9
 /* BB need to add server (Samba e.g) support for security and trusted prefix */
 
-
-
 int cifs_removexattr(struct dentry *direntry, const char *ea_name)
 {
 	int rc = -EOPNOTSUPP;
@@ -339,10 +337,10 @@ ssize_t cifs_getxattr(struct dentry *direntry, const char *ea_name,
 		cFYI(1, "Query CIFS ACL not supported yet");
 #endif /* CONFIG_CIFS_ACL */
 	} else if (strncmp(ea_name,
-		  CIFS_XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) == 0) {
+		  CIFS_XATTR_TRUSTED_PREFIX, CIFS_XATTR_TRUSTED_PREFIX_LEN) == 0) {
 		cFYI(1, "Trusted xattr namespace not supported yet");
 	} else if (strncmp(ea_name,
-		  CIFS_XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) == 0) {
+		  CIFS_XATTR_SECURITY_PREFIX, CIFS_XATTR_SECURITY_PREFIX_LEN) == 0) {
 		cFYI(1, "Security xattr namespace not supported yet");
 	} else
 		cFYI(1,
diff --git a/fs/dcache.c b/fs/dcache.c
index 8452838..f56b021 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -76,7 +76,7 @@
  *   dentry1->d_lock
  *     dentry2->d_lock
  */
-int sysctl_vfs_cache_pressure __read_mostly = 100;
+int sysctl_vfs_cache_pressure __read_mostly = 200;
 EXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure);
 
 static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dcache_lru_lock);
diff --git a/fs/ext4/dir.c b/fs/ext4/dir.c
index f00b0a0..3bda91c 100644
--- a/fs/ext4/dir.c
+++ b/fs/ext4/dir.c
@@ -50,7 +50,6 @@ const struct file_operations ext4_dir_operations = {
 	.release	= ext4_release_dir,
 };
 
-
 static unsigned char get_dtype(struct super_block *sb, int filetype)
 {
 	if (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FILETYPE) ||
@@ -90,10 +89,6 @@ int __ext4_check_dir_entry(const char *function, unsigned int line,
 	else
 		return 0;
 
-	/* for debugging, sangwoo2.lee */
-	print_bh(dir->i_sb, bh, 0, EXT4_BLOCK_SIZE(dir->i_sb));
-	/* for debugging */
-
 	if (filp)
 		ext4_error_file(filp, function, line, bh ? bh->b_blocknr : 0,
 				"bad entry in directory: %s - offset=%u(%u), "
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index f9132e0..7ebc236 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1930,13 +1930,6 @@ extern __le16 ext4_group_desc_csum(struct ext4_sb_info *sbi, __u32 group,
 				   struct ext4_group_desc *gdp);
 extern int ext4_group_desc_csum_verify(struct ext4_sb_info *sbi, __u32 group,
 				       struct ext4_group_desc *gdp);
-/* for debugging, sangwoo2.lee */
-extern void print_bh(struct super_block *sb,
-		     struct buffer_head *bh, int start, int len);
-extern void print_block_data(struct super_block *sb, sector_t blocknr,
-			     unsigned char *data_to_dump, int start, int len);
-/* for debugging */
-
 
 static inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)
 {
diff --git a/fs/ext4/ext4_jbd2.c b/fs/ext4/ext4_jbd2.c
index f5240aa..15109d5 100644
--- a/fs/ext4/ext4_jbd2.c
+++ b/fs/ext4/ext4_jbd2.c
@@ -41,12 +41,6 @@ int __ext4_forget(const char *where, unsigned int line, handle_t *handle,
 	might_sleep();
 
 	trace_ext4_forget(inode, is_metadata, blocknr);
-	BUFFER_TRACE(bh, "enter");
-
-	jbd_debug(4, "forgetting bh %p: is_metadata = %d, mode %o, "
-		  "data mode %x\n",
-		  bh, is_metadata, inode->i_mode,
-		  test_opt(inode->i_sb, DATA_FLAGS));
 
 	/* In the no journal case, we can just do a bforget and return */
 	if (!ext4_handle_valid(handle)) {
@@ -62,7 +56,6 @@ int __ext4_forget(const char *where, unsigned int line, handle_t *handle,
 	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||
 	    (!is_metadata && !ext4_should_journal_data(inode))) {
 		if (bh) {
-			BUFFER_TRACE(bh, "call jbd2_journal_forget");
 			err = jbd2_journal_forget(handle, bh);
 			if (err)
 				ext4_journal_abort_handle(where, line, __func__,
@@ -75,7 +68,6 @@ int __ext4_forget(const char *where, unsigned int line, handle_t *handle,
 	/*
 	 * data!=journal && (is_metadata || should_journal_data(inode))
 	 */
-	BUFFER_TRACE(bh, "call jbd2_journal_revoke");
 	err = jbd2_journal_revoke(handle, blocknr, bh);
 	if (err) {
 		ext4_journal_abort_handle(where, line, __func__,
@@ -83,7 +75,6 @@ int __ext4_forget(const char *where, unsigned int line, handle_t *handle,
 		__ext4_abort(inode->i_sb, where, line,
 			   "error %d when attempting revoke", err);
 	}
-	BUFFER_TRACE(bh, "exit");
 	return err;
 }
 
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 3988b9b..0c2e825 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -547,9 +547,6 @@ ext4_ext_binsearch_idx(struct inode *inode,
 	struct ext4_extent_header *eh = path->p_hdr;
 	struct ext4_extent_idx *r, *l, *m;
 
-
-	ext_debug("binsearch for %u(idx):  ", block);
-
 	l = EXT_FIRST_INDEX(eh) + 1;
 	r = EXT_LAST_INDEX(eh);
 	while (l <= r) {
@@ -558,14 +555,9 @@ ext4_ext_binsearch_idx(struct inode *inode,
 			r = m - 1;
 		else
 			l = m + 1;
-		ext_debug("%p(%u):%p(%u):%p(%u) ", l, le32_to_cpu(l->ei_block),
-				m, le32_to_cpu(m->ei_block),
-				r, le32_to_cpu(r->ei_block));
 	}
 
 	path->p_idx = l - 1;
-	ext_debug("  -> %d->%lld ", le32_to_cpu(path->p_idx->ei_block),
-		  ext4_idx_pblock(path->p_idx));
 
 #ifdef CHECK_BINSEARCH
 	{
@@ -615,8 +607,6 @@ ext4_ext_binsearch(struct inode *inode,
 		return;
 	}
 
-	ext_debug("binsearch for %u:  ", block);
-
 	l = EXT_FIRST_EXTENT(eh) + 1;
 	r = EXT_LAST_EXTENT(eh);
 
@@ -626,17 +616,9 @@ ext4_ext_binsearch(struct inode *inode,
 			r = m - 1;
 		else
 			l = m + 1;
-		ext_debug("%p(%u):%p(%u):%p(%u) ", l, le32_to_cpu(l->ee_block),
-				m, le32_to_cpu(m->ee_block),
-				r, le32_to_cpu(r->ee_block));
 	}
 
 	path->p_ext = l - 1;
-	ext_debug("  -> %d:%llu:[%d]%d ",
-			le32_to_cpu(path->p_ext->ee_block),
-			ext4_ext_pblock(path->p_ext),
-			ext4_ext_is_uninitialized(path->p_ext),
-			ext4_ext_get_actual_len(path->p_ext));
 
 #ifdef CHECK_BINSEARCH
 	{
@@ -698,9 +680,6 @@ ext4_ext_find_extent(struct inode *inode, ext4_lblk_t block,
 	while (i) {
 		int need_to_validate = 0;
 
-		ext_debug("depth %d: num %d, max %d\n",
-			  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));
-
 		ext4_ext_binsearch_idx(inode, path + ppos, block);
 		path[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);
 		path[ppos].p_depth = i;
@@ -784,10 +763,6 @@ static int ext4_ext_insert_index(handle_t *handle, struct inode *inode,
 		if (curp->p_idx != EXT_LAST_INDEX(curp->p_hdr)) {
 			len = (len - 1) * sizeof(struct ext4_extent_idx);
 			len = len < 0 ? 0 : len;
-			ext_debug("insert new index %d after: %llu. "
-					"move %d from 0x%p to 0x%p\n",
-					logical, ptr, len,
-					(curp->p_idx + 1), (curp->p_idx + 2));
 			memmove(curp->p_idx + 2, curp->p_idx + 1, len);
 		}
 		ix = curp->p_idx + 1;
@@ -795,10 +770,6 @@ static int ext4_ext_insert_index(handle_t *handle, struct inode *inode,
 		/* insert before */
 		len = len * sizeof(struct ext4_extent_idx);
 		len = len < 0 ? 0 : len;
-		ext_debug("insert new index %d before: %llu. "
-				"move %d from 0x%p to 0x%p\n",
-				logical, ptr, len,
-				curp->p_idx, (curp->p_idx + 1));
 		memmove(curp->p_idx + 1, curp->p_idx, len);
 		ix = curp->p_idx;
 	}
@@ -861,14 +832,8 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 	}
 	if (path[depth].p_ext != EXT_MAX_EXTENT(path[depth].p_hdr)) {
 		border = path[depth].p_ext[1].ee_block;
-		ext_debug("leaf will be split."
-				" next leaf starts at %d\n",
-				  le32_to_cpu(border));
 	} else {
 		border = newext->ee_block;
-		ext_debug("leaf will be added."
-				" next leaf starts at %d\n",
-				le32_to_cpu(border));
 	}
 
 	/*
@@ -888,7 +853,6 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 		return -ENOMEM;
 
 	/* allocate all needed blocks */
-	ext_debug("allocate %d blocks for indexes/leaf\n", depth - at);
 	for (a = 0; a < depth - at; a++) {
 		newblock = ext4_ext_new_meta_block(handle, inode, path,
 						   newext, &err, flags);
@@ -968,8 +932,6 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 		err = -EIO;
 		goto cleanup;
 	}
-	if (k)
-		ext_debug("create %d intermediate indices\n", k);
 	/* insert new index into current index block */
 	/* current depth stored in i var */
 	i = depth - 1;
@@ -996,9 +958,6 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 		fidx->ei_block = border;
 		ext4_idx_store_pblock(fidx, oldblock);
 
-		ext_debug("int.index at %d (block %llu): %u -> %llu\n",
-				i, newblock, le32_to_cpu(border), oldblock);
-
 		/* move remainder of path[i] to the new index block */
 		if (unlikely(EXT_MAX_INDEX(path[i].p_hdr) !=
 					EXT_LAST_INDEX(path[i].p_hdr))) {
@@ -1010,8 +969,6 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 		}
 		/* start copy indexes */
 		m = EXT_MAX_INDEX(path[i].p_hdr) - path[i].p_idx++;
-		ext_debug("cur 0x%p, last 0x%p\n", path[i].p_idx,
-				EXT_MAX_INDEX(path[i].p_hdr));
 		ext4_ext_show_move(inode, path, newblock, i);
 		if (m) {
 			memmove(++fidx, path[i].p_idx,
@@ -1142,10 +1099,6 @@ static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
 	ext4_idx_store_pblock(curp->p_idx, newblock);
 
 	neh = ext_inode_hdr(inode);
-	ext_debug("new root: num %d(%d), lblock %d, ptr %llu\n",
-		  le16_to_cpu(neh->eh_entries), le16_to_cpu(neh->eh_max),
-		  le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),
-		  ext4_idx_pblock(EXT_FIRST_INDEX(neh)));
 
 	neh->eh_depth = cpu_to_le16(path->p_depth + 1);
 	err = ext4_ext_dirty(handle, inode, curp);
@@ -1732,13 +1685,6 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,
 	/* try to insert block into found extent and return */
 	if (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)
 		&& ext4_can_extents_be_merged(inode, ex, newext)) {
-		ext_debug("append [%d]%d block to %d:[%d]%d (from %llu)\n",
-			  ext4_ext_is_uninitialized(newext),
-			  ext4_ext_get_actual_len(newext),
-			  le32_to_cpu(ex->ee_block),
-			  ext4_ext_is_uninitialized(ex),
-			  ext4_ext_get_actual_len(ex),
-			  ext4_ext_pblock(ex));
 		err = ext4_ext_get_access(handle, inode, path + depth);
 		if (err)
 			return err;
@@ -1770,7 +1716,6 @@ repeat:
 	next = ext4_ext_next_leaf_block(inode, path);
 	if (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)
 	    && next != EXT_MAX_BLOCKS) {
-		ext_debug("next leaf block - %d\n", next);
 		BUG_ON(npath != NULL);
 		npath = ext4_ext_find_extent(inode, next, NULL);
 		if (IS_ERR(npath))
@@ -1778,13 +1723,9 @@ repeat:
 		BUG_ON(npath->p_depth != path->p_depth);
 		eh = npath[depth].p_hdr;
 		if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {
-			ext_debug("next leaf isn't full(%d)\n",
-				  le16_to_cpu(eh->eh_entries));
 			path = npath;
 			goto repeat;
 		}
-		ext_debug("next leaf has no free space(%d,%d)\n",
-			  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));
 	}
 
 	/*
@@ -1808,11 +1749,6 @@ has_space:
 
 	if (!nearex) {
 		/* there is no extent in this leaf, create first one */
-		ext_debug("first extent in the leaf: %d:%llu:[%d]%d\n",
-				le32_to_cpu(newext->ee_block),
-				ext4_ext_pblock(newext),
-				ext4_ext_is_uninitialized(newext),
-				ext4_ext_get_actual_len(newext));
 		path[depth].p_ext = EXT_FIRST_EXTENT(eh);
 	} else if (le32_to_cpu(newext->ee_block)
 			   > le32_to_cpu(nearex->ee_block)) {
@@ -1821,13 +1757,6 @@ has_space:
 			len = EXT_MAX_EXTENT(eh) - nearex;
 			len = (len - 1) * sizeof(struct ext4_extent);
 			len = len < 0 ? 0 : len;
-			ext_debug("insert %d:%llu:[%d]%d after: nearest 0x%p, "
-					"move %d from 0x%p to 0x%p\n",
-					le32_to_cpu(newext->ee_block),
-					ext4_ext_pblock(newext),
-					ext4_ext_is_uninitialized(newext),
-					ext4_ext_get_actual_len(newext),
-					nearex, len, nearex + 1, nearex + 2);
 			memmove(nearex + 2, nearex + 1, len);
 		}
 		path[depth].p_ext = nearex + 1;
@@ -1835,13 +1764,6 @@ has_space:
 		BUG_ON(newext->ee_block == nearex->ee_block);
 		len = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);
 		len = len < 0 ? 0 : len;
-		ext_debug("insert %d:%llu:[%d]%d before: nearest 0x%p, "
-				"move %d from 0x%p to 0x%p\n",
-				le32_to_cpu(newext->ee_block),
-				ext4_ext_pblock(newext),
-				ext4_ext_is_uninitialized(newext),
-				ext4_ext_get_actual_len(newext),
-				nearex, len, nearex + 1, nearex + 2);
 		memmove(nearex + 1, nearex, len);
 		path[depth].p_ext = nearex;
 	}
@@ -2023,14 +1945,9 @@ ext4_ext_put_gap_in_cache(struct inode *inode, struct ext4_ext_path *path,
 		/* there is no extent yet, so gap is [0;-] */
 		lblock = 0;
 		len = EXT_MAX_BLOCKS;
-		ext_debug("cache gap(whole file):");
 	} else if (block < le32_to_cpu(ex->ee_block)) {
 		lblock = block;
 		len = le32_to_cpu(ex->ee_block) - block;
-		ext_debug("cache gap(before): %u [%u:%u]",
-				block,
-				le32_to_cpu(ex->ee_block),
-				 ext4_ext_get_actual_len(ex));
 	} else if (block >= le32_to_cpu(ex->ee_block)
 			+ ext4_ext_get_actual_len(ex)) {
 		ext4_lblk_t next;
@@ -2038,10 +1955,6 @@ ext4_ext_put_gap_in_cache(struct inode *inode, struct ext4_ext_path *path,
 			+ ext4_ext_get_actual_len(ex);
 
 		next = ext4_ext_next_allocated_block(path);
-		ext_debug("cache gap(after): [%u:%u] %u",
-				le32_to_cpu(ex->ee_block),
-				ext4_ext_get_actual_len(ex),
-				block);
 		BUG_ON(next == lblock);
 		len = next - lblock;
 	} else {
@@ -2049,7 +1962,6 @@ ext4_ext_put_gap_in_cache(struct inode *inode, struct ext4_ext_path *path,
 		BUG();
 	}
 
-	ext_debug(" -> %u:%lu\n", lblock, len);
 	ext4_ext_put_in_cache(inode, lblock, len, 0);
 }
 
@@ -2088,9 +2000,6 @@ static int ext4_ext_check_cache(struct inode *inode, ext4_lblk_t block,
 
 	if (in_range(block, cex->ec_block, cex->ec_len)) {
 		memcpy(ex, cex, sizeof(struct ext4_ext_cache));
-		ext_debug("%u cached by %u:%u:%llu\n",
-				block,
-				cex->ec_block, cex->ec_len, cex->ec_start);
 		ret = 1;
 	}
 errout:
@@ -2132,7 +2041,6 @@ ext4_ext_in_cache(struct inode *inode, ext4_lblk_t block,
 	return ret;
 }
 
-
 /*
  * ext4_ext_rm_idx:
  * removes index from the index block.
@@ -2160,7 +2068,6 @@ static int ext4_ext_rm_idx(handle_t *handle, struct inode *inode,
 	err = ext4_ext_dirty(handle, inode, path);
 	if (err)
 		return err;
-	ext_debug("index is empty, remove it, free block %llu\n", leaf);
 	ext4_free_blocks(handle, inode, NULL, leaf, 1,
 			 EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);
 
@@ -2270,7 +2177,6 @@ static int ext4_remove_blocks(handle_t *handle, struct inode *inode,
 
 		num = le32_to_cpu(ex->ee_block) + ee_len - from;
 		start = ext4_ext_pblock(ex) + ee_len - num;
-		ext_debug("free last %u blocks starting %llu\n", num, start);
 		ext4_free_blocks(handle, inode, NULL, start, num, flags);
 	} else if (from == le32_to_cpu(ex->ee_block)
 		   && to <= le32_to_cpu(ex->ee_block) + ee_len - 1) {
@@ -2281,7 +2187,6 @@ static int ext4_remove_blocks(handle_t *handle, struct inode *inode,
 		num = to - from;
 		start = ext4_ext_pblock(ex);
 
-		ext_debug("free first %u blocks starting %llu\n", num, start);
 		ext4_free_blocks(handle, inode, 0, start, num, flags);
 
 	} else {
@@ -2292,7 +2197,6 @@ static int ext4_remove_blocks(handle_t *handle, struct inode *inode,
 	return 0;
 }
 
-
 /*
  * ext4_ext_rm_leaf() Removes the extents associated with the
  * blocks appearing between "start" and "end", and splits the extents
@@ -2321,7 +2225,6 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 	struct ext4_map_blocks map;
 
 	/* the header must be checked already in ext4_ext_remove_space() */
-	ext_debug("truncate since %u in leaf\n", start);
 	if (!path[depth].p_hdr)
 		path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);
 	eh = path[depth].p_hdr;
@@ -2343,16 +2246,12 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 		else
 			uninitialized = 0;
 
-		ext_debug("remove ext %u:[%d]%d\n", ex_ee_block,
-			 uninitialized, ex_ee_len);
 		path[depth].p_ext = ex;
 
 		a = ex_ee_block > start ? ex_ee_block : start;
 		b = ex_ee_block+ex_ee_len - 1 < end ?
 			ex_ee_block+ex_ee_len - 1 : end;
 
-		ext_debug("  border %u:%u\n", a, b);
-
 		/* If this extent is beyond the end of the hole, skip it */
 		if (end <= ex_ee_block) {
 			ex--;
@@ -2367,8 +2266,6 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 			 * needs to be on the edge of the extent.
 			 */
 			if (end == EXT_MAX_BLOCKS - 1) {
-				ext_debug("  bad truncate %u:%u\n",
-						start, end);
 				block = 0;
 				num = 0;
 				err = -EIO;
@@ -2415,8 +2312,6 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 			 * should never happen
 			 */
 			if (end == EXT_MAX_BLOCKS - 1) {
-				ext_debug("  bad truncate %u:%u\n",
-					start, end);
 				err = -EIO;
 				goto out;
 			}
@@ -2425,15 +2320,11 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 			block = ex_ee_block;
 			num = 0;
 			if (a != ex_ee_block) {
-				ext_debug("  bad truncate %u:%u\n",
-					start, end);
 				err = -EIO;
 				goto out;
 			}
 
 			if (b != ex_ee_block + ex_ee_len - 1) {
-				ext_debug("  bad truncate %u:%u\n",
-					start, end);
 				err = -EIO;
 				goto out;
 			}
@@ -2510,8 +2401,6 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 		if (err)
 			goto out;
 
-		ext_debug("new extent: %u:%u:%llu\n", block, num,
-				ext4_ext_pblock(ex));
 		ex--;
 		ex_ee_block = le32_to_cpu(ex->ee_block);
 		ex_ee_len = ext4_ext_get_actual_len(ex);
@@ -2559,8 +2448,6 @@ static int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,
 	handle_t *handle;
 	int i, err;
 
-	ext_debug("truncate since %u\n", start);
-
 	/* probably first extent we're gonna free will be last in block */
 	handle = ext4_journal_start(inode, depth + 1);
 	if (IS_ERR(handle))
@@ -2601,7 +2488,6 @@ again:
 
 		/* this is index block */
 		if (!path[i].p_hdr) {
-			ext_debug("initialize header\n");
 			path[i].p_hdr = ext_block_hdr(path[i].p_bh);
 		}
 
@@ -2609,22 +2495,14 @@ again:
 			/* this level hasn't been touched yet */
 			path[i].p_idx = EXT_LAST_INDEX(path[i].p_hdr);
 			path[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries)+1;
-			ext_debug("init index ptr: hdr 0x%p, num %d\n",
-				  path[i].p_hdr,
-				  le16_to_cpu(path[i].p_hdr->eh_entries));
 		} else {
 			/* we were already here, see at next index */
 			path[i].p_idx--;
 		}
 
-		ext_debug("level %d - index, first 0x%p, cur 0x%p\n",
-				i, EXT_FIRST_INDEX(path[i].p_hdr),
-				path[i].p_idx);
 		if (ext4_ext_more_to_rm(path + i)) {
 			struct buffer_head *bh;
 			/* go to the next level */
-			ext_debug("move to level %d (block %llu)\n",
-				  i + 1, ext4_idx_pblock(path[i].p_idx));
 			memset(path + i + 1, 0, sizeof(*path));
 			bh = sb_bread(sb, ext4_idx_pblock(path[i].p_idx));
 			if (!bh) {
@@ -2659,7 +2537,6 @@ again:
 			brelse(path[i].p_bh);
 			path[i].p_bh = NULL;
 			i--;
-			ext_debug("return to level %d\n", i);
 		}
 	}
 
@@ -2798,9 +2675,6 @@ static int ext4_split_extent_at(handle_t *handle,
 	unsigned int ee_len, depth;
 	int err = 0;
 
-	ext_debug("ext4_split_extents_at: inode %lu, logical"
-		"block %llu\n", inode->i_ino, (unsigned long long)split);
-
 	ext4_ext_show_leaf(inode, path);
 
 	depth = ext_depth(inode);
@@ -2971,10 +2845,6 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 	int err = 0;
 	int split_flag = 0;
 
-	ext_debug("ext4_ext_convert_to_initialized: inode %lu, logical"
-		"block %llu, max_blocks %u\n", inode->i_ino,
-		(unsigned long long)map->m_lblk, map->m_len);
-
 	eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>
 		inode->i_sb->s_blocksize_bits;
 	if (eof_block < map->m_lblk + map->m_len)
@@ -3097,10 +2967,6 @@ static int ext4_split_unwritten_extents(handle_t *handle,
 	unsigned int ee_len;
 	int split_flag = 0, depth;
 
-	ext_debug("ext4_split_unwritten_extents: inode %lu, logical"
-		"block %llu, max_blocks %u\n", inode->i_ino,
-		(unsigned long long)map->m_lblk, map->m_len);
-
 	eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>
 		inode->i_sb->s_blocksize_bits;
 	if (eof_block < map->m_lblk + map->m_len)
@@ -3134,11 +3000,6 @@ static int ext4_convert_unwritten_extents_endio(handle_t *handle,
 	eh = path[depth].p_hdr;
 	ex = path[depth].p_ext;
 
-	ext_debug("ext4_convert_unwritten_extents_endio: inode %lu, logical"
-		"block %llu, max_blocks %u\n", inode->i_ino,
-		(unsigned long long)le32_to_cpu(ex->ee_block),
-		ext4_ext_get_actual_len(ex));
-
 	err = ext4_ext_get_access(handle, inode, path + depth);
 	if (err)
 		goto out;
@@ -3225,10 +3086,6 @@ ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,
 	int err = 0;
 	ext4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;
 
-	ext_debug("ext4_ext_handle_uninitialized_extents: inode %lu, logical"
-		  "block %llu, max_blocks %u, flags %d, allocated %u",
-		  inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,
-		  flags, allocated);
 	ext4_ext_show_leaf(inode, path);
 
 	/* get_block() before submit the IO, split the extent */
@@ -3372,8 +3229,6 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 	ext4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;
 	struct ext4_map_blocks punch_map;
 
-	ext_debug("blocks %u/%u requested for inode %lu\n",
-		  map->m_lblk, map->m_len, inode->i_ino);
 	trace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);
 
 	/* check in cache */
@@ -3440,8 +3295,6 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 			newblock = map->m_lblk - ee_block + ee_start;
 			/* number of remaining blocks in the extent */
 			allocated = ee_len - (map->m_lblk - ee_block);
-			ext_debug("%u fit into %u:%d -> %llu\n", map->m_lblk,
-				  ee_block, ee_len, newblock);
 
 			if ((flags & EXT4_GET_BLOCKS_PUNCH_OUT_EXT) == 0) {
 				/*
@@ -3587,8 +3440,6 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 	newblock = ext4_mb_new_blocks(handle, &ar, &err);
 	if (!newblock)
 		goto out2;
-	ext_debug("allocate new block: goal %llu, found %llu/%u\n",
-		  ar.goal, newblock, allocated);
 
 	/* try to insert new extent into found leaf and return */
 	ext4_ext_store_pblock(&newex, newblock);
@@ -4319,7 +4170,6 @@ int ext4_ext_punch_hole(struct file *file, loff_t offset, loff_t length)
 
 		if (num_blocks == 0) {
 			/* This condition should never happen */
-			ext_debug("Block lookup failed");
 			err = -EIO;
 			break;
 		}
diff --git a/fs/ext4/fsync.c b/fs/ext4/fsync.c
index ce66d2f..641c6cb 100644
--- a/fs/ext4/fsync.c
+++ b/fs/ext4/fsync.c
@@ -42,11 +42,9 @@ static void dump_completed_IO(struct inode * inode)
 	unsigned long flags;
 
 	if (list_empty(&EXT4_I(inode)->i_completed_io_list)){
-		ext4_debug("inode %lu completed_io list is empty\n", inode->i_ino);
 		return;
 	}
 
-	ext4_debug("Dump inode %lu completed_io list \n", inode->i_ino);
 	spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);
 	list_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){
 		cur = &io->list;
@@ -55,8 +53,6 @@ static void dump_completed_IO(struct inode * inode)
 		after = cur->next;
 		io1 = container_of(after, ext4_io_end_t, list);
 
-		ext4_debug("io 0x%p from inode %lu,prev 0x%p,next 0x%p\n",
-			    io, inode->i_ino, io0, io1);
 	}
 	spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);
 #endif
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 98cb570..85f63a8 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -58,7 +58,6 @@ void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)
 	if (start_bit >= end_bit)
 		return;
 
-	ext4_debug("mark end bits +%d through +%d used\n", start_bit, end_bit);
 	for (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)
 		ext4_set_bit(i, bitmap);
 	if (i < end_bit)
@@ -213,7 +212,6 @@ void ext4_free_inode(handle_t *handle, struct inode *inode)
 	sbi = EXT4_SB(sb);
 
 	ino = inode->i_ino;
-	ext4_debug("freeing inode %lu\n", ino);
 	trace_ext4_free_inode(inode);
 
 	/*
@@ -241,7 +239,6 @@ void ext4_free_inode(handle_t *handle, struct inode *inode)
 	if (!bitmap_bh)
 		goto error_return;
 
-	BUFFER_TRACE(bitmap_bh, "get_write_access");
 	fatal = ext4_journal_get_write_access(handle, bitmap_bh);
 	if (fatal)
 		goto error_return;
@@ -249,7 +246,6 @@ void ext4_free_inode(handle_t *handle, struct inode *inode)
 	fatal = -ESRCH;
 	gdp = ext4_get_group_desc(sb, block_group, &bh2);
 	if (gdp) {
-		BUFFER_TRACE(bh2, "get_write_access");
 		fatal = ext4_journal_get_write_access(handle, bh2);
 	}
 	ext4_lock_group(sb, block_group);
@@ -277,21 +273,15 @@ void ext4_free_inode(handle_t *handle, struct inode *inode)
 		if (is_directory)
 			atomic_dec(&sbi->s_flex_groups[f].used_dirs);
 	}
-	BUFFER_TRACE(bh2, "call ext4_handle_dirty_metadata");
 	fatal = ext4_handle_dirty_metadata(handle, NULL, bh2);
 out:
 	if (cleared) {
-		BUFFER_TRACE(bitmap_bh, "call ext4_handle_dirty_metadata");
 		err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);
 		if (!fatal)
 			fatal = err;
 		ext4_mark_super_dirty(sb);
-	} else {
-		/* for debugging, sangwoo2.lee */
-		print_bh(sb, bitmap_bh, 0, EXT4_BLOCK_SIZE(sb));
-		/* for debugging */
+	} else
 		ext4_error(sb, "bit already cleared for inode %lu", ino);
-	}
 
 error_return:
 	brelse(bitmap_bh);
@@ -890,7 +880,7 @@ got_group:
 		inode_bitmap_bh = ext4_read_inode_bitmap(sb, group);
 		if (!inode_bitmap_bh)
 			goto fail;
-		BUFFER_TRACE(inode_bitmap_bh, "get_write_access");
+
 		err = ext4_journal_get_write_access(handle, inode_bitmap_bh);
 		if (err)
 				goto fail;
@@ -902,13 +892,11 @@ repeat_in_this_group:
 
 		if (ino < EXT4_INODES_PER_GROUP(sb)) {
 
-			BUFFER_TRACE(inode_bitmap_bh, "get_write_access");
 			err = ext4_journal_get_write_access(handle,
 							    inode_bitmap_bh);
 			if (err)
 				goto fail;
 
-			BUFFER_TRACE(group_desc_bh, "get_write_access");
 			err = ext4_journal_get_write_access(handle,
 								group_desc_bh);
 			if (err)
@@ -916,8 +904,6 @@ repeat_in_this_group:
 			if (!ext4_claim_inode(sb, inode_bitmap_bh,
 						ino, group, mode)) {
 				/* we won it */
-				BUFFER_TRACE(inode_bitmap_bh,
-					"call ext4_handle_dirty_metadata");
 				err = ext4_handle_dirty_metadata(handle,
 								 NULL,
 							inode_bitmap_bh);
@@ -950,7 +936,6 @@ repeat_in_this_group:
 	goto out;
 
 got:
-	BUFFER_TRACE(inode_bitmap_bh, "call ext4_handle_dirty_metadata");
 	err = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);
 	if (err)
 		goto fail;
@@ -961,7 +946,7 @@ got:
 		struct buffer_head *block_bitmap_bh;
 
 		block_bitmap_bh = ext4_read_block_bitmap(sb, group);
-		BUFFER_TRACE(block_bitmap_bh, "get block bitmap access");
+
 		err = ext4_journal_get_write_access(handle, block_bitmap_bh);
 		if (err) {
 			brelse(block_bitmap_bh);
@@ -982,7 +967,6 @@ got:
 
 		/* Don't need to dirty bitmap block if we didn't change it */
 		if (free) {
-			BUFFER_TRACE(block_bitmap_bh, "dirty block bitmap");
 			err = ext4_handle_dirty_metadata(handle,
 							NULL, block_bitmap_bh);
 		}
@@ -991,7 +975,6 @@ got:
 		if (err)
 			goto fail;
 	}
-	BUFFER_TRACE(group_desc_bh, "call ext4_handle_dirty_metadata");
 	err = ext4_handle_dirty_metadata(handle, NULL, group_desc_bh);
 	if (err)
 		goto fail;
@@ -1088,7 +1071,6 @@ got:
 		goto fail_free_drop;
 	}
 
-	ext4_debug("allocating inode %lu\n", inode->i_ino);
 	trace_ext4_allocate_inode(inode, dir, mode);
 	goto really_out;
 fail:
@@ -1316,7 +1298,6 @@ extern int ext4_init_inode_table(struct super_block *sb, ext4_group_t group,
 	blk = ext4_inode_table(sb, gdp) + used_blks;
 	num = sbi->s_itb_per_group - used_blks;
 
-	BUFFER_TRACE(group_desc_bh, "get_write_access");
 	ret = ext4_journal_get_write_access(handle,
 					    group_desc_bh);
 	if (ret)
@@ -1330,8 +1311,6 @@ extern int ext4_init_inode_table(struct super_block *sb, ext4_group_t group,
 	if (unlikely(num == 0))
 		goto skip_zeroout;
 
-	ext4_debug("going to zero out inode table in group %d\n",
-		   group);
 	ret = sb_issue_zeroout(sb, blk, num, GFP_NOFS);
 	if (ret < 0)
 		goto err_out;
@@ -1344,8 +1323,6 @@ skip_zeroout:
 	gdp->bg_checksum = ext4_group_desc_csum(sbi, group, gdp);
 	ext4_unlock_group(sb, group);
 
-	BUFFER_TRACE(group_desc_bh,
-		     "call ext4_handle_dirty_metadata");
 	ret = ext4_handle_dirty_metadata(handle, NULL,
 					 group_desc_bh);
 
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 8f4da9b..e3926e3 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -385,7 +385,6 @@ static int __ext4_check_blockref(const char *function, unsigned int line,
 	return 0;
 }
 
-
 #define ext4_check_indirect_blockref(inode, bh)                         \
 	__ext4_check_blockref(__func__, __LINE__, inode,		\
 			      (__le32 *)(bh)->b_data,			\
@@ -790,7 +789,6 @@ static int ext4_alloc_branch(handle_t *handle, struct inode *inode,
 
 		branch[n].bh = bh;
 		lock_buffer(bh);
-		BUFFER_TRACE(bh, "call get_create_access");
 		err = ext4_journal_get_create_access(handle, bh);
 		if (err) {
 			/* Don't brelse(bh) here; it's done in
@@ -813,11 +811,9 @@ static int ext4_alloc_branch(handle_t *handle, struct inode *inode,
 			for (i = 1; i < num; i++)
 				*(branch[n].p + i) = cpu_to_le32(++current_block);
 		}
-		BUFFER_TRACE(bh, "marking uptodate");
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
 
-		BUFFER_TRACE(bh, "call ext4_handle_dirty_metadata");
 		err = ext4_handle_dirty_metadata(handle, inode, bh);
 		if (err)
 			goto failed;
@@ -873,7 +869,6 @@ static int ext4_splice_branch(handle_t *handle, struct inode *inode,
 	 * before the splice.
 	 */
 	if (where->bh) {
-		BUFFER_TRACE(where->bh, "get_write_access");
 		err = ext4_journal_get_write_access(handle, where->bh);
 		if (err)
 			goto err_out;
@@ -904,7 +899,6 @@ static int ext4_splice_branch(handle_t *handle, struct inode *inode,
 		 * generic_commit_write->__mark_inode_dirty->ext4_dirty_inode.
 		 */
 		jbd_debug(5, "splicing indirect only\n");
-		BUFFER_TRACE(where->bh, "call ext4_handle_dirty_metadata");
 		err = ext4_handle_dirty_metadata(handle, inode, where->bh);
 		if (err)
 			goto err_out;
@@ -1057,7 +1051,6 @@ got_it:
 	partial = chain + depth - 1;	/* the whole chain */
 cleanup:
 	while (partial > chain) {
-		BUFFER_TRACE(partial->bh, "call brelse");
 		brelse(partial->bh);
 		partial--;
 	}
@@ -1191,12 +1184,6 @@ static int __check_block_validity(struct inode *inode, const char *func,
 {
 	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
 				   map->m_len)) {
-		/* for debugging, sangwoo2.lee */
-		printk(KERN_ERR "printing inode..\n");
-		print_block_data(inode->i_sb, 0, (unsigned char *)inode,
-				0, EXT4_INODE_SIZE(inode->i_sb));
-		/* for debugging */
-
 		ext4_error_inode(inode, func, line, map->m_pblk,
 				 "lblock %lu mapped to illegal pblock "
 				 "(length %d)", (unsigned long) map->m_lblk,
@@ -1486,19 +1473,15 @@ struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,
 		 * problem.
 		 */
 		lock_buffer(bh);
-		BUFFER_TRACE(bh, "call get_create_access");
 		fatal = ext4_journal_get_create_access(handle, bh);
 		if (!fatal && !buffer_uptodate(bh)) {
 			memset(bh->b_data, 0, inode->i_sb->s_blocksize);
 			set_buffer_uptodate(bh);
 		}
 		unlock_buffer(bh);
-		BUFFER_TRACE(bh, "call ext4_handle_dirty_metadata");
 		err = ext4_handle_dirty_metadata(handle, inode, bh);
 		if (!fatal)
 			fatal = err;
-	} else {
-		BUFFER_TRACE(bh, "not a new buffer");
 	}
 	if (fatal) {
 		*errp = fatal;
@@ -1806,7 +1789,6 @@ static int ext4_ordered_write_end(struct file *file,
 			ext4_orphan_del(NULL, inode);
 	}
 
-
 	return ret ? ret : copied;
 }
 
@@ -2912,7 +2894,6 @@ out:
 	return ret;
 }
 
-
 static int ext4_da_writepages(struct address_space *mapping,
 			      struct writeback_control *wbc)
 {
@@ -4026,17 +4007,13 @@ int ext4_block_zero_page_range(handle_t *handle,
 	}
 
 	err = 0;
-	if (buffer_freed(bh)) {
-		BUFFER_TRACE(bh, "freed: skip");
+	if (buffer_freed(bh))
 		goto unlock;
-	}
 
 	if (!buffer_mapped(bh)) {
-		BUFFER_TRACE(bh, "unmapped");
 		ext4_get_block(inode, iblock, bh, 0);
 		/* unmapped? It's a hole - nothing to do */
 		if (!buffer_mapped(bh)) {
-			BUFFER_TRACE(bh, "still unmapped");
 			goto unlock;
 		}
 	}
@@ -4055,7 +4032,6 @@ int ext4_block_zero_page_range(handle_t *handle,
 	}
 
 	if (ext4_should_journal_data(inode)) {
-		BUFFER_TRACE(bh, "get write access");
 		err = ext4_journal_get_write_access(handle, bh);
 		if (err)
 			goto unlock;
@@ -4063,8 +4039,6 @@ int ext4_block_zero_page_range(handle_t *handle,
 
 	zero_user(page, offset, length);
 
-	BUFFER_TRACE(bh, "zeroed end of block");
-
 	err = 0;
 	if (ext4_should_journal_data(inode)) {
 		err = ext4_handle_dirty_metadata(handle, inode, bh);
@@ -4211,7 +4185,6 @@ static int ext4_clear_blocks(handle_t *handle, struct inode *inode,
 
 	if (try_to_extend_transaction(handle, inode)) {
 		if (bh) {
-			BUFFER_TRACE(bh, "call ext4_handle_dirty_metadata");
 			err = ext4_handle_dirty_metadata(handle, inode, bh);
 			if (unlikely(err))
 				goto out_err;
@@ -4224,7 +4197,6 @@ static int ext4_clear_blocks(handle_t *handle, struct inode *inode,
 		if (unlikely(err))
 			goto out_err;
 		if (bh) {
-			BUFFER_TRACE(bh, "retaking write access");
 			err = ext4_journal_get_write_access(handle, bh);
 			if (unlikely(err))
 				goto out_err;
@@ -4275,7 +4247,6 @@ static void ext4_free_data(handle_t *handle, struct inode *inode,
 	int err = 0;
 
 	if (this_bh) {				/* For indirect block */
-		BUFFER_TRACE(this_bh, "get_write_access");
 		err = ext4_journal_get_write_access(handle, this_bh);
 		/* Important: if we can't update the indirect pointers
 		 * to the blocks, we can't free them. */
@@ -4314,8 +4285,6 @@ static void ext4_free_data(handle_t *handle, struct inode *inode,
 		return;
 
 	if (this_bh) {
-		BUFFER_TRACE(this_bh, "call ext4_handle_dirty_metadata");
-
 		/*
 		 * The buffer head should have an attached journal head at this
 		 * point. However, if the data is corrupted and an indirect
@@ -4387,7 +4356,6 @@ static void ext4_free_branches(handle_t *handle, struct inode *inode,
 			}
 
 			/* This zaps the entire block.  Bottom up. */
-			BUFFER_TRACE(bh, "free child branches");
 			ext4_free_branches(handle, inode, bh,
 					(__le32 *) bh->b_data,
 					(__le32 *) bh->b_data + addr_per_block,
@@ -4438,12 +4406,9 @@ static void ext4_free_branches(handle_t *handle, struct inode *inode,
 				 * The block which we have just freed is
 				 * pointed to by an indirect block: journal it
 				 */
-				BUFFER_TRACE(parent_bh, "get_write_access");
 				if (!ext4_journal_get_write_access(handle,
 								   parent_bh)){
 					*p = 0;
-					BUFFER_TRACE(parent_bh,
-					"call ext4_handle_dirty_metadata");
 					ext4_handle_dirty_metadata(handle,
 								   inode,
 								   parent_bh);
@@ -4452,7 +4417,6 @@ static void ext4_free_branches(handle_t *handle, struct inode *inode,
 		}
 	} else {
 		/* We have reached the bottom of the tree. */
-		BUFFER_TRACE(parent_bh, "free data blocks");
 		ext4_free_data(handle, inode, parent_bh, first, last);
 	}
 }
@@ -4626,7 +4590,6 @@ void ext4_truncate(struct inode *inode)
 			 */
 		} else {
 			/* Shared branch grows from an indirect block */
-			BUFFER_TRACE(partial->bh, "get_write_access");
 			ext4_free_branches(handle, inode, partial->bh,
 					partial->p,
 					partial->p+1, (chain+n-1) - partial);
@@ -4637,7 +4600,6 @@ void ext4_truncate(struct inode *inode)
 		ext4_free_branches(handle, inode, partial->bh, partial->p + 1,
 				   (__le32*)partial->bh->b_data+addr_per_block,
 				   (chain+n-1) - partial);
-		BUFFER_TRACE(partial->bh, "call brelse");
 		brelse(partial->bh);
 		partial--;
 	}
@@ -4954,17 +4916,6 @@ struct inode *ext4_iget(struct super_block *sb, unsigned long ino)
 		if (inode->i_mode == 0 ||
 		    !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) {
 			/* this inode is deleted */
-			/* for debugging, sangwoo2.lee */
-			printk(KERN_ERR "iloc info, offset : %lu, "
-					"group# : %u\n", iloc.offset,
-					iloc.block_group);
-			printk(KERN_ERR "sb info, inodes per group : %lu, "
-					"inode size : %d\n",
-					EXT4_SB(sb)->s_inodes_per_group,
-					EXT4_SB(sb)->s_inode_size);
-			print_bh(sb, iloc.bh, 0, EXT4_BLOCK_SIZE(sb));
-			/* for debugging */
-
 			ret = -ESTALE;
 			goto bad_inode;
 		}
@@ -5111,17 +5062,6 @@ struct inode *ext4_iget(struct super_block *sb, unsigned long ino)
 	return inode;
 
 bad_inode:
-	/* for debugging, woojoong.lee */
-	printk(KERN_ERR "iloc info, offset : %lu,"
-					, iloc.offset);
-	printk(KERN_ERR " group# : %u\n", iloc.block_group);
-	printk(KERN_ERR "sb info, inodes per group : %lu,"
-					, EXT4_SB(sb)->s_inodes_per_group);
-	printk(KERN_ERR " inode size : %d\n"
-					, EXT4_SB(sb)->s_inode_size);
-	print_bh(sb, iloc.bh, 0, EXT4_BLOCK_SIZE(sb));
-	/* end */
-
 	brelse(iloc.bh);
 	iget_failed(inode);
 	return ERR_PTR(ret);
@@ -5280,7 +5220,6 @@ static int ext4_do_update_inode(handle_t *handle,
 		raw_inode->i_extra_isize = cpu_to_le16(ei->i_extra_isize);
 	}
 
-	BUFFER_TRACE(bh, "call ext4_handle_dirty_metadata");
 	rc = ext4_handle_dirty_metadata(handle, NULL, bh);
 	if (!err)
 		err = rc;
@@ -5687,7 +5626,6 @@ ext4_reserve_inode_write(handle_t *handle, struct inode *inode,
 
 	err = ext4_get_inode_loc(inode, iloc);
 	if (!err) {
-		BUFFER_TRACE(iloc->bh, "get_write_access");
 		err = ext4_journal_get_write_access(handle, iloc->bh);
 		if (err) {
 			brelse(iloc->bh);
@@ -5826,36 +5764,6 @@ out:
 	return;
 }
 
-#if 0
-/*
- * Bind an inode's backing buffer_head into this transaction, to prevent
- * it from being flushed to disk early.  Unlike
- * ext4_reserve_inode_write, this leaves behind no bh reference and
- * returns no iloc structure, so the caller needs to repeat the iloc
- * lookup to mark the inode dirty later.
- */
-static int ext4_pin_inode(handle_t *handle, struct inode *inode)
-{
-	struct ext4_iloc iloc;
-
-	int err = 0;
-	if (handle) {
-		err = ext4_get_inode_loc(inode, &iloc);
-		if (!err) {
-			BUFFER_TRACE(iloc.bh, "get_write_access");
-			err = jbd2_journal_get_write_access(handle, iloc.bh);
-			if (!err)
-				err = ext4_handle_dirty_metadata(handle,
-								 NULL,
-								 iloc.bh);
-			brelse(iloc.bh);
-		}
-	}
-	ext4_std_error(inode->i_sb, err);
-	return err;
-}
-#endif
-
 int ext4_change_inode_journal_flag(struct inode *inode, int val)
 {
 	journal_t *journal;
diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
index 4cbe1c2..868f0ef 100644
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -24,8 +24,6 @@ long ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	struct ext4_inode_info *ei = EXT4_I(inode);
 	unsigned int flags;
 
-	ext4_debug("cmd = %u, arg = %lu\n", cmd, arg);
-
 	switch (cmd) {
 	case EXT4_IOC_GETFLAGS:
 		ext4_get_inode_flags(ei);
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index ff12650..0f91173 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -16,7 +16,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-
  */
 
-
 /*
  * mballoc.c contains the multiblocks allocation routines
  */
@@ -731,10 +730,6 @@ void ext4_mb_generate_buddy(struct super_block *sb,
 	grp->bb_fragments = fragments;
 
 	if (free != grp->bb_free) {
-		/* for more specific debugging, sangwoo2.lee */
-		print_block_data(sb, 0, bitmap, 0, EXT4_BLOCK_SIZE(sb));
-		/* for more specific debugging */
-
 		ext4_grp_locked_error(sb, group, 0, 0,
 				      "%u blocks in bitmap, %u in gd",
 				      free, grp->bb_free);
@@ -1245,7 +1240,6 @@ static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)
 		page_cache_release(e4b->bd_buddy_page);
 }
 
-
 static int mb_find_order_for_block(struct ext4_buddy *e4b, int block)
 {
 	int order = 1;
@@ -1342,10 +1336,6 @@ static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,
 
 			blocknr = ext4_group_first_block_no(sb, e4b->bd_group);
 			blocknr += block;
-			/* for debugging, sangwoo2.lee */
-			print_block_data(sb, blocknr, EXT4_MB_BITMAP(e4b),
-					0, EXT4_BLOCK_SIZE(sb));
-			/* for debugging */
 			ext4_grp_locked_error(sb, e4b->bd_group,
 					      inode ? inode->i_ino : 0,
 					      blocknr,
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index d92d07f..31b8390 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -130,7 +130,6 @@ struct dx_node
 	struct dx_entry	entries[0];
 };
 
-
 struct dx_frame
 {
 	struct buffer_head *bh;
@@ -557,7 +556,6 @@ static int ext4_htree_next_block(struct inode *dir, __u32 hash,
 	return 1;
 }
 
-
 /*
  * This function fills a red-black tree with information from a
  * directory block.  It returns the number directory entries loaded
@@ -606,7 +604,6 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 	return count;
 }
 
-
 /*
  * This function fills a red-black tree with information from a
  * directory.  We start scanning the directory in hash order, starting
@@ -697,7 +694,6 @@ errout:
 	return (err);
 }
 
-
 /*
  * Directory block splitting, compacting
  */
@@ -834,7 +830,6 @@ static inline int search_dirblock(struct buffer_head *bh,
 	return 0;
 }
 
-
 /*
  *	ext4_find_entry()
  *
@@ -1029,11 +1024,6 @@ static struct dentry *ext4_lookup(struct inode *dir, struct dentry *dentry, stru
 	if (bh) {
 		__u32 ino = le32_to_cpu(de->inode);
 		if (!ext4_valid_inum(dir->i_sb, ino)) {
-			/* for debugging, sangwoo2.lee */
-			printk(KERN_ERR "Name of directory entry has "
-					"bad inode# : %s\n", de->name);
-			print_bh(dir->i_sb, bh, 0, EXT4_BLOCK_SIZE(dir->i_sb));
-			/* for debugging */
 			brelse(bh);
 
 			EXT4_ERROR_INODE(dir, "bad inode number: %u", ino);
diff --git a/fs/ext4/page-io.c b/fs/ext4/page-io.c
index d99d74a..39a3686 100644
--- a/fs/ext4/page-io.c
+++ b/fs/ext4/page-io.c
@@ -96,10 +96,6 @@ int ext4_end_io_nolock(ext4_io_end_t *io)
 	wait_queue_head_t *wq;
 	int ret = 0;
 
-	ext4_debug("ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,"
-		   "list->prev 0x%p\n",
-		   io, inode->i_ino, io->list.next, io->list.prev);
-
 	if (list_empty(&io->list))
 		return ret;
 
@@ -384,9 +380,6 @@ int ext4_bio_write_page(struct ext4_io_submit *io,
 
 	blocksize = 1 << inode->i_blkbits;
 
-	BUG_ON(!PageLocked(page));
-	BUG_ON(PageWriteback(page));
-
 	io_page = kmem_cache_alloc(io_page_cachep, GFP_NOFS);
 	if (!io_page) {
 		set_page_dirty(page);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 274710d..668b1c7 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -96,7 +96,6 @@ static struct file_system_type ext2_fs_type = {
 #define IS_EXT2_SB(sb) (0)
 #endif
 
-
 #if !defined(CONFIG_EXT3_FS) && !defined(CONFIG_EXT3_FS_MODULE) && defined(CONFIG_EXT4_USE_FOR_EXT23)
 static struct file_system_type ext3_fs_type = {
 	.owner		= THIS_MODULE,
@@ -222,15 +221,12 @@ void ext4_itable_unused_set(struct super_block *sb,
 		bg->bg_itable_unused_hi = cpu_to_le16(count >> 16);
 }
 
-
 /* Just increment the non-pointer handle value */
 static handle_t *ext4_get_nojournal(void)
 {
 	handle_t *handle = current->journal_info;
 	unsigned long ref_cnt = (unsigned long)handle;
 
-	BUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);
-
 	ref_cnt++;
 	handle = (handle_t *)ref_cnt;
 
@@ -238,14 +234,11 @@ static handle_t *ext4_get_nojournal(void)
 	return handle;
 }
 
-
 /* Decrement the non-pointer handle value */
 static void ext4_put_nojournal(handle_t *handle)
 {
 	unsigned long ref_cnt = (unsigned long)handle;
 
-	BUG_ON(ref_cnt == 0);
-
 	ref_cnt--;
 	handle = (handle_t *)ref_cnt;
 
@@ -333,11 +326,6 @@ void ext4_journal_abort_handle(const char *caller, unsigned int line,
 	char nbuf[16];
 	const char *errstr = ext4_decode_error(NULL, err, nbuf);
 
-	BUG_ON(!ext4_handle_valid(handle));
-
-	if (bh)
-		BUFFER_TRACE(bh, "abort");
-
 	if (!handle->h_err)
 		handle->h_err = err;
 
@@ -384,7 +372,6 @@ static void save_error_info(struct super_block *sb, const char *func,
 	ext4_commit_super(sb, 1);
 }
 
-
 /* Deal with the reporting of failure conditions on a filesystem such as
  * inconsistencies detected or read IO failures.
  *
@@ -3723,17 +3710,8 @@ no_journal:
 	return 0;
 
 cantfind_ext4:
-
-	/* for debugging, sangwoo2.lee */
-	/* If you wanna use the flag 'MS_SILENT',*/
-	/* call 'print_bh' function within below 'if'. */
-	printk(KERN_ERR "printing data of superblock-bh\n");
-	print_bh(sb, bh, 0, EXT4_BLOCK_SIZE(sb));
-	/* for debugging */
-
 	if (!silent)
 		ext4_msg(sb, KERN_ERR, "VFS: Can't find ext4 filesystem");
-
 	goto failed_mount;
 
 failed_mount7:
@@ -4838,58 +4816,6 @@ out:
 
 #endif
 
-/* for debugging, sangwoo2.lee */
-void print_bh(struct super_block *sb, struct buffer_head *bh,
-	      int start, int len)
-{
-	print_block_data(sb, bh->b_blocknr, bh->b_data, start, len);
-}
-
-void print_block_data(struct super_block *sb, sector_t blocknr,
-		      unsigned char *data_to_dump, int start, int len)
-{
-	int i, j;
-	int bh_offset = (start / 16) * 16;
-	char row_data[17] = { 0, };
-	char row_hex[50] = { 0, };
-	char ch;
-
-	printk(KERN_ERR "As EXT4-fs error, printing data in hex\n");
-	printk(KERN_ERR " [partition info] s_id : %s, start block# : %llu\n",
-	       sb->s_id, sb->s_bdev->bd_part->start_sect);
-	printk(KERN_ERR " dump block# : %llu, start offset(byte) : %d,"
-	       " length(byte) : %d\n", blocknr, start, len);
-	printk(KERN_ERR "---------------------------------------------------"
-	       "--------------------------\n");
-
-	for (i = 0; i < (len + 15) / 16; i++) {
-		for (j = 0; j < 16; j++) {
-			ch = *(data_to_dump + bh_offset + j);
-			if (start <= bh_offset + j && start +
-			    len > bh_offset + j) {
-				if (isascii(ch) && isprint(ch))
-					sprintf(row_data + j, "%c", ch);
-				else
-					sprintf(row_data + j, ".");
-
-				sprintf(row_hex + (j * 3), "%2.2x ", ch);
-			} else {
-				sprintf(row_data + j, " ");
-				sprintf(row_hex + (j * 3), "-- ");
-			}
-		}
-
-		printk(KERN_ERR "0x%4.4x : %s | %s\n",
-		       bh_offset, row_hex, row_data);
-		bh_offset += 16;
-
-	}
-	printk(KERN_ERR "---------------------------------------------------"
-	       "--------------------------\n");
-}
-/* for debugging */
-
-
 static struct dentry *ext4_mount(struct file_system_type *fs_type, int flags,
 		       const char *dev_name, void *data)
 {
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index 49c8c98..a175b27 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -186,7 +186,6 @@ void inode_wb_list_del(struct inode *inode)
 	spin_unlock(&inode_wb_list_lock);
 }
 
-
 /*
  * Redirty an inode: set its when-it-was dirtied timestamp and move it to the
  * furthest end of its superblock's dirty-inode list.
@@ -954,7 +953,6 @@ int bdi_writeback_thread(void *data)
 	return 0;
 }
 
-
 /*
  * Start writeback of `nr_pages' pages.  If `nr_pages' is zero, write back
  * the whole world.
@@ -988,10 +984,6 @@ static noinline void block_dump___mark_inode_dirty(struct inode *inode)
 			spin_lock(&dentry->d_lock);
 			name = (const char *) dentry->d_name.name;
 		}
-		printk(KERN_DEBUG
-		       "%s(%d): dirtied inode %lu (%s) on %s\n",
-		       current->comm, task_pid_nr(current), inode->i_ino,
-		       name, inode->i_sb->s_id);
 		if (dentry) {
 			spin_unlock(&dentry->d_lock);
 			dput(dentry);
@@ -1084,9 +1076,6 @@ void __mark_inode_dirty(struct inode *inode, int flags)
 			bdi = inode_to_bdi(inode);
 
 			if (bdi_cap_writeback_dirty(bdi)) {
-				WARN(!test_bit(BDI_registered, &bdi->state),
-				     "bdi-%s not registered\n", bdi->name);
-
 				/*
 				 * If this is the first dirty inode for this
 				 * bdi, we have to wake-up the corresponding
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 09089e1..228c82c 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -666,7 +666,6 @@ static int fuse_readpages_fill(void *_data, struct page *page)
 		if (is_cma_pageblock(newpage)) {
 			page_cache_release(oldpage);
 			__free_page(newpage);
-			printk(KERN_ERR "[%s] still on cma pgblk\n", __func__);
 			return -ENOMEM;
 		}
 
@@ -678,8 +677,7 @@ static int fuse_readpages_fill(void *_data, struct page *page)
 		}
 
 		/*
-		 * Decrement the count on new page to make page cache the only
-		 * owner of it
+		 * Decrement the count on new page to make page cache the only owner of it
 		 */
 		lock_page(newpage);
 		put_page(newpage);
@@ -1797,7 +1795,6 @@ static int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec *dst,
 	return 0;
 }
 
-
 /*
  * For ioctls, there is no generic way to determine how much memory
  * needs to be read and/or written.  Furthermore, ioctls are allowed
diff --git a/fs/locks.c b/fs/locks.c
index 35388d5..f3d65ef 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -11,11 +11,11 @@
  *
  *  Miscellaneous edits, and a total rewrite of posix_lock_file() code.
  *  Kai Petzke (wpp@marie.physik.tu-berlin.de), 1994
- *  
+ *
  *  Converted file_lock_table to a linked list from an array, which eliminates
  *  the limits on how many active file locks are open.
  *  Chad Page (pageone@netcom.com), November 27, 1994
- * 
+ *
  *  Removed dependency on file descriptors. dup()'ed file descriptors now
  *  get the same locks as the original file descriptors, and a close() on
  *  any file descriptor removes ALL the locks on the file for the current
@@ -41,7 +41,7 @@
  *  with a file pointer (filp). As a result they can be shared by a parent
  *  process and its children after a fork(). They are removed when the last
  *  file descriptor referring to the file pointer is closed (unless explicitly
- *  unlocked). 
+ *  unlocked).
  *
  *  FL_FLOCK locks never deadlock, an existing lock is always removed before
  *  upgrading from shared to exclusive (or vice versa). When this happens
@@ -50,7 +50,7 @@
  *  Andy Walker (andy@lysaker.kvaerner.no), June 09, 1995
  *
  *  Removed some race conditions in flock_lock_file(), marked other possible
- *  races. Just grep for FIXME to see them. 
+ *  races. Just grep for FIXME to see them.
  *  Dmitry Gorodchanin (pgmdsg@ibi.com), February 09, 1996.
  *
  *  Addressed Dmitry's concerns. Deadlock checking no longer recursive.
@@ -300,7 +300,7 @@ static int flock_make_lock(struct file *filp, struct file_lock **lock,
 	int type = flock_translate_cmd(cmd);
 	if (type < 0)
 		return type;
-	
+
 	fl = locks_alloc_lock();
 	if (fl == NULL)
 		return -ENOMEM;
@@ -310,7 +310,7 @@ static int flock_make_lock(struct file *filp, struct file_lock **lock,
 	fl->fl_flags = FL_FLOCK;
 	fl->fl_type = type;
 	fl->fl_end = OFFSET_MAX;
-	
+
 	*lock = fl;
 	return 0;
 }
@@ -370,7 +370,7 @@ static int flock_to_posix_lock(struct file *filp, struct file_lock *fl,
 	fl->fl_start = start;	/* we record the absolute position */
 	if (fl->fl_end < fl->fl_start)
 		return -EOVERFLOW;
-	
+
 	fl->fl_owner = current->files;
 	fl->fl_pid = current->tgid;
 	fl->fl_file = filp;
@@ -416,7 +416,7 @@ static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,
 	fl->fl_start = start;	/* we record the absolute position */
 	if (fl->fl_end < fl->fl_start)
 		return -EOVERFLOW;
-	
+
 	fl->fl_owner = current->files;
 	fl->fl_pid = current->tgid;
 	fl->fl_file = filp;
@@ -529,7 +529,7 @@ static void locks_delete_block(struct file_lock *waiter)
  * the order they blocked. The documentation doesn't require this but
  * it seems like the reasonable thing to do.
  */
-static void locks_insert_block(struct file_lock *blocker, 
+static void locks_insert_block(struct file_lock *blocker,
 			       struct file_lock *waiter)
 {
 	BUG_ON(!list_empty(&waiter->fl_block));
@@ -862,7 +862,7 @@ static int __posix_lock_file(struct inode *inode, struct file_lock *request, str
 	/*
 	 * Find the first old lock with the same owner as the new lock.
 	 */
-	
+
 	before = &inode->i_flock;
 
 	/* First skip locks owned by other processes.  */
@@ -1195,6 +1195,9 @@ int __break_lease(struct inode *inode, unsigned int mode)
 
 	new_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);
 
+	if (IS_ERR(new_fl))
+		return PTR_ERR(new_fl);
+
 	lock_flocks();
 
 	time_out_leases(inode);
@@ -1221,12 +1224,6 @@ int __break_lease(struct inode *inode, unsigned int mode)
 		goto out;
 	}
 
-	if (IS_ERR(new_fl) && !i_have_this_lease
-			&& ((mode & O_NONBLOCK) == 0)) {
-		error = PTR_ERR(new_fl);
-		goto out;
-	}
-
 	break_time = 0;
 	if (lease_break_time > 0) {
 		break_time = jiffies + lease_break_time * HZ;
diff --git a/fs/namei.c b/fs/namei.c
index 16bda6c..661f35c 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -45,8 +45,8 @@
  * The new code replaces the old recursive symlink resolution with
  * an iterative one (in case of non-nested symlink chains).  It does
  * this with calls to <fs>_follow_link().
- * As a side effect, dir_namei(), _namei() and follow_link() are now 
- * replaced with a single function lookup_dentry() that can handle all 
+ * As a side effect, dir_namei(), _namei() and follow_link() are now
+ * replaced with a single function lookup_dentry() that can handle all
  * the special cases of the former code.
  *
  * With the new dcache, the pathname is stored at each inode, at least as
@@ -138,7 +138,7 @@ static int do_getname(const char __user *filename, char *page)
 
 static char *getname_flags(const char __user *filename, int flags, int *empty)
 {
-	char *tmp, *result;
+	char *tmp = NULL, *result;
 
 	result = ERR_PTR(-ENOMEM);
 	tmp = __getname();
@@ -1363,7 +1363,7 @@ static int link_path_walk(const char *name, struct nameidata *nd)
 	struct path next;
 	int err;
 	unsigned int lookup_flags = nd->flags;
-	
+
 	while (*name=='/')
 		name++;
 	if (!*name)
@@ -1432,7 +1432,7 @@ static int link_path_walk(const char *name, struct nameidata *nd)
 			if (err)
 				return err;
 		}
-		err = -ENOTDIR; 
+		err = -ENOTDIR;
 		if (!nd->inode->i_op->lookup)
 			break;
 		continue;
@@ -2454,7 +2454,7 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, int, mode,
 		unsigned, dev)
 {
 	int error;
-	char *tmp;
+	char *tmp = NULL;
 	struct dentry *dentry;
 	struct nameidata nd;
 
@@ -3102,7 +3102,7 @@ int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 
 	if (old_dentry->d_inode == new_dentry->d_inode)
  		return 0;
- 
+
 	error = may_delete(old_dir, old_dentry, is_dir);
 	if (error)
 		return error;
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c9fc255..399a505 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -316,7 +316,7 @@ void nfs_commit_release_pages(struct nfs_write_data *data);
 
 #ifdef CONFIG_MIGRATION
 extern int nfs_migrate_page(struct address_space *,
-		struct page *, struct page *);
+		struct page *, struct page *, enum migrate_mode);
 #else
 #define nfs_migrate_page NULL
 #endif
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index f2f80c0..15c96f6 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -927,7 +927,6 @@ static int nfs_flush_multi(struct nfs_pageio_descriptor *desc)
 	     desc->pg_count > wsize))
 		desc->pg_ioflags &= ~FLUSH_COND_STABLE;
 
-
 	nbytes = desc->pg_count;
 	do {
 		size_t len = min(nbytes, wsize);
@@ -1185,7 +1184,6 @@ static const struct rpc_call_ops nfs_write_full_ops = {
 	.rpc_release = nfs_writeback_release_full,
 };
 
-
 /*
  * This function is called when the WRITE call is complete.
  */
@@ -1269,7 +1267,6 @@ void nfs_writeback_done(struct rpc_task *task, struct nfs_write_data *data)
 	return;
 }
 
-
 #if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)
 static int nfs_commit_set_lock(struct nfs_inode *nfsi, int may_wait)
 {
@@ -1662,7 +1659,7 @@ out_error:
 
 #ifdef CONFIG_MIGRATION
 int nfs_migrate_page(struct address_space *mapping, struct page *newpage,
-		struct page *page)
+		struct page *page, enum migrate_mode mode)
 {
 	/*
 	 * If PagePrivate is set, then the page is currently associated with
@@ -1677,7 +1674,7 @@ int nfs_migrate_page(struct address_space *mapping, struct page *newpage,
 
 	nfs_fscache_release_page(page, GFP_KERNEL);
 
-	return migrate_page(mapping, newpage, page);
+	return migrate_page(mapping, newpage, page, mode);
 }
 #endif
 
@@ -1729,4 +1726,3 @@ void nfs_destroy_writepagecache(void)
 	mempool_destroy(nfs_wdata_mempool);
 	kmem_cache_destroy(nfs_wdata_cachep);
 }
-
diff --git a/fs/posix_acl.c b/fs/posix_acl.c
index b1cf6bf..365a071 100644
--- a/fs/posix_acl.c
+++ b/fs/posix_acl.c
@@ -386,3 +386,39 @@ posix_acl_chmod_masq(struct posix_acl *acl, mode_t mode)
 
 	return 0;
 }
+
+int
+posix_acl_create(struct posix_acl **acl, gfp_t gfp, mode_t *mode_p)
+{
+	struct posix_acl *clone = posix_acl_clone(*acl, gfp);
+	int err = -ENOMEM;
+	if (clone) {
+		err = posix_acl_create_masq(clone, mode_p);
+		if (err < 0) {
+			posix_acl_release(clone);
+			clone = NULL;
+		}
+	}
+	posix_acl_release(*acl);
+	*acl = clone;
+	return err;
+}
+EXPORT_SYMBOL(posix_acl_create);
+
+int
+posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, mode_t mode)
+{
+	struct posix_acl *clone = posix_acl_clone(*acl, gfp);
+	int err = -ENOMEM;
+	if (clone) {
+		err = posix_acl_chmod_masq(clone, mode);
+		if (err) {
+			posix_acl_release(clone);
+			clone = NULL;
+		}
+	}
+	posix_acl_release(*acl);
+	*acl = clone;
+	return err;
+}
+EXPORT_SYMBOL(posix_acl_chmod);
diff --git a/fs/sync.c b/fs/sync.c
index c38ec16..47954b5 100644
--- a/fs/sync.c
+++ b/fs/sync.c
@@ -18,6 +18,11 @@
 #include <linux/backing-dev.h>
 #include "internal.h"
 
+#ifdef CONFIG_DYNAMIC_FSYNC
+extern bool early_suspend_active;
+extern bool dyn_fsync_active;
+#endif
+
 #define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \
 			SYNC_FILE_RANGE_WAIT_AFTER)
 
@@ -87,7 +92,7 @@ static void sync_one_sb(struct super_block *sb, void *arg)
  * Sync all the data for all the filesystems (called by sys_sync() and
  * emergency sync)
  */
-static void sync_filesystems(int wait)
+void sync_filesystems(int wait)
 {
 	iterate_supers(sync_one_sb, &wait);
 }
@@ -165,6 +170,12 @@ SYSCALL_DEFINE1(syncfs, int, fd)
  */
 int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)
 {
+#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && !early_suspend_active))
+		return 0;
+	else {
+#endif
+
 	struct address_space *mapping = file->f_mapping;
 	int err, ret;
 
@@ -187,6 +198,9 @@ int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)
 
 out:
 	return ret;
+#ifdef CONFIG_DYNAMIC_FSYNC
+	}
+#endif
 }
 EXPORT_SYMBOL(vfs_fsync_range);
 
@@ -219,11 +233,21 @@ static int do_fsync(unsigned int fd, int datasync)
 
 SYSCALL_DEFINE1(fsync, unsigned int, fd)
 {
+#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && !early_suspend_active))
+		return 0;
+	else
+#endif
 	return do_fsync(fd, 0);
 }
 
 SYSCALL_DEFINE1(fdatasync, unsigned int, fd)
 {
+#if 0
+	if (likely(dyn_fsync_active && !early_suspend_active))
+		return 0;
+	else
+#endif
 	return do_fsync(fd, 1);
 }
 
@@ -294,6 +318,12 @@ EXPORT_SYMBOL(generic_write_sync);
 SYSCALL_DEFINE(sync_file_range)(int fd, loff_t offset, loff_t nbytes,
 				unsigned int flags)
 {
+#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && !early_suspend_active))
+		return 0;
+	else {
+#endif
+
 	int ret;
 	struct file *file;
 	struct address_space *mapping;
@@ -373,6 +403,9 @@ out_put:
 	fput_light(file, fput_needed);
 out:
 	return ret;
+#ifdef CONFIG_DYNAMIC_FSYNC
+	}
+#endif
 }
 #ifdef CONFIG_HAVE_SYSCALL_WRAPPERS
 asmlinkage long SyS_sync_file_range(long fd, loff_t offset, loff_t nbytes,
@@ -389,6 +422,11 @@ SYSCALL_ALIAS(sys_sync_file_range, SyS_sync_file_range);
 SYSCALL_DEFINE(sync_file_range2)(int fd, unsigned int flags,
 				 loff_t offset, loff_t nbytes)
 {
+#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && !early_suspend_active))
+		return 0;
+	else
+#endif
 	return sys_sync_file_range(fd, offset, nbytes, flags);
 }
 #ifdef CONFIG_HAVE_SYSCALL_WRAPPERS
diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h
index 6395692..cee53e3 100644
--- a/include/linux/blk_types.h
+++ b/include/linux/blk_types.h
@@ -124,6 +124,7 @@ enum rq_flag_bits {
 
 	__REQ_SYNC,		/* request is sync (sync write or read) */
 	__REQ_META,		/* metadata io request */
+	__REQ_PRIO,		/* boost priority in cfq */
 	__REQ_DISCARD,		/* request to discard sectors */
 	__REQ_NOIDLE,		/* don't anticipate more IO after this one */
 
@@ -160,14 +161,15 @@ enum rq_flag_bits {
 #define REQ_FAILFAST_DRIVER	(1 << __REQ_FAILFAST_DRIVER)
 #define REQ_SYNC		(1 << __REQ_SYNC)
 #define REQ_META		(1 << __REQ_META)
+#define REQ_PRIO		(1 << __REQ_PRIO)
 #define REQ_DISCARD		(1 << __REQ_DISCARD)
 #define REQ_NOIDLE		(1 << __REQ_NOIDLE)
 
 #define REQ_FAILFAST_MASK \
 	(REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT | REQ_FAILFAST_DRIVER)
 #define REQ_COMMON_MASK \
-	(REQ_WRITE | REQ_FAILFAST_MASK | REQ_SYNC | REQ_META | REQ_DISCARD | \
-	 REQ_NOIDLE | REQ_FLUSH | REQ_FUA | REQ_SECURE)
+	(REQ_WRITE | REQ_FAILFAST_MASK | REQ_SYNC | REQ_META | REQ_PRIO | \
+	 REQ_DISCARD | REQ_NOIDLE | REQ_FLUSH | REQ_FUA | REQ_SECURE)
 #define REQ_CLONE_MASK		REQ_COMMON_MASK
 
 #define REQ_RAHEAD		(1 << __REQ_RAHEAD)
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 1b13021..1591139 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -275,6 +275,7 @@ struct request_queue
 	struct request_list	rq;
 
 	request_fn_proc		*request_fn;
+	request_fn_proc		*urgent_request_fn;
 	make_request_fn		*make_request_fn;
 	prep_rq_fn		*prep_rq_fn;
 	unprep_rq_fn		*unprep_rq_fn;
@@ -350,6 +351,8 @@ struct request_queue
 	struct list_head	timeout_list;
 
 	struct queue_limits	limits;
+	bool			notified_urgent;
+	bool			dispatched_urgent;
 
 	/*
 	 * sg stuff
@@ -551,7 +554,6 @@ static inline void blk_clear_queue_full(struct request_queue *q, int sync)
 		queue_flag_clear(QUEUE_FLAG_ASYNCFULL, q);
 }
 
-
 /*
  * mergeable request must not have _NOMERGE or _BARRIER bit set, nor may
  * it already be started by driver.
@@ -657,6 +659,8 @@ extern struct request *blk_make_request(struct request_queue *, struct bio *,
 					gfp_t);
 extern void blk_insert_request(struct request_queue *, struct request *, int, void *);
 extern void blk_requeue_request(struct request_queue *, struct request *);
+extern int blk_reinsert_request(struct request_queue *q, struct request *rq);
+extern bool blk_reinsert_req_sup(struct request_queue *q);
 extern void blk_add_request_payload(struct request *rq, struct page *page,
 		unsigned int len);
 extern int blk_rq_check_limits(struct request_queue *q, struct request *rq);
@@ -804,6 +808,7 @@ extern struct request_queue *blk_init_queue_node(request_fn_proc *rfn,
 extern struct request_queue *blk_init_queue(request_fn_proc *, spinlock_t *);
 extern struct request_queue *blk_init_allocated_queue(struct request_queue *,
 						      request_fn_proc *, spinlock_t *);
+extern void blk_urgent_request(struct request_queue *q, request_fn_proc *fn);
 extern void blk_cleanup_queue(struct request_queue *);
 extern void blk_queue_make_request(struct request_queue *, make_request_fn *);
 extern void blk_queue_bounce_limit(struct request_queue *, u64);
@@ -1342,7 +1347,6 @@ static inline void blk_schedule_flush_plug(struct task_struct *task)
 {
 }
 
-
 static inline bool blk_needs_flush_plug(struct task_struct *tsk)
 {
 	return false;
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 905ea72..8a38d74 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -24,7 +24,6 @@
 
 #define CPUFREQ_NAME_LEN 16
 
-
 /*********************************************************************
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/
@@ -132,7 +131,6 @@ struct cpufreq_freqs {
 	u8 flags;		/* flags of cpufreq_driver, see below. */
 };
 
-
 /**
  * cpufreq_scale - "old * mult / div" calculation for large values (32-bit-arch safe)
  * @old:   old value
@@ -192,14 +190,12 @@ extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int target_freq,
 				   unsigned int relation);
 
-
 extern int __cpufreq_driver_getavg(struct cpufreq_policy *policy,
 				   unsigned int cpu);
 
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 
-
 /*********************************************************************
  *                      CPUFREQ DRIVER INTERFACE                     *
  *********************************************************************/
@@ -251,10 +247,8 @@ struct cpufreq_driver {
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 
-
 void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);
 
-
 static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max)
 {
 	if (policy->min < min)
@@ -286,7 +280,7 @@ __ATTR(_name, _perm, show_##_name, NULL)
 
 #define cpufreq_freq_attr_rw(_name)		\
 static struct freq_attr _name =			\
-__ATTR(_name, 0644, show_##_name, store_##_name)
+__ATTR(_name, 0664, show_##_name, store_##_name)
 
 struct global_attr {
 	struct attribute attr;
@@ -302,8 +296,7 @@ __ATTR(_name, 0444, show_##_name, NULL)
 
 #define define_one_global_rw(_name)		\
 static struct global_attr _name =		\
-__ATTR(_name, 0644, show_##_name, store_##_name)
-
+__ATTR(_name, 0664, show_##_name, store_##_name)
 
 /*********************************************************************
  *                        CPUFREQ 2.6. INTERFACE                     *
@@ -331,12 +324,10 @@ static inline unsigned int cpufreq_quick_get(unsigned int cpu)
 }
 #endif
 
-
 /*********************************************************************
  *                       CPUFREQ DEFAULT GOVERNOR                    *
  *********************************************************************/
 
-
 /*
   Performance governor is fallback governor if any other gov failed to
   auto load due latency restrictions
@@ -361,12 +352,20 @@ extern struct cpufreq_governor cpufreq_gov_conservative;
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE)
 extern struct cpufreq_governor cpufreq_gov_interactive;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_interactive)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_LULZACTIVE)
+extern struct cpufreq_governor cpufreq_gov_lulzactive;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_lulzactive)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_LULZACTIVEQ)
+extern struct cpufreq_governor cpufreq_gov_lulzactiveq;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_lulzactiveq)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_PEGASUSQ)
+extern struct cpufreq_governor cpufreq_gov_pegasusq;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_pegasusq)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_HOTPLUG)
 extern struct cpufreq_governor cpufreq_gov_hotplug;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_hotplug)
 #endif
 
-
 /*********************************************************************
  *                     FREQUENCY TABLE HELPERS                       *
  *********************************************************************/
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 96b1035..ddddb89 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -17,44 +17,43 @@
  * nr_file rlimit, so it's safe to set up a ridiculously high absolute
  * upper limit on files-per-process.
  *
- * Some programs (notably those using select()) may have to be 
- * recompiled to take full advantage of the new limits..  
+ * Some programs (notably those using select()) may have to be
+ * recompiled to take full advantage of the new limits..
  */
 
 /* Fixed constants first: */
 #undef NR_OPEN
-#define INR_OPEN_CUR 1024	/* Initial setting for nfile rlimits */
-#define INR_OPEN_MAX 4096	/* Hard limit for nfile rlimits */
+#define INR_OPEN_CUR 1024        /* Initial setting for nfile rlimits */
+#define INR_OPEN_MAX 4096        /* Hard limit for nfile rlimits */
 
 #define BLOCK_SIZE_BITS 10
 #define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
 
-#define SEEK_SET	0	/* seek relative to beginning of file */
-#define SEEK_CUR	1	/* seek relative to current file position */
-#define SEEK_END	2	/* seek relative to end of file */
-#define SEEK_MAX	SEEK_END
+#define SEEK_SET        0        /* seek relative to beginning of file */
+#define SEEK_CUR        1        /* seek relative to current file position */
+#define SEEK_END        2        /* seek relative to end of file */
+#define SEEK_MAX        SEEK_END
 
 struct fstrim_range {
-	__u64 start;
-	__u64 len;
-	__u64 minlen;
+        __u64 start;
+        __u64 len;
+        __u64 minlen;
 };
 
 /* And dynamically-tunable limits and defaults: */
 struct files_stat_struct {
-	unsigned long nr_files;		/* read only */
-	unsigned long nr_free_files;	/* read only */
-	unsigned long max_files;		/* tunable */
+        unsigned long nr_files;                /* read only */
+        unsigned long nr_free_files;        /* read only */
+        unsigned long max_files;                /* tunable */
 };
 
 struct inodes_stat_t {
-	int nr_inodes;
-	int nr_unused;
-	int dummy[5];		/* padding for sysctl ABI compatibility */
+        int nr_inodes;
+        int nr_unused;
+        int dummy[5];                /* padding for sysctl ABI compatibility */
 };
 
-
-#define NR_FILE  8192	/* this can well be larger on a larger system */
+#define NR_FILE  8192        /* this can well be larger on a larger system */
 
 #define MAY_EXEC 1
 #define MAY_WRITE 2
@@ -70,24 +69,24 @@ struct inodes_stat_t {
  */
 
 /* file is open for reading */
-#define FMODE_READ		((__force fmode_t)0x1)
+#define FMODE_READ                ((__force fmode_t)0x1)
 /* file is open for writing */
-#define FMODE_WRITE		((__force fmode_t)0x2)
+#define FMODE_WRITE                ((__force fmode_t)0x2)
 /* file is seekable */
-#define FMODE_LSEEK		((__force fmode_t)0x4)
+#define FMODE_LSEEK                ((__force fmode_t)0x4)
 /* file can be accessed using pread */
-#define FMODE_PREAD		((__force fmode_t)0x8)
+#define FMODE_PREAD                ((__force fmode_t)0x8)
 /* file can be accessed using pwrite */
-#define FMODE_PWRITE		((__force fmode_t)0x10)
+#define FMODE_PWRITE                ((__force fmode_t)0x10)
 /* File is opened for execution with sys_execve / sys_uselib */
-#define FMODE_EXEC		((__force fmode_t)0x20)
+#define FMODE_EXEC                ((__force fmode_t)0x20)
 /* File is opened with O_NDELAY (only set for block devices) */
-#define FMODE_NDELAY		((__force fmode_t)0x40)
+#define FMODE_NDELAY                ((__force fmode_t)0x40)
 /* File is opened with O_EXCL (only set for block devices) */
-#define FMODE_EXCL		((__force fmode_t)0x80)
+#define FMODE_EXCL                ((__force fmode_t)0x80)
 /* File is opened using open(.., 3, ..) and is writeable only for ioctls
    (specialy hack for floppy.c) */
-#define FMODE_WRITE_IOCTL	((__force fmode_t)0x100)
+#define FMODE_WRITE_IOCTL        ((__force fmode_t)0x100)
 
 /*
  * Don't update ctime and mtime.
@@ -95,60 +94,60 @@ struct inodes_stat_t {
  * Currently a special hack for the XFS open_by_handle ioctl, but we'll
  * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.
  */
-#define FMODE_NOCMTIME		((__force fmode_t)0x800)
+#define FMODE_NOCMTIME                ((__force fmode_t)0x800)
 
 /* Expect random access pattern */
-#define FMODE_RANDOM		((__force fmode_t)0x1000)
+#define FMODE_RANDOM                ((__force fmode_t)0x1000)
 
 /* File is huge (eg. /dev/kmem): treat loff_t as unsigned */
-#define FMODE_UNSIGNED_OFFSET	((__force fmode_t)0x2000)
+#define FMODE_UNSIGNED_OFFSET        ((__force fmode_t)0x2000)
 
 /* File is opened with O_PATH; almost nothing can be done with it */
-#define FMODE_PATH		((__force fmode_t)0x4000)
+#define FMODE_PATH                ((__force fmode_t)0x4000)
 
 /* File was opened by fanotify and shouldn't generate fanotify events */
-#define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
+#define FMODE_NONOTIFY                ((__force fmode_t)0x1000000)
 
 /*
  * The below are the various read and write types that we support. Some of
  * them include behavioral modifiers that send information down to the
  * block layer and IO scheduler. Terminology:
  *
- *	The block layer uses device plugging to defer IO a little bit, in
- *	the hope that we will see more IO very shortly. This increases
- *	coalescing of adjacent IO and thus reduces the number of IOs we
- *	have to send to the device. It also allows for better queuing,
- *	if the IO isn't mergeable. If the caller is going to be waiting
- *	for the IO, then he must ensure that the device is unplugged so
- *	that the IO is dispatched to the driver.
+ *        The block layer uses device plugging to defer IO a little bit, in
+ *        the hope that we will see more IO very shortly. This increases
+ *        coalescing of adjacent IO and thus reduces the number of IOs we
+ *        have to send to the device. It also allows for better queuing,
+ *        if the IO isn't mergeable. If the caller is going to be waiting
+ *        for the IO, then he must ensure that the device is unplugged so
+ *        that the IO is dispatched to the driver.
  *
- *	All IO is handled async in Linux. This is fine for background
- *	writes, but for reads or writes that someone waits for completion
- *	on, we want to notify the block layer and IO scheduler so that they
- *	know about it. That allows them to make better scheduling
- *	decisions. So when the below references 'sync' and 'async', it
- *	is referencing this priority hint.
+ *        All IO is handled async in Linux. This is fine for background
+ *        writes, but for reads or writes that someone waits for completion
+ *        on, we want to notify the block layer and IO scheduler so that they
+ *        know about it. That allows them to make better scheduling
+ *        decisions. So when the below references 'sync' and 'async', it
+ *        is referencing this priority hint.
  *
  * With that in mind, the available types are:
  *
- * READ			A normal read operation. Device will be plugged.
- * READ_SYNC		A synchronous read. Device is not plugged, caller can
- *			immediately wait on this read without caring about
- *			unplugging.
- * READA		Used for read-ahead operations. Lower priority, and the
- *			block layer could (in theory) choose to ignore this
- *			request if it runs into resource problems.
- * WRITE		A normal async write. Device will be plugged.
- * WRITE_SYNC		Synchronous write. Identical to WRITE, but passes down
- *			the hint that someone will be waiting on this IO
- *			shortly. The write equivalent of READ_SYNC.
- * WRITE_ODIRECT	Special case write for O_DIRECT only.
- * WRITE_FLUSH		Like WRITE_SYNC but with preceding cache flush.
- * WRITE_FUA		Like WRITE_SYNC but data is guaranteed to be on
- *			non-volatile media on completion.
- * WRITE_FLUSH_FUA	Combination of WRITE_FLUSH and FUA. The IO is preceded
- *			by a cache flush and data is guaranteed to be on
- *			non-volatile media on completion.
+ * READ                        A normal read operation. Device will be plugged.
+ * READ_SYNC                A synchronous read. Device is not plugged, caller can
+ *                        immediately wait on this read without caring about
+ *                        unplugging.
+ * READA                Used for read-ahead operations. Lower priority, and the
+ *                        block layer could (in theory) choose to ignore this
+ *                        request if it runs into resource problems.
+ * WRITE                A normal async write. Device will be plugged.
+ * WRITE_SYNC                Synchronous write. Identical to WRITE, but passes down
+ *                        the hint that someone will be waiting on this IO
+ *                        shortly. The write equivalent of READ_SYNC.
+ * WRITE_ODIRECT        Special case write for O_DIRECT only.
+ * WRITE_FLUSH                Like WRITE_SYNC but with preceding cache flush.
+ * WRITE_FUA                Like WRITE_SYNC but data is guaranteed to be on
+ *                        non-volatile media on completion.
+ * WRITE_FLUSH_FUA        Combination of WRITE_FLUSH and FUA. The IO is preceded
+ *                        by a cache flush and data is guaranteed to be on
+ *                        non-volatile media on completion.
  *
  */
 #define RW_MASK			REQ_WRITE
@@ -172,51 +171,51 @@ struct inodes_stat_t {
 #define SEL_EX		4
 
 /* public flags for file_system_type */
-#define FS_REQUIRES_DEV 1 
+#define FS_REQUIRES_DEV 1
 #define FS_BINARY_MOUNTDATA 2
 #define FS_HAS_SUBTYPE 4
-#define FS_REVAL_DOT	16384	/* Check the paths ".", ".." for staleness */
-#define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move()
-					 * during rename() internally.
-					 */
+#define FS_REVAL_DOT        16384        /* Check the paths ".", ".." for staleness */
+#define FS_RENAME_DOES_D_MOVE        32768        /* FS will handle d_move()
+                                         * during rename() internally.
+                                         */
 
 /*
  * These are the fs-independent mount-flags: up to 32 flags are supported
  */
-#define MS_RDONLY	 1	/* Mount read-only */
-#define MS_NOSUID	 2	/* Ignore suid and sgid bits */
-#define MS_NODEV	 4	/* Disallow access to device special files */
-#define MS_NOEXEC	 8	/* Disallow program execution */
-#define MS_SYNCHRONOUS	16	/* Writes are synced at once */
-#define MS_REMOUNT	32	/* Alter flags of a mounted FS */
-#define MS_MANDLOCK	64	/* Allow mandatory locks on an FS */
-#define MS_DIRSYNC	128	/* Directory modifications are synchronous */
-#define MS_NOATIME	1024	/* Do not update access times. */
-#define MS_NODIRATIME	2048	/* Do not update directory access times */
-#define MS_BIND		4096
-#define MS_MOVE		8192
-#define MS_REC		16384
-#define MS_VERBOSE	32768	/* War is peace. Verbosity is silence.
-				   MS_VERBOSE is deprecated. */
-#define MS_SILENT	32768
-#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
-#define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
-#define MS_PRIVATE	(1<<18)	/* change to private */
-#define MS_SLAVE	(1<<19)	/* change to slave */
-#define MS_SHARED	(1<<20)	/* change to shared */
-#define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
-#define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
-#define MS_I_VERSION	(1<<23) /* Update inode I_version field */
-#define MS_STRICTATIME	(1<<24) /* Always perform atime updates */
-#define MS_NOSEC	(1<<28)
-#define MS_BORN		(1<<29)
-#define MS_ACTIVE	(1<<30)
-#define MS_NOUSER	(1<<31)
+#define MS_RDONLY         1        /* Mount read-only */
+#define MS_NOSUID         2        /* Ignore suid and sgid bits */
+#define MS_NODEV         4        /* Disallow access to device special files */
+#define MS_NOEXEC         8        /* Disallow program execution */
+#define MS_SYNCHRONOUS        16        /* Writes are synced at once */
+#define MS_REMOUNT        32        /* Alter flags of a mounted FS */
+#define MS_MANDLOCK        64        /* Allow mandatory locks on an FS */
+#define MS_DIRSYNC        128        /* Directory modifications are synchronous */
+#define MS_NOATIME        1024        /* Do not update access times. */
+#define MS_NODIRATIME        2048        /* Do not update directory access times */
+#define MS_BIND                4096
+#define MS_MOVE                8192
+#define MS_REC                16384
+#define MS_VERBOSE        32768        /* War is peace. Verbosity is silence.
+                                   MS_VERBOSE is deprecated. */
+#define MS_SILENT        32768
+#define MS_POSIXACL        (1<<16)        /* VFS does not apply the umask */
+#define MS_UNBINDABLE        (1<<17)        /* change to unbindable */
+#define MS_PRIVATE        (1<<18)        /* change to private */
+#define MS_SLAVE        (1<<19)        /* change to slave */
+#define MS_SHARED        (1<<20)        /* change to shared */
+#define MS_RELATIME        (1<<21)        /* Update atime relative to mtime/ctime. */
+#define MS_KERNMOUNT        (1<<22) /* this is a kern_mount call */
+#define MS_I_VERSION        (1<<23) /* Update inode I_version field */
+#define MS_STRICTATIME        (1<<24) /* Always perform atime updates */
+#define MS_NOSEC        (1<<28)
+#define MS_BORN                (1<<29)
+#define MS_ACTIVE        (1<<30)
+#define MS_NOUSER        (1<<31)
 
 /*
  * Superblock flags that can be altered by MS_REMOUNT
  */
-#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)
+#define MS_RMT_MASK        (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)
 
 /*
  * Old magic mount flag and mask
@@ -226,19 +225,19 @@ struct inodes_stat_t {
 
 /* Inode flags - they have nothing to superblock flags now */
 
-#define S_SYNC		1	/* Writes are synced at once */
-#define S_NOATIME	2	/* Do not update access times */
-#define S_APPEND	4	/* Append-only file */
-#define S_IMMUTABLE	8	/* Immutable file */
-#define S_DEAD		16	/* removed, but still open directory */
-#define S_NOQUOTA	32	/* Inode is not counted to quota */
-#define S_DIRSYNC	64	/* Directory modifications are synchronous */
-#define S_NOCMTIME	128	/* Do not update file c/mtime */
-#define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
-#define S_PRIVATE	512	/* Inode is fs-internal */
-#define S_IMA		1024	/* Inode has an associated IMA struct */
-#define S_AUTOMOUNT	2048	/* Automount/referral quasi-directory */
-#define S_NOSEC		4096	/* no suid or xattr security attributes */
+#define S_SYNC                1        /* Writes are synced at once */
+#define S_NOATIME        2        /* Do not update access times */
+#define S_APPEND        4        /* Append-only file */
+#define S_IMMUTABLE        8        /* Immutable file */
+#define S_DEAD                16        /* removed, but still open directory */
+#define S_NOQUOTA        32        /* Inode is not counted to quota */
+#define S_DIRSYNC        64        /* Directory modifications are synchronous */
+#define S_NOCMTIME        128        /* Do not update file c/mtime */
+#define S_SWAPFILE        256        /* Do not truncate: swapon got its bmaps */
+#define S_PRIVATE        512        /* Inode is fs-internal */
+#define S_IMA                1024        /* Inode has an associated IMA struct */
+#define S_AUTOMOUNT        2048        /* Automount/referral quasi-directory */
+#define S_NOSEC                4096        /* no suid or xattr security attributes */
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -256,37 +255,37 @@ struct inodes_stat_t {
 #define __IS_FLG(inode,flg) ((inode)->i_sb->s_flags & (flg))
 
 #define IS_RDONLY(inode) ((inode)->i_sb->s_flags & MS_RDONLY)
-#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \
-					((inode)->i_flags & S_SYNC))
-#define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
-					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
-#define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
+#define IS_SYNC(inode)                (__IS_FLG(inode, MS_SYNCHRONOUS) || \
+                                        ((inode)->i_flags & S_SYNC))
+#define IS_DIRSYNC(inode)        (__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
+                                        ((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
+#define IS_MANDLOCK(inode)        __IS_FLG(inode, MS_MANDLOCK)
 #define IS_NOATIME(inode)   __IS_FLG(inode, MS_RDONLY|MS_NOATIME)
 #define IS_I_VERSION(inode)   __IS_FLG(inode, MS_I_VERSION)
 
-#define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
-#define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
-#define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
-#define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
+#define IS_NOQUOTA(inode)        ((inode)->i_flags & S_NOQUOTA)
+#define IS_APPEND(inode)        ((inode)->i_flags & S_APPEND)
+#define IS_IMMUTABLE(inode)        ((inode)->i_flags & S_IMMUTABLE)
+#define IS_POSIXACL(inode)        __IS_FLG(inode, MS_POSIXACL)
 
-#define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
-#define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
-#define IS_SWAPFILE(inode)	((inode)->i_flags & S_SWAPFILE)
-#define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
-#define IS_IMA(inode)		((inode)->i_flags & S_IMA)
-#define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
-#define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
+#define IS_DEADDIR(inode)        ((inode)->i_flags & S_DEAD)
+#define IS_NOCMTIME(inode)        ((inode)->i_flags & S_NOCMTIME)
+#define IS_SWAPFILE(inode)        ((inode)->i_flags & S_SWAPFILE)
+#define IS_PRIVATE(inode)        ((inode)->i_flags & S_PRIVATE)
+#define IS_IMA(inode)                ((inode)->i_flags & S_IMA)
+#define IS_AUTOMOUNT(inode)        ((inode)->i_flags & S_AUTOMOUNT)
+#define IS_NOSEC(inode)                ((inode)->i_flags & S_NOSEC)
 
 /* the read-only stuff doesn't really belong here, but any other place is
    probably as bad and I don't want to create yet another include file. */
 
-#define BLKROSET   _IO(0x12,93)	/* set device read-only (0 = read-write) */
-#define BLKROGET   _IO(0x12,94)	/* get read-only status (0 = read_write) */
-#define BLKRRPART  _IO(0x12,95)	/* re-read partition table */
-#define BLKGETSIZE _IO(0x12,96)	/* return device size /512 (long *arg) */
-#define BLKFLSBUF  _IO(0x12,97)	/* flush buffer cache */
-#define BLKRASET   _IO(0x12,98)	/* set read ahead for block device */
-#define BLKRAGET   _IO(0x12,99)	/* get current read ahead setting */
+#define BLKROSET   _IO(0x12,93)        /* set device read-only (0 = read-write) */
+#define BLKROGET   _IO(0x12,94)        /* get read-only status (0 = read_write) */
+#define BLKRRPART  _IO(0x12,95)        /* re-read partition table */
+#define BLKGETSIZE _IO(0x12,96)        /* return device size /512 (long *arg) */
+#define BLKFLSBUF  _IO(0x12,97)        /* flush buffer cache */
+#define BLKRASET   _IO(0x12,98)        /* set read ahead for block device */
+#define BLKRAGET   _IO(0x12,99)        /* get current read ahead setting */
 #define BLKFRASET  _IO(0x12,100)/* set filesystem (mm/filemap.c) read-ahead */
 #define BLKFRAGET  _IO(0x12,101)/* get filesystem (mm/filemap.c) read-ahead */
 #define BLKSECTSET _IO(0x12,102)/* set max sectors per request (ll_rw_blk.c) */
@@ -305,7 +304,7 @@ struct inodes_stat_t {
 /* A jump here: 108-111 have been used for various private purposes. */
 #define BLKBSZGET  _IOR(0x12,112,size_t)
 #define BLKBSZSET  _IOW(0x12,113,size_t)
-#define BLKGETSIZE64 _IOR(0x12,114,size_t)	/* return device size in bytes (u64 *arg) */
+#define BLKGETSIZE64 _IOR(0x12,114,size_t)        /* return device size in bytes (u64 *arg) */
 #define BLKTRACESETUP _IOWR(0x12,115,struct blk_user_trace_setup)
 #define BLKTRACESTART _IO(0x12,116)
 #define BLKTRACESTOP _IO(0x12,117)
@@ -318,59 +317,58 @@ struct inodes_stat_t {
 #define BLKDISCARDZEROES _IO(0x12,124)
 #define BLKSECDISCARD _IO(0x12,125)
 
-#define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
-#define FIBMAP	   _IO(0x00,1)	/* bmap access */
-#define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
-#define FIFREEZE	_IOWR('X', 119, int)	/* Freeze */
-#define FITHAW		_IOWR('X', 120, int)	/* Thaw */
-#define FITRIM		_IOWR('X', 121, struct fstrim_range)	/* Trim */
-
-#define	FS_IOC_GETFLAGS			_IOR('f', 1, long)
-#define	FS_IOC_SETFLAGS			_IOW('f', 2, long)
-#define	FS_IOC_GETVERSION		_IOR('v', 1, long)
-#define	FS_IOC_SETVERSION		_IOW('v', 2, long)
-#define FS_IOC_FIEMAP			_IOWR('f', 11, struct fiemap)
-#define FS_IOC32_GETFLAGS		_IOR('f', 1, int)
-#define FS_IOC32_SETFLAGS		_IOW('f', 2, int)
-#define FS_IOC32_GETVERSION		_IOR('v', 1, int)
-#define FS_IOC32_SETVERSION		_IOW('v', 2, int)
+#define BMAP_IOCTL 1                /* obsolete - kept for compatibility */
+#define FIBMAP           _IO(0x00,1)        /* bmap access */
+#define FIGETBSZ   _IO(0x00,2)        /* get the block size used for bmap */
+#define FIFREEZE        _IOWR('X', 119, int)        /* Freeze */
+#define FITHAW                _IOWR('X', 120, int)        /* Thaw */
+#define FITRIM                _IOWR('X', 121, struct fstrim_range)        /* Trim */
+
+#define        FS_IOC_GETFLAGS                        _IOR('f', 1, long)
+#define        FS_IOC_SETFLAGS                        _IOW('f', 2, long)
+#define        FS_IOC_GETVERSION                _IOR('v', 1, long)
+#define        FS_IOC_SETVERSION                _IOW('v', 2, long)
+#define FS_IOC_FIEMAP                        _IOWR('f', 11, struct fiemap)
+#define FS_IOC32_GETFLAGS                _IOR('f', 1, int)
+#define FS_IOC32_SETFLAGS                _IOW('f', 2, int)
+#define FS_IOC32_GETVERSION                _IOR('v', 1, int)
+#define FS_IOC32_SETVERSION                _IOW('v', 2, int)
 
 /*
  * Inode flags (FS_IOC_GETFLAGS / FS_IOC_SETFLAGS)
  */
-#define	FS_SECRM_FL			0x00000001 /* Secure deletion */
-#define	FS_UNRM_FL			0x00000002 /* Undelete */
-#define	FS_COMPR_FL			0x00000004 /* Compress file */
-#define FS_SYNC_FL			0x00000008 /* Synchronous updates */
-#define FS_IMMUTABLE_FL			0x00000010 /* Immutable file */
-#define FS_APPEND_FL			0x00000020 /* writes to file may only append */
-#define FS_NODUMP_FL			0x00000040 /* do not dump file */
-#define FS_NOATIME_FL			0x00000080 /* do not update atime */
+#define        FS_SECRM_FL                        0x00000001 /* Secure deletion */
+#define        FS_UNRM_FL                        0x00000002 /* Undelete */
+#define        FS_COMPR_FL                        0x00000004 /* Compress file */
+#define FS_SYNC_FL                        0x00000008 /* Synchronous updates */
+#define FS_IMMUTABLE_FL                        0x00000010 /* Immutable file */
+#define FS_APPEND_FL                        0x00000020 /* writes to file may only append */
+#define FS_NODUMP_FL                        0x00000040 /* do not dump file */
+#define FS_NOATIME_FL                        0x00000080 /* do not update atime */
 /* Reserved for compression usage... */
-#define FS_DIRTY_FL			0x00000100
-#define FS_COMPRBLK_FL			0x00000200 /* One or more compressed clusters */
-#define FS_NOCOMP_FL			0x00000400 /* Don't compress */
-#define FS_ECOMPR_FL			0x00000800 /* Compression error */
+#define FS_DIRTY_FL                        0x00000100
+#define FS_COMPRBLK_FL                        0x00000200 /* One or more compressed clusters */
+#define FS_NOCOMP_FL                        0x00000400 /* Don't compress */
+#define FS_ECOMPR_FL                        0x00000800 /* Compression error */
 /* End compression flags --- maybe not all used */
-#define FS_BTREE_FL			0x00001000 /* btree format dir */
-#define FS_INDEX_FL			0x00001000 /* hash-indexed directory */
-#define FS_IMAGIC_FL			0x00002000 /* AFS directory */
-#define FS_JOURNAL_DATA_FL		0x00004000 /* Reserved for ext3 */
-#define FS_NOTAIL_FL			0x00008000 /* file tail should not be merged */
-#define FS_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
-#define FS_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
-#define FS_EXTENT_FL			0x00080000 /* Extents */
-#define FS_DIRECTIO_FL			0x00100000 /* Use direct i/o */
-#define FS_NOCOW_FL			0x00800000 /* Do not cow file */
-#define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */
-
-#define FS_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
-#define FS_FL_USER_MODIFIABLE		0x000380FF /* User modifiable flags */
-
-
-#define SYNC_FILE_RANGE_WAIT_BEFORE	1
-#define SYNC_FILE_RANGE_WRITE		2
-#define SYNC_FILE_RANGE_WAIT_AFTER	4
+#define FS_BTREE_FL                        0x00001000 /* btree format dir */
+#define FS_INDEX_FL                        0x00001000 /* hash-indexed directory */
+#define FS_IMAGIC_FL                        0x00002000 /* AFS directory */
+#define FS_JOURNAL_DATA_FL                0x00004000 /* Reserved for ext3 */
+#define FS_NOTAIL_FL                        0x00008000 /* file tail should not be merged */
+#define FS_DIRSYNC_FL                        0x00010000 /* dirsync behaviour (directories only) */
+#define FS_TOPDIR_FL                        0x00020000 /* Top of directory hierarchies*/
+#define FS_EXTENT_FL                        0x00080000 /* Extents */
+#define FS_DIRECTIO_FL                        0x00100000 /* Use direct i/o */
+#define FS_NOCOW_FL                        0x00800000 /* Do not cow file */
+#define FS_RESERVED_FL                        0x80000000 /* reserved for ext2 lib */
+
+#define FS_FL_USER_VISIBLE                0x0003DFFF /* User visible flags */
+#define FS_FL_USER_MODIFIABLE                0x000380FF /* User modifiable flags */
+
+#define SYNC_FILE_RANGE_WAIT_BEFORE        1
+#define SYNC_FILE_RANGE_WRITE                2
+#define SYNC_FILE_RANGE_WAIT_AFTER        4
 
 #ifdef __KERNEL__
 
@@ -421,32 +419,32 @@ extern int leases_enable, lease_break_time;
 
 struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,
-			struct buffer_head *bh_result, int create);
+                        struct buffer_head *bh_result, int create);
 typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
-			ssize_t bytes, void *private, int ret,
-			bool is_async);
+                        ssize_t bytes, void *private, int ret,
+                        bool is_async);
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what
  * has been changed!
  */
-#define ATTR_MODE	(1 << 0)
-#define ATTR_UID	(1 << 1)
-#define ATTR_GID	(1 << 2)
-#define ATTR_SIZE	(1 << 3)
-#define ATTR_ATIME	(1 << 4)
-#define ATTR_MTIME	(1 << 5)
-#define ATTR_CTIME	(1 << 6)
-#define ATTR_ATIME_SET	(1 << 7)
-#define ATTR_MTIME_SET	(1 << 8)
-#define ATTR_FORCE	(1 << 9) /* Not a change, but a change it */
-#define ATTR_ATTR_FLAG	(1 << 10)
-#define ATTR_KILL_SUID	(1 << 11)
-#define ATTR_KILL_SGID	(1 << 12)
-#define ATTR_FILE	(1 << 13)
-#define ATTR_KILL_PRIV	(1 << 14)
-#define ATTR_OPEN	(1 << 15) /* Truncating from open(O_TRUNC) */
-#define ATTR_TIMES_SET	(1 << 16)
+#define ATTR_MODE        (1 << 0)
+#define ATTR_UID        (1 << 1)
+#define ATTR_GID        (1 << 2)
+#define ATTR_SIZE        (1 << 3)
+#define ATTR_ATIME        (1 << 4)
+#define ATTR_MTIME        (1 << 5)
+#define ATTR_CTIME        (1 << 6)
+#define ATTR_ATIME_SET        (1 << 7)
+#define ATTR_MTIME_SET        (1 << 8)
+#define ATTR_FORCE        (1 << 9) /* Not a change, but a change it */
+#define ATTR_ATTR_FLAG        (1 << 10)
+#define ATTR_KILL_SUID        (1 << 11)
+#define ATTR_KILL_SGID        (1 << 12)
+#define ATTR_FILE        (1 << 13)
+#define ATTR_KILL_PRIV        (1 << 14)
+#define ATTR_OPEN        (1 << 15) /* Truncating from open(O_TRUNC) */
+#define ATTR_TIMES_SET        (1 << 16)
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -458,21 +456,21 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
  * Derek Atkins <warlord@MIT.EDU> 94-10-20
  */
 struct iattr {
-	unsigned int	ia_valid;
-	umode_t		ia_mode;
-	uid_t		ia_uid;
-	gid_t		ia_gid;
-	loff_t		ia_size;
-	struct timespec	ia_atime;
-	struct timespec	ia_mtime;
-	struct timespec	ia_ctime;
-
-	/*
-	 * Not an attribute, but an auxiliary info for filesystems wanting to
-	 * implement an ftruncate() like method.  NOTE: filesystem should
-	 * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).
-	 */
-	struct file	*ia_file;
+        unsigned int        ia_valid;
+        umode_t                ia_mode;
+        uid_t                ia_uid;
+        gid_t                ia_gid;
+        loff_t                ia_size;
+        struct timespec        ia_atime;
+        struct timespec        ia_mtime;
+        struct timespec        ia_ctime;
+
+        /*
+         * Not an attribute, but an auxiliary info for filesystems wanting to
+         * implement an ftruncate() like method.  NOTE: filesystem should
+         * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).
+         */
+        struct file        *ia_file;
 };
 
 /*
@@ -480,25 +478,25 @@ struct iattr {
  */
 #include <linux/quota.h>
 
-/** 
+/**
  * enum positive_aop_returns - aop return codes with specific semantics
  *
  * @AOP_WRITEPAGE_ACTIVATE: Informs the caller that page writeback has
- * 			    completed, that the page is still locked, and
- * 			    should be considered active.  The VM uses this hint
- * 			    to return the page to the active list -- it won't
- * 			    be a candidate for writeback again in the near
- * 			    future.  Other callers must be careful to unlock
- * 			    the page if they get this return.  Returned by
- * 			    writepage(); 
+ *                             completed, that the page is still locked, and
+ *                             should be considered active.  The VM uses this hint
+ *                             to return the page to the active list -- it won't
+ *                             be a candidate for writeback again in the near
+ *                             future.  Other callers must be careful to unlock
+ *                             the page if they get this return.  Returned by
+ *                             writepage();
  *
  * @AOP_TRUNCATED_PAGE: The AOP method that was handed a locked page has
- *  			unlocked it and the page might have been truncated.
- *  			The caller should back up to acquiring a new page and
- *  			trying again.  The aop will be taking reasonable
- *  			precautions not to livelock.  If the caller held a page
- *  			reference, it should drop it before retrying.  Returned
- *  			by readpage().
+ *                          unlocked it and the page might have been truncated.
+ *                          The caller should back up to acquiring a new page and
+ *                          trying again.  The aop will be taking reasonable
+ *                          precautions not to livelock.  If the caller held a page
+ *                          reference, it should drop it before retrying.  Returned
+ *                          by readpage().
  *
  * address_space_operation functions return these large constants to indicate
  * special semantics to the caller.  These are much larger than the bytes in a
@@ -507,15 +505,15 @@ struct iattr {
  */
 
 enum positive_aop_returns {
-	AOP_WRITEPAGE_ACTIVATE	= 0x80000,
-	AOP_TRUNCATED_PAGE	= 0x80001,
+        AOP_WRITEPAGE_ACTIVATE        = 0x80000,
+        AOP_TRUNCATED_PAGE        = 0x80001,
 };
 
-#define AOP_FLAG_UNINTERRUPTIBLE	0x0001 /* will not do a short write */
-#define AOP_FLAG_CONT_EXPAND		0x0002 /* called from cont_expand */
-#define AOP_FLAG_NOFS			0x0004 /* used by filesystem to direct
-						* helper code (eg buffer layer)
-						* to clear GFP_FS from alloc */
+#define AOP_FLAG_UNINTERRUPTIBLE        0x0001 /* will not do a short write */
+#define AOP_FLAG_CONT_EXPAND                0x0002 /* called from cont_expand */
+#define AOP_FLAG_NOFS                        0x0004 /* used by filesystem to direct
+                                                * helper code (eg buffer layer)
+                                                * to clear GFP_FS from alloc */
 
 /*
  * oh the beauties of C type declarations.
@@ -523,37 +521,38 @@ enum positive_aop_returns {
 struct page;
 struct address_space;
 struct writeback_control;
+enum migrate_mode;
 
 struct iov_iter {
-	const struct iovec *iov;
-	unsigned long nr_segs;
-	size_t iov_offset;
-	size_t count;
+        const struct iovec *iov;
+        unsigned long nr_segs;
+        size_t iov_offset;
+        size_t count;
 };
 
 size_t iov_iter_copy_from_user_atomic(struct page *page,
-		struct iov_iter *i, unsigned long offset, size_t bytes);
+                struct iov_iter *i, unsigned long offset, size_t bytes);
 size_t iov_iter_copy_from_user(struct page *page,
-		struct iov_iter *i, unsigned long offset, size_t bytes);
+                struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
 int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
 size_t iov_iter_single_seg_count(struct iov_iter *i);
 
 static inline void iov_iter_init(struct iov_iter *i,
-			const struct iovec *iov, unsigned long nr_segs,
-			size_t count, size_t written)
+                        const struct iovec *iov, unsigned long nr_segs,
+                        size_t count, size_t written)
 {
-	i->iov = iov;
-	i->nr_segs = nr_segs;
-	i->iov_offset = 0;
-	i->count = count + written;
+        i->iov = iov;
+        i->nr_segs = nr_segs;
+        i->iov_offset = 0;
+        i->count = count + written;
 
-	iov_iter_advance(i, written);
+        iov_iter_advance(i, written);
 }
 
 static inline size_t iov_iter_count(struct iov_iter *i)
 {
-	return i->count;
+        return i->count;
 }
 
 /*
@@ -566,54 +565,57 @@ static inline size_t iov_iter_count(struct iov_iter *i)
  * mode.
  */
 typedef struct {
-	size_t written;
-	size_t count;
-	union {
-		char __user *buf;
-		void *data;
-	} arg;
-	int error;
+        size_t written;
+        size_t count;
+        union {
+                char __user *buf;
+                void *data;
+        } arg;
+        int error;
 } read_descriptor_t;
 
 typedef int (*read_actor_t)(read_descriptor_t *, struct page *,
-		unsigned long, unsigned long);
+                unsigned long, unsigned long);
 
 struct address_space_operations {
-	int (*writepage)(struct page *page, struct writeback_control *wbc);
-	int (*readpage)(struct file *, struct page *);
-
-	/* Write back some dirty pages from this mapping. */
-	int (*writepages)(struct address_space *, struct writeback_control *);
-
-	/* Set a page dirty.  Return true if this dirtied it */
-	int (*set_page_dirty)(struct page *page);
-
-	int (*readpages)(struct file *filp, struct address_space *mapping,
-			struct list_head *pages, unsigned nr_pages);
-
-	int (*write_begin)(struct file *, struct address_space *mapping,
-				loff_t pos, unsigned len, unsigned flags,
-				struct page **pagep, void **fsdata);
-	int (*write_end)(struct file *, struct address_space *mapping,
-				loff_t pos, unsigned len, unsigned copied,
-				struct page *page, void *fsdata);
-
-	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
-	sector_t (*bmap)(struct address_space *, sector_t);
-	void (*invalidatepage) (struct page *, unsigned long);
-	int (*releasepage) (struct page *, gfp_t);
-	void (*freepage)(struct page *);
-	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
-			loff_t offset, unsigned long nr_segs);
-	int (*get_xip_mem)(struct address_space *, pgoff_t, int,
-						void **, unsigned long *);
-	/* migrate the contents of a page to the specified target */
-	int (*migratepage) (struct address_space *,
-			struct page *, struct page *);
-	int (*launder_page) (struct page *);
-	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
-					unsigned long);
-	int (*error_remove_page)(struct address_space *, struct page *);
+        int (*writepage)(struct page *page, struct writeback_control *wbc);
+        int (*readpage)(struct file *, struct page *);
+
+        /* Write back some dirty pages from this mapping. */
+        int (*writepages)(struct address_space *, struct writeback_control *);
+
+        /* Set a page dirty.  Return true if this dirtied it */
+        int (*set_page_dirty)(struct page *page);
+
+        int (*readpages)(struct file *filp, struct address_space *mapping,
+                        struct list_head *pages, unsigned nr_pages);
+
+        int (*write_begin)(struct file *, struct address_space *mapping,
+                                loff_t pos, unsigned len, unsigned flags,
+                                struct page **pagep, void **fsdata);
+        int (*write_end)(struct file *, struct address_space *mapping,
+                                loff_t pos, unsigned len, unsigned copied,
+                                struct page *page, void *fsdata);
+
+        /* Unfortunately this kludge is needed for FIBMAP. Don't use it */
+        sector_t (*bmap)(struct address_space *, sector_t);
+        void (*invalidatepage) (struct page *, unsigned long);
+        int (*releasepage) (struct page *, gfp_t);
+        void (*freepage)(struct page *);
+        ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
+                        loff_t offset, unsigned long nr_segs);
+        int (*get_xip_mem)(struct address_space *, pgoff_t, int,
+                                                void **, unsigned long *);
+	/*
+	 * migrate the contents of a page to the specified target. If sync
+	 * is false, it must not block.
+	 */
+        int (*migratepage) (struct address_space *,
+			struct page *, struct page *, enum migrate_mode);
+        int (*launder_page) (struct page *);
+        int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
+                                        unsigned long);
+        int (*error_remove_page)(struct address_space *, struct page *);
 };
 
 extern const struct address_space_operations empty_aops;
@@ -623,81 +625,81 @@ extern const struct address_space_operations empty_aops;
  * to write into the pagecache.
  */
 int pagecache_write_begin(struct file *, struct address_space *mapping,
-				loff_t pos, unsigned len, unsigned flags,
-				struct page **pagep, void **fsdata);
+                                loff_t pos, unsigned len, unsigned flags,
+                                struct page **pagep, void **fsdata);
 
 int pagecache_write_end(struct file *, struct address_space *mapping,
-				loff_t pos, unsigned len, unsigned copied,
-				struct page *page, void *fsdata);
+                                loff_t pos, unsigned len, unsigned copied,
+                                struct page *page, void *fsdata);
 
 struct backing_dev_info;
 struct address_space {
-	struct inode		*host;		/* owner: inode, block_device */
-	struct radix_tree_root	page_tree;	/* radix tree of all pages */
-	spinlock_t		tree_lock;	/* and lock protecting it */
-	unsigned int		i_mmap_writable;/* count VM_SHARED mappings */
-	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
-	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
-	struct mutex		i_mmap_mutex;	/* protect tree, count, list */
-	/* Protected by tree_lock together with the radix tree */
-	unsigned long		nrpages;	/* number of total pages */
-	pgoff_t			writeback_index;/* writeback starts here */
-	const struct address_space_operations *a_ops;	/* methods */
-	unsigned long		flags;		/* error bits/gfp mask */
-	struct backing_dev_info *backing_dev_info; /* device readahead, etc */
-	spinlock_t		private_lock;	/* for use by the address_space */
-	struct list_head	private_list;	/* ditto */
-	struct address_space	*assoc_mapping;	/* ditto */
+        struct inode                *host;                /* owner: inode, block_device */
+        struct radix_tree_root        page_tree;        /* radix tree of all pages */
+        spinlock_t                tree_lock;        /* and lock protecting it */
+        unsigned int                i_mmap_writable;/* count VM_SHARED mappings */
+        struct prio_tree_root        i_mmap;                /* tree of private and shared mappings */
+        struct list_head        i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
+        struct mutex                i_mmap_mutex;        /* protect tree, count, list */
+        /* Protected by tree_lock together with the radix tree */
+        unsigned long                nrpages;        /* number of total pages */
+        pgoff_t                        writeback_index;/* writeback starts here */
+        const struct address_space_operations *a_ops;        /* methods */
+        unsigned long                flags;                /* error bits/gfp mask */
+        struct backing_dev_info *backing_dev_info; /* device readahead, etc */
+        spinlock_t                private_lock;        /* for use by the address_space */
+        struct list_head        private_list;        /* ditto */
+        struct address_space        *assoc_mapping;        /* ditto */
 } __attribute__((aligned(sizeof(long))));
-	/*
-	 * On most architectures that alignment is already the case; but
-	 * must be enforced here for CRIS, to let the least significant bit
-	 * of struct page's "mapping" pointer be used for PAGE_MAPPING_ANON.
-	 */
+        /*
+         * On most architectures that alignment is already the case; but
+         * must be enforced here for CRIS, to let the least significant bit
+         * of struct page's "mapping" pointer be used for PAGE_MAPPING_ANON.
+         */
 
 struct block_device {
-	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
-	int			bd_openers;
-	struct inode *		bd_inode;	/* will die */
-	struct super_block *	bd_super;
-	struct mutex		bd_mutex;	/* open/close mutex */
-	struct list_head	bd_inodes;
-	void *			bd_claiming;
-	void *			bd_holder;
-	int			bd_holders;
-	bool			bd_write_holder;
+        dev_t                        bd_dev;  /* not a kdev_t - it's a search key */
+        int                        bd_openers;
+        struct inode *                bd_inode;        /* will die */
+        struct super_block *        bd_super;
+        struct mutex                bd_mutex;        /* open/close mutex */
+        struct list_head        bd_inodes;
+        void *                        bd_claiming;
+        void *                        bd_holder;
+        int                        bd_holders;
+        bool                        bd_write_holder;
 #ifdef CONFIG_SYSFS
-	struct list_head	bd_holder_disks;
+        struct list_head        bd_holder_disks;
 #endif
-	struct block_device *	bd_contains;
-	unsigned		bd_block_size;
-	struct hd_struct *	bd_part;
-	/* number of times partitions within this device have been opened. */
-	unsigned		bd_part_count;
-	int			bd_invalidated;
-	struct gendisk *	bd_disk;
-	struct list_head	bd_list;
-	/*
-	 * Private data.  You must have bd_claim'ed the block_device
-	 * to use this.  NOTE:  bd_claim allows an owner to claim
-	 * the same device multiple times, the owner must take special
-	 * care to not mess up bd_private for that case.
-	 */
-	unsigned long		bd_private;
-
-	/* The counter of freeze processes */
-	int			bd_fsfreeze_count;
-	/* Mutex for freeze */
-	struct mutex		bd_fsfreeze_mutex;
+        struct block_device *        bd_contains;
+        unsigned                bd_block_size;
+        struct hd_struct *        bd_part;
+        /* number of times partitions within this device have been opened. */
+        unsigned                bd_part_count;
+        int                        bd_invalidated;
+        struct gendisk *        bd_disk;
+        struct list_head        bd_list;
+        /*
+         * Private data.  You must have bd_claim'ed the block_device
+         * to use this.  NOTE:  bd_claim allows an owner to claim
+         * the same device multiple times, the owner must take special
+         * care to not mess up bd_private for that case.
+         */
+        unsigned long                bd_private;
+
+        /* The counter of freeze processes */
+        int                        bd_fsfreeze_count;
+        /* Mutex for freeze */
+        struct mutex                bd_fsfreeze_mutex;
 };
 
 /*
  * Radix-tree tags, for tagging dirty and writeback pages within the pagecache
  * radix trees
  */
-#define PAGECACHE_TAG_DIRTY	0
-#define PAGECACHE_TAG_WRITEBACK	1
-#define PAGECACHE_TAG_TOWRITE	2
+#define PAGECACHE_TAG_DIRTY        0
+#define PAGECACHE_TAG_WRITEBACK        1
+#define PAGECACHE_TAG_TOWRITE        2
 
 int mapping_tagged(struct address_space *mapping, int tag);
 
@@ -706,8 +708,8 @@ int mapping_tagged(struct address_space *mapping, int tag);
  */
 static inline int mapping_mapped(struct address_space *mapping)
 {
-	return	!prio_tree_empty(&mapping->i_mmap) ||
-		!list_empty(&mapping->i_mmap_nonlinear);
+        return        !prio_tree_empty(&mapping->i_mmap) ||
+                !list_empty(&mapping->i_mmap_nonlinear);
 }
 
 /*
@@ -718,7 +720,7 @@ static inline int mapping_mapped(struct address_space *mapping)
  */
 static inline int mapping_writably_mapped(struct address_space *mapping)
 {
-	return mapping->i_mmap_writable != 0;
+        return mapping->i_mmap_writable != 0;
 }
 
 /*
@@ -736,83 +738,82 @@ struct posix_acl;
 #define ACL_NOT_CACHED ((void *)(-1))
 
 struct inode {
-	/* RCU path lookup touches following: */
-	umode_t			i_mode;
-	uid_t			i_uid;
-	gid_t			i_gid;
-	const struct inode_operations	*i_op;
-	struct super_block	*i_sb;
-
-	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
-	unsigned int		i_flags;
-	unsigned long		i_state;
+        /* RCU path lookup touches following: */
+        umode_t                        i_mode;
+        uid_t                        i_uid;
+        gid_t                        i_gid;
+        const struct inode_operations        *i_op;
+        struct super_block        *i_sb;
+
+        spinlock_t                i_lock;        /* i_blocks, i_bytes, maybe i_size */
+        unsigned int                i_flags;
+        unsigned long                i_state;
 #ifdef CONFIG_SECURITY
-	void			*i_security;
+        void                        *i_security;
 #endif
-	struct mutex		i_mutex;
-
-
-	unsigned long		dirtied_when;	/* jiffies of first dirtying */
-
-	struct hlist_node	i_hash;
-	struct list_head	i_wb_list;	/* backing dev IO list */
-	struct list_head	i_lru;		/* inode LRU list */
-	struct list_head	i_sb_list;
-	union {
-		struct list_head	i_dentry;
-		struct rcu_head		i_rcu;
-	};
-	unsigned long		i_ino;
-	atomic_t		i_count;
-	unsigned int		i_nlink;
-	dev_t			i_rdev;
-	unsigned int		i_blkbits;
-	u64			i_version;
-	loff_t			i_size;
+        struct mutex                i_mutex;
+
+        unsigned long                dirtied_when;        /* jiffies of first dirtying */
+
+        struct hlist_node        i_hash;
+        struct list_head        i_wb_list;        /* backing dev IO list */
+        struct list_head        i_lru;                /* inode LRU list */
+        struct list_head        i_sb_list;
+        union {
+                struct list_head        i_dentry;
+                struct rcu_head                i_rcu;
+        };
+        unsigned long                i_ino;
+        atomic_t                i_count;
+        unsigned int                i_nlink;
+        dev_t                        i_rdev;
+        unsigned int                i_blkbits;
+        u64                        i_version;
+        loff_t                        i_size;
 #ifdef __NEED_I_SIZE_ORDERED
-	seqcount_t		i_size_seqcount;
+        seqcount_t                i_size_seqcount;
 #endif
-	struct timespec		i_atime;
-	struct timespec		i_mtime;
-	struct timespec		i_ctime;
-	blkcnt_t		i_blocks;
-	unsigned short          i_bytes;
-	struct rw_semaphore	i_alloc_sem;
-	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
-	struct file_lock	*i_flock;
-	struct address_space	*i_mapping;
-	struct address_space	i_data;
+        struct timespec                i_atime;
+        struct timespec                i_mtime;
+        struct timespec                i_ctime;
+        blkcnt_t                i_blocks;
+        unsigned short          i_bytes;
+        struct rw_semaphore        i_alloc_sem;
+        const struct file_operations        *i_fop;        /* former ->i_op->default_file_ops */
+        struct file_lock        *i_flock;
+        struct address_space        *i_mapping;
+        struct address_space        i_data;
 #ifdef CONFIG_QUOTA
-	struct dquot		*i_dquot[MAXQUOTAS];
+        struct dquot                *i_dquot[MAXQUOTAS];
 #endif
-	struct list_head	i_devices;
-	union {
-		struct pipe_inode_info	*i_pipe;
-		struct block_device	*i_bdev;
-		struct cdev		*i_cdev;
-	};
+        struct list_head        i_devices;
+        union {
+                struct pipe_inode_info        *i_pipe;
+                struct block_device        *i_bdev;
+                struct cdev                *i_cdev;
+        };
 
-	__u32			i_generation;
+        __u32                        i_generation;
 
 #ifdef CONFIG_FSNOTIFY
-	__u32			i_fsnotify_mask; /* all events this inode cares about */
-	struct hlist_head	i_fsnotify_marks;
+        __u32                        i_fsnotify_mask; /* all events this inode cares about */
+        struct hlist_head        i_fsnotify_marks;
 #endif
 
 #ifdef CONFIG_IMA
-	atomic_t		i_readcount; /* struct files open RO */
+        atomic_t                i_readcount; /* struct files open RO */
 #endif
-	atomic_t		i_writecount;
+        atomic_t                i_writecount;
 #ifdef CONFIG_FS_POSIX_ACL
-	struct posix_acl	*i_acl;
-	struct posix_acl	*i_default_acl;
+        struct posix_acl        *i_acl;
+        struct posix_acl        *i_default_acl;
 #endif
-	void			*i_private; /* fs or device private pointer */
+        void                        *i_private; /* fs or device private pointer */
 };
 
 static inline int inode_unhashed(struct inode *inode)
 {
-	return hlist_unhashed(&inode->i_hash);
+        return hlist_unhashed(&inode->i_hash);
 }
 
 /*
@@ -828,11 +829,11 @@ static inline int inode_unhashed(struct inode *inode)
  */
 enum inode_i_mutex_lock_class
 {
-	I_MUTEX_NORMAL,
-	I_MUTEX_PARENT,
-	I_MUTEX_CHILD,
-	I_MUTEX_XATTR,
-	I_MUTEX_QUOTA
+        I_MUTEX_NORMAL,
+        I_MUTEX_PARENT,
+        I_MUTEX_CHILD,
+        I_MUTEX_XATTR,
+        I_MUTEX_QUOTA
 };
 
 /*
@@ -848,23 +849,23 @@ enum inode_i_mutex_lock_class
 static inline loff_t i_size_read(const struct inode *inode)
 {
 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
-	loff_t i_size;
-	unsigned int seq;
-
-	do {
-		seq = read_seqcount_begin(&inode->i_size_seqcount);
-		i_size = inode->i_size;
-	} while (read_seqcount_retry(&inode->i_size_seqcount, seq));
-	return i_size;
+        loff_t i_size;
+        unsigned int seq;
+
+        do {
+                seq = read_seqcount_begin(&inode->i_size_seqcount);
+                i_size = inode->i_size;
+        } while (read_seqcount_retry(&inode->i_size_seqcount, seq));
+        return i_size;
 #elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
-	loff_t i_size;
+        loff_t i_size;
 
-	preempt_disable();
-	i_size = inode->i_size;
-	preempt_enable();
-	return i_size;
+        preempt_disable();
+        i_size = inode->i_size;
+        preempt_enable();
+        return i_size;
 #else
-	return inode->i_size;
+        return inode->i_size;
 #endif
 }
 
@@ -876,50 +877,50 @@ static inline loff_t i_size_read(const struct inode *inode)
 static inline void i_size_write(struct inode *inode, loff_t i_size)
 {
 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
-	write_seqcount_begin(&inode->i_size_seqcount);
-	inode->i_size = i_size;
-	write_seqcount_end(&inode->i_size_seqcount);
+        write_seqcount_begin(&inode->i_size_seqcount);
+        inode->i_size = i_size;
+        write_seqcount_end(&inode->i_size_seqcount);
 #elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
-	preempt_disable();
-	inode->i_size = i_size;
-	preempt_enable();
+        preempt_disable();
+        inode->i_size = i_size;
+        preempt_enable();
 #else
-	inode->i_size = i_size;
+        inode->i_size = i_size;
 #endif
 }
 
 static inline unsigned iminor(const struct inode *inode)
 {
-	return MINOR(inode->i_rdev);
+        return MINOR(inode->i_rdev);
 }
 
 static inline unsigned imajor(const struct inode *inode)
 {
-	return MAJOR(inode->i_rdev);
+        return MAJOR(inode->i_rdev);
 }
 
 extern struct block_device *I_BDEV(struct inode *inode);
 
 struct fown_struct {
-	rwlock_t lock;          /* protects pid, uid, euid fields */
-	struct pid *pid;	/* pid or -pgrp where SIGIO should be sent */
-	enum pid_type pid_type;	/* Kind of process group SIGIO should be sent to */
-	uid_t uid, euid;	/* uid/euid of process setting the owner */
-	int signum;		/* posix.1b rt signal to be delivered on IO */
+        rwlock_t lock;          /* protects pid, uid, euid fields */
+        struct pid *pid;        /* pid or -pgrp where SIGIO should be sent */
+        enum pid_type pid_type;        /* Kind of process group SIGIO should be sent to */
+        uid_t uid, euid;        /* uid/euid of process setting the owner */
+        int signum;                /* posix.1b rt signal to be delivered on IO */
 };
 
 /*
  * Track a single file's readahead state
  */
 struct file_ra_state {
-	pgoff_t start;			/* where readahead started */
-	unsigned int size;		/* # of readahead pages */
-	unsigned int async_size;	/* do asynchronous readahead when
-					   there are only # of pages ahead */
-
-	unsigned int ra_pages;		/* Maximum readahead window */
-	unsigned int mmap_miss;		/* Cache miss stat for mmap accesses */
-	loff_t prev_pos;		/* Cache last read() position */
+        pgoff_t start;                        /* where readahead started */
+        unsigned int size;                /* # of readahead pages */
+        unsigned int async_size;        /* do asynchronous readahead when
+                                           there are only # of pages ahead */
+
+        unsigned int ra_pages;                /* Maximum readahead window */
+        unsigned int mmap_miss;                /* Cache miss stat for mmap accesses */
+        loff_t prev_pos;                /* Cache last read() position */
 };
 
 /*
@@ -927,98 +928,98 @@ struct file_ra_state {
  */
 static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)
 {
-	return (index >= ra->start &&
-		index <  ra->start + ra->size);
+        return (index >= ra->start &&
+                index <  ra->start + ra->size);
 }
 
-#define FILE_MNT_WRITE_TAKEN	1
-#define FILE_MNT_WRITE_RELEASED	2
+#define FILE_MNT_WRITE_TAKEN        1
+#define FILE_MNT_WRITE_RELEASED        2
 
 struct file {
-	/*
-	 * fu_list becomes invalid after file_free is called and queued via
-	 * fu_rcuhead for RCU freeing
-	 */
-	union {
-		struct list_head	fu_list;
-		struct rcu_head 	fu_rcuhead;
-	} f_u;
-	struct path		f_path;
-#define f_dentry	f_path.dentry
-#define f_vfsmnt	f_path.mnt
-	const struct file_operations	*f_op;
-	spinlock_t		f_lock;  /* f_ep_links, f_flags, no IRQ */
+        /*
+         * fu_list becomes invalid after file_free is called and queued via
+         * fu_rcuhead for RCU freeing
+         */
+        union {
+                struct list_head        fu_list;
+                struct rcu_head         fu_rcuhead;
+        } f_u;
+        struct path                f_path;
+#define f_dentry        f_path.dentry
+#define f_vfsmnt        f_path.mnt
+        const struct file_operations        *f_op;
+        spinlock_t                f_lock;  /* f_ep_links, f_flags, no IRQ */
 #ifdef CONFIG_SMP
-	int			f_sb_list_cpu;
+        int                        f_sb_list_cpu;
 #endif
-	atomic_long_t		f_count;
-	unsigned int 		f_flags;
-	fmode_t			f_mode;
-	loff_t			f_pos;
-	struct fown_struct	f_owner;
-	const struct cred	*f_cred;
-	struct file_ra_state	f_ra;
-
-	u64			f_version;
+        atomic_long_t                f_count;
+        unsigned int                 f_flags;
+        fmode_t                        f_mode;
+        loff_t                        f_pos;
+        struct fown_struct        f_owner;
+        const struct cred        *f_cred;
+        struct file_ra_state        f_ra;
+
+        u64                        f_version;
 #ifdef CONFIG_SECURITY
-	void			*f_security;
+        void                        *f_security;
 #endif
-	/* needed for tty driver, and maybe others */
-	void			*private_data;
+        /* needed for tty driver, and maybe others */
+        void                        *private_data;
 
 #ifdef CONFIG_EPOLL
-	/* Used by fs/eventpoll.c to link all the hooks to this file */
-	struct list_head	f_ep_links;
-	struct list_head	f_tfile_llink;
+        /* Used by fs/eventpoll.c to link all the hooks to this file */
+        struct list_head        f_ep_links;
+        struct list_head        f_tfile_llink;
 #endif /* #ifdef CONFIG_EPOLL */
-	struct address_space	*f_mapping;
+        struct address_space        *f_mapping;
 #ifdef CONFIG_DEBUG_WRITECOUNT
-	unsigned long f_mnt_write_state;
+        unsigned long f_mnt_write_state;
 #endif
 };
 
 struct file_handle {
-	__u32 handle_bytes;
-	int handle_type;
-	/* file identifier */
-	unsigned char f_handle[0];
+        __u32 handle_bytes;
+        int handle_type;
+        /* file identifier */
+        unsigned char f_handle[0];
 };
 
-#define get_file(x)	atomic_long_inc(&(x)->f_count)
-#define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
-#define file_count(x)	atomic_long_read(&(x)->f_count)
+#define get_file(x)        atomic_long_inc(&(x)->f_count)
+#define fput_atomic(x)        atomic_long_add_unless(&(x)->f_count, -1, 1)
+#define file_count(x)        atomic_long_read(&(x)->f_count)
 
 #ifdef CONFIG_DEBUG_WRITECOUNT
 static inline void file_take_write(struct file *f)
 {
-	WARN_ON(f->f_mnt_write_state != 0);
-	f->f_mnt_write_state = FILE_MNT_WRITE_TAKEN;
+        WARN_ON(f->f_mnt_write_state != 0);
+        f->f_mnt_write_state = FILE_MNT_WRITE_TAKEN;
 }
 static inline void file_release_write(struct file *f)
 {
-	f->f_mnt_write_state |= FILE_MNT_WRITE_RELEASED;
+        f->f_mnt_write_state |= FILE_MNT_WRITE_RELEASED;
 }
 static inline void file_reset_write(struct file *f)
 {
-	f->f_mnt_write_state = 0;
+        f->f_mnt_write_state = 0;
 }
 static inline void file_check_state(struct file *f)
 {
-	/*
-	 * At this point, either both or neither of these bits
-	 * should be set.
-	 */
-	WARN_ON(f->f_mnt_write_state == FILE_MNT_WRITE_TAKEN);
-	WARN_ON(f->f_mnt_write_state == FILE_MNT_WRITE_RELEASED);
+        /*
+         * At this point, either both or neither of these bits
+         * should be set.
+         */
+        WARN_ON(f->f_mnt_write_state == FILE_MNT_WRITE_TAKEN);
+        WARN_ON(f->f_mnt_write_state == FILE_MNT_WRITE_RELEASED);
 }
 static inline int file_check_writeable(struct file *f)
 {
-	if (f->f_mnt_write_state == FILE_MNT_WRITE_TAKEN)
-		return 0;
-	printk(KERN_WARNING "writeable file with no "
-			    "mnt_want_write()\n");
-	WARN_ON(1);
-	return -EINVAL;
+        if (f->f_mnt_write_state == FILE_MNT_WRITE_TAKEN)
+                return 0;
+        printk(KERN_WARNING "writeable file with no "
+                            "mnt_want_write()\n");
+        WARN_ON(1);
+        return -EINVAL;
 }
 #else /* !CONFIG_DEBUG_WRITECOUNT */
 static inline void file_take_write(struct file *filp) {}
@@ -1027,27 +1028,27 @@ static inline void file_reset_write(struct file *filp) {}
 static inline void file_check_state(struct file *filp) {}
 static inline int file_check_writeable(struct file *filp)
 {
-	return 0;
+        return 0;
 }
 #endif /* CONFIG_DEBUG_WRITECOUNT */
 
-#define	MAX_NON_LFS	((1UL<<31) - 1)
+#define        MAX_NON_LFS        ((1UL<<31) - 1)
 
-/* Page cache limit. The filesystems should put that into their s_maxbytes 
-   limits, otherwise bad things can happen in VM. */ 
+/* Page cache limit. The filesystems should put that into their s_maxbytes
+   limits, otherwise bad things can happen in VM. */
 #if BITS_PER_LONG==32
-#define MAX_LFS_FILESIZE	(((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
+#define MAX_LFS_FILESIZE        (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)
 #elif BITS_PER_LONG==64
-#define MAX_LFS_FILESIZE 	0x7fffffffffffffffUL
+#define MAX_LFS_FILESIZE         0x7fffffffffffffffUL
 #endif
 
-#define FL_POSIX	1
-#define FL_FLOCK	2
-#define FL_ACCESS	8	/* not trying to lock, just looking */
-#define FL_EXISTS	16	/* when unlocking, test for existence */
-#define FL_LEASE	32	/* lease held on this file */
-#define FL_CLOSE	64	/* unlock on close */
-#define FL_SLEEP	128	/* A blocking lock */
+#define FL_POSIX        1
+#define FL_FLOCK        2
+#define FL_ACCESS        8        /* not trying to lock, just looking */
+#define FL_EXISTS        16        /* when unlocking, test for existence */
+#define FL_LEASE        32        /* lease held on this file */
+#define FL_CLOSE        64        /* unlock on close */
+#define FL_SLEEP        128        /* A blocking lock */
 
 /*
  * Special return value from posix_lock_file() and vfs_lock_file() for
@@ -1065,21 +1066,21 @@ static inline int file_check_writeable(struct file *filp)
 typedef struct files_struct *fl_owner_t;
 
 struct file_lock_operations {
-	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
-	void (*fl_release_private)(struct file_lock *);
+        void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
+        void (*fl_release_private)(struct file_lock *);
 };
 
 struct lock_manager_operations {
-	int (*fl_compare_owner)(struct file_lock *, struct file_lock *);
-	void (*fl_notify)(struct file_lock *);	/* unblock callback */
-	int (*fl_grant)(struct file_lock *, struct file_lock *, int);
-	void (*fl_release_private)(struct file_lock *);
-	void (*fl_break)(struct file_lock *);
-	int (*fl_change)(struct file_lock **, int);
+        int (*fl_compare_owner)(struct file_lock *, struct file_lock *);
+        void (*fl_notify)(struct file_lock *);        /* unblock callback */
+        int (*fl_grant)(struct file_lock *, struct file_lock *, int);
+        void (*fl_release_private)(struct file_lock *);
+        void (*fl_break)(struct file_lock *);
+        int (*fl_change)(struct file_lock **, int);
 };
 
 struct lock_manager {
-	struct list_head list;
+        struct list_head list;
 };
 
 void locks_start_grace(struct lock_manager *);
@@ -1090,39 +1091,39 @@ int locks_in_grace(void);
 #include <linux/nfs_fs_i.h>
 
 struct file_lock {
-	struct file_lock *fl_next;	/* singly linked list for this inode  */
-	struct list_head fl_link;	/* doubly linked list of all locks */
-	struct list_head fl_block;	/* circular list of blocked processes */
-	fl_owner_t fl_owner;
-	unsigned char fl_flags;
-	unsigned char fl_type;
-	unsigned int fl_pid;
-	struct pid *fl_nspid;
-	wait_queue_head_t fl_wait;
-	struct file *fl_file;
-	loff_t fl_start;
-	loff_t fl_end;
-
-	struct fasync_struct *	fl_fasync; /* for lease break notifications */
-	unsigned long fl_break_time;	/* for nonblocking lease breaks */
-
-	const struct file_lock_operations *fl_ops;	/* Callbacks for filesystems */
-	const struct lock_manager_operations *fl_lmops;	/* Callbacks for lockmanagers */
-	union {
-		struct nfs_lock_info	nfs_fl;
-		struct nfs4_lock_info	nfs4_fl;
-		struct {
-			struct list_head link;	/* link in AFS vnode's pending_locks list */
-			int state;		/* state of grant or error if -ve */
-		} afs;
-	} fl_u;
+        struct file_lock *fl_next;        /* singly linked list for this inode  */
+        struct list_head fl_link;        /* doubly linked list of all locks */
+        struct list_head fl_block;        /* circular list of blocked processes */
+        fl_owner_t fl_owner;
+        unsigned char fl_flags;
+        unsigned char fl_type;
+        unsigned int fl_pid;
+        struct pid *fl_nspid;
+        wait_queue_head_t fl_wait;
+        struct file *fl_file;
+        loff_t fl_start;
+        loff_t fl_end;
+
+        struct fasync_struct *        fl_fasync; /* for lease break notifications */
+        unsigned long fl_break_time;        /* for nonblocking lease breaks */
+
+        const struct file_lock_operations *fl_ops;        /* Callbacks for filesystems */
+        const struct lock_manager_operations *fl_lmops;        /* Callbacks for lockmanagers */
+        union {
+                struct nfs_lock_info        nfs_fl;
+                struct nfs4_lock_info        nfs4_fl;
+                struct {
+                        struct list_head link;        /* link in AFS vnode's pending_locks list */
+                        int state;                /* state of grant or error if -ve */
+                } afs;
+        } fl_u;
 };
 
 /* The following constant reflects the upper bound of the file/locking space */
 #ifndef OFFSET_MAX
-#define INT_LIMIT(x)	(~((x)1 << (sizeof(x)*8 - 1)))
-#define OFFSET_MAX	INT_LIMIT(loff_t)
-#define OFFT_OFFSET_MAX	INT_LIMIT(off_t)
+#define INT_LIMIT(x)        (~((x)1 << (sizeof(x)*8 - 1)))
+#define OFFSET_MAX        INT_LIMIT(loff_t)
+#define OFFT_OFFSET_MAX        INT_LIMIT(off_t)
 #endif
 
 #include <linux/fcntl.h>
@@ -1132,12 +1133,12 @@ extern void send_sigio(struct fown_struct *fown, int fd, int band);
 #ifdef CONFIG_FILE_LOCKING
 extern int fcntl_getlk(struct file *, struct flock __user *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
-			struct flock __user *);
+                        struct flock __user *);
 
 #if BITS_PER_LONG == 32
 extern int fcntl_getlk64(struct file *, struct flock64 __user *);
 extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
-			struct flock64 __user *);
+                        struct flock64 __user *);
 #endif
 
 extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
@@ -1172,143 +1173,143 @@ extern void unlock_flocks(void);
 #else /* !CONFIG_FILE_LOCKING */
 static inline int fcntl_getlk(struct file *file, struct flock __user *user)
 {
-	return -EINVAL;
+        return -EINVAL;
 }
 
 static inline int fcntl_setlk(unsigned int fd, struct file *file,
-			      unsigned int cmd, struct flock __user *user)
+                              unsigned int cmd, struct flock __user *user)
 {
-	return -EACCES;
+        return -EACCES;
 }
 
 #if BITS_PER_LONG == 32
 static inline int fcntl_getlk64(struct file *file, struct flock64 __user *user)
 {
-	return -EINVAL;
+        return -EINVAL;
 }
 
 static inline int fcntl_setlk64(unsigned int fd, struct file *file,
-				unsigned int cmd, struct flock64 __user *user)
+                                unsigned int cmd, struct flock64 __user *user)
 {
-	return -EACCES;
+        return -EACCES;
 }
 #endif
 static inline int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
 {
-	return 0;
+        return 0;
 }
 
 static inline int fcntl_getlease(struct file *filp)
 {
-	return 0;
+        return 0;
 }
 
 static inline void locks_init_lock(struct file_lock *fl)
 {
-	return;
+        return;
 }
 
 static inline void __locks_copy_lock(struct file_lock *new, struct file_lock *fl)
 {
-	return;
+        return;
 }
 
 static inline void locks_copy_lock(struct file_lock *new, struct file_lock *fl)
 {
-	return;
+        return;
 }
 
 static inline void locks_remove_posix(struct file *filp, fl_owner_t owner)
 {
-	return;
+        return;
 }
 
 static inline void locks_remove_flock(struct file *filp)
 {
-	return;
+        return;
 }
 
 static inline void posix_test_lock(struct file *filp, struct file_lock *fl)
 {
-	return;
+        return;
 }
 
 static inline int posix_lock_file(struct file *filp, struct file_lock *fl,
-				  struct file_lock *conflock)
+                                  struct file_lock *conflock)
 {
-	return -ENOLCK;
+        return -ENOLCK;
 }
 
 static inline int posix_lock_file_wait(struct file *filp, struct file_lock *fl)
 {
-	return -ENOLCK;
+        return -ENOLCK;
 }
 
 static inline int posix_unblock_lock(struct file *filp,
-				     struct file_lock *waiter)
+                                     struct file_lock *waiter)
 {
-	return -ENOENT;
+        return -ENOENT;
 }
 
 static inline int vfs_test_lock(struct file *filp, struct file_lock *fl)
 {
-	return 0;
+        return 0;
 }
 
 static inline int vfs_lock_file(struct file *filp, unsigned int cmd,
-				struct file_lock *fl, struct file_lock *conf)
+                                struct file_lock *fl, struct file_lock *conf)
 {
-	return -ENOLCK;
+        return -ENOLCK;
 }
 
 static inline int vfs_cancel_lock(struct file *filp, struct file_lock *fl)
 {
-	return 0;
+        return 0;
 }
 
 static inline int flock_lock_file_wait(struct file *filp,
-				       struct file_lock *request)
+                                       struct file_lock *request)
 {
-	return -ENOLCK;
+        return -ENOLCK;
 }
 
 static inline int __break_lease(struct inode *inode, unsigned int mode)
 {
-	return 0;
+        return 0;
 }
 
 static inline void lease_get_mtime(struct inode *inode, struct timespec *time)
 {
-	return;
+        return;
 }
 
 static inline int generic_setlease(struct file *filp, long arg,
-				    struct file_lock **flp)
+                                    struct file_lock **flp)
 {
-	return -EINVAL;
+        return -EINVAL;
 }
 
 static inline int vfs_setlease(struct file *filp, long arg,
-			       struct file_lock **lease)
+                               struct file_lock **lease)
 {
-	return -EINVAL;
+        return -EINVAL;
 }
 
 static inline int lease_modify(struct file_lock **before, int arg)
 {
-	return -EINVAL;
+        return -EINVAL;
 }
 
 static inline int lock_may_read(struct inode *inode, loff_t start,
-				unsigned long len)
+                                unsigned long len)
 {
-	return 1;
+        return 1;
 }
 
 static inline int lock_may_write(struct inode *inode, loff_t start,
-				 unsigned long len)
+                                 unsigned long len)
 {
-	return 1;
+        return 1;
 }
 
 static inline void lock_flocks(void)
@@ -1321,14 +1322,13 @@ static inline void unlock_flocks(void)
 
 #endif /* !CONFIG_FILE_LOCKING */
 
-
 struct fasync_struct {
-	spinlock_t		fa_lock;
-	int			magic;
-	int			fa_fd;
-	struct fasync_struct	*fa_next; /* singly linked list */
-	struct file		*fa_file;
-	struct rcu_head		fa_rcu;
+        spinlock_t                fa_lock;
+        int                        magic;
+        int                        fa_fd;
+        struct fasync_struct        *fa_next; /* singly linked list */
+        struct file                *fa_file;
+        struct rcu_head                fa_rcu;
 };
 
 #define FASYNC_MAGIC 0x4601
@@ -1350,48 +1350,48 @@ extern pid_t f_getown(struct file *filp);
 extern int send_sigurg(struct fown_struct *fown);
 
 /*
- *	Umount options
+ *        Umount options
  */
 
-#define MNT_FORCE	0x00000001	/* Attempt to forcibily umount */
-#define MNT_DETACH	0x00000002	/* Just detach from the tree */
-#define MNT_EXPIRE	0x00000004	/* Mark for expiry */
-#define UMOUNT_NOFOLLOW	0x00000008	/* Don't follow symlink on umount */
-#define UMOUNT_UNUSED	0x80000000	/* Flag guaranteed to be unused */
+#define MNT_FORCE        0x00000001        /* Attempt to forcibily umount */
+#define MNT_DETACH        0x00000002        /* Just detach from the tree */
+#define MNT_EXPIRE        0x00000004        /* Mark for expiry */
+#define UMOUNT_NOFOLLOW        0x00000008        /* Don't follow symlink on umount */
+#define UMOUNT_UNUSED        0x80000000        /* Flag guaranteed to be unused */
 
 extern struct list_head super_blocks;
 extern spinlock_t sb_lock;
 
 struct super_block {
-	struct list_head	s_list;		/* Keep this first */
-	dev_t			s_dev;		/* search index; _not_ kdev_t */
-	unsigned char		s_dirt;
-	unsigned char		s_blocksize_bits;
-	unsigned long		s_blocksize;
-	loff_t			s_maxbytes;	/* Max file size */
-	struct file_system_type	*s_type;
-	const struct super_operations	*s_op;
-	const struct dquot_operations	*dq_op;
-	const struct quotactl_ops	*s_qcop;
-	const struct export_operations *s_export_op;
-	unsigned long		s_flags;
-	unsigned long		s_magic;
-	struct dentry		*s_root;
-	struct rw_semaphore	s_umount;
-	struct mutex		s_lock;
-	int			s_count;
-	atomic_t		s_active;
+        struct list_head        s_list;                /* Keep this first */
+        dev_t                        s_dev;                /* search index; _not_ kdev_t */
+        unsigned char                s_dirt;
+        unsigned char                s_blocksize_bits;
+        unsigned long                s_blocksize;
+        loff_t                        s_maxbytes;        /* Max file size */
+        struct file_system_type        *s_type;
+        const struct super_operations        *s_op;
+        const struct dquot_operations        *dq_op;
+        const struct quotactl_ops        *s_qcop;
+        const struct export_operations *s_export_op;
+        unsigned long                s_flags;
+        unsigned long                s_magic;
+        struct dentry                *s_root;
+        struct rw_semaphore        s_umount;
+        struct mutex                s_lock;
+        int                        s_count;
+        atomic_t                s_active;
 #ifdef CONFIG_SECURITY
-	void                    *s_security;
+        void                    *s_security;
 #endif
-	const struct xattr_handler **s_xattr;
+        const struct xattr_handler **s_xattr;
 
-	struct list_head	s_inodes;	/* all inodes */
-	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
+        struct list_head        s_inodes;        /* all inodes */
+        struct hlist_bl_head        s_anon;                /* anonymous dentries for (nfs) exporting */
 #ifdef CONFIG_SMP
-	struct list_head __percpu *s_files;
+        struct list_head __percpu *s_files;
 #else
-	struct list_head	s_files;
+        struct list_head        s_files;
 #endif
 	/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
@@ -1447,13 +1447,13 @@ extern struct timespec current_fs_time(struct super_block *sb);
  * Snapshotting support.
  */
 enum {
-	SB_UNFROZEN = 0,
-	SB_FREEZE_WRITE	= 1,
-	SB_FREEZE_TRANS = 2,
+        SB_UNFROZEN = 0,
+        SB_FREEZE_WRITE        = 1,
+        SB_FREEZE_TRANS = 2,
 };
 
 #define vfs_check_frozen(sb, level) \
-	wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
+        wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
 
 #define get_fs_excl() atomic_inc(&current->fs_excl)
 #define put_fs_excl() atomic_dec(&current->fs_excl)
@@ -1493,19 +1493,19 @@ extern void dentry_unhash(struct dentry *dentry);
  */
 extern int file_permission(struct file *, int);
 extern void inode_init_owner(struct inode *inode, const struct inode *dir,
-			mode_t mode);
+                        mode_t mode);
 /*
  * VFS FS_IOC_FIEMAP helper definitions.
  */
 struct fiemap_extent_info {
-	unsigned int fi_flags;		/* Flags as passed from user */
-	unsigned int fi_extents_mapped;	/* Number of mapped extents */
-	unsigned int fi_extents_max;	/* Size of fiemap_extent array */
-	struct fiemap_extent __user *fi_extents_start; /* Start of
-							fiemap_extent array */
+        unsigned int fi_flags;                /* Flags as passed from user */
+        unsigned int fi_extents_mapped;        /* Number of mapped extents */
+        unsigned int fi_extents_max;        /* Size of fiemap_extent array */
+        struct fiemap_extent __user *fi_extents_start; /* Start of
+                                                        fiemap_extent array */
 };
 int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
-			    u64 phys, u64 len, u32 flags);
+                            u64 phys, u64 len, u32 flags);
 int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
 
 /*
@@ -1514,15 +1514,15 @@ int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
  * NOTE! These match bits 12..15 of stat.st_mode
  * (ie "(i_mode >> 12) & 15").
  */
-#define DT_UNKNOWN	0
-#define DT_FIFO		1
-#define DT_CHR		2
-#define DT_DIR		4
-#define DT_BLK		6
-#define DT_REG		8
-#define DT_LNK		10
-#define DT_SOCK		12
-#define DT_WHT		14
+#define DT_UNKNOWN        0
+#define DT_FIFO                1
+#define DT_CHR                2
+#define DT_DIR                4
+#define DT_BLK                6
+#define DT_REG                8
+#define DT_LNK                10
+#define DT_SOCK                12
+#define DT_WHT                14
 
 /*
  * This is the "filldir" function type, used by readdir() to let
@@ -1545,107 +1545,107 @@ struct block_device_operations;
  * the big kernel lock held in all filesystems.
  */
 struct file_operations {
-	struct module *owner;
-	loff_t (*llseek) (struct file *, loff_t, int);
-	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
-	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
-	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
-	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
-	int (*readdir) (struct file *, void *, filldir_t);
-	unsigned int (*poll) (struct file *, struct poll_table_struct *);
-	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
-	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
-	int (*mmap) (struct file *, struct vm_area_struct *);
-	int (*open) (struct inode *, struct file *);
-	int (*flush) (struct file *, fl_owner_t id);
-	int (*release) (struct inode *, struct file *);
-	int (*fsync) (struct file *, int datasync);
-	int (*aio_fsync) (struct kiocb *, int datasync);
-	int (*fasync) (int, struct file *, int);
-	int (*lock) (struct file *, int, struct file_lock *);
-	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
-	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
-	int (*check_flags)(int);
-	int (*flock) (struct file *, int, struct file_lock *);
-	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
-	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
-	int (*setlease)(struct file *, long, struct file_lock **);
-	long (*fallocate)(struct file *file, int mode, loff_t offset,
-			  loff_t len);
+        struct module *owner;
+        loff_t (*llseek) (struct file *, loff_t, int);
+        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
+        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
+        ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
+        ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
+        int (*readdir) (struct file *, void *, filldir_t);
+        unsigned int (*poll) (struct file *, struct poll_table_struct *);
+        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
+        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
+        int (*mmap) (struct file *, struct vm_area_struct *);
+        int (*open) (struct inode *, struct file *);
+        int (*flush) (struct file *, fl_owner_t id);
+        int (*release) (struct inode *, struct file *);
+        int (*fsync) (struct file *, int datasync);
+        int (*aio_fsync) (struct kiocb *, int datasync);
+        int (*fasync) (int, struct file *, int);
+        int (*lock) (struct file *, int, struct file_lock *);
+        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
+        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
+        int (*check_flags)(int);
+        int (*flock) (struct file *, int, struct file_lock *);
+        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
+        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
+        int (*setlease)(struct file *, long, struct file_lock **);
+        long (*fallocate)(struct file *file, int mode, loff_t offset,
+                          loff_t len);
 };
 
-#define IPERM_FLAG_RCU	0x0001
+#define IPERM_FLAG_RCU        0x0001
 
 struct inode_operations {
-	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
-	void * (*follow_link) (struct dentry *, struct nameidata *);
-	int (*permission) (struct inode *, int, unsigned int);
-	int (*check_acl)(struct inode *, int, unsigned int);
-
-	int (*readlink) (struct dentry *, char __user *,int);
-	void (*put_link) (struct dentry *, struct nameidata *, void *);
-
-	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
-	int (*link) (struct dentry *,struct inode *,struct dentry *);
-	int (*unlink) (struct inode *,struct dentry *);
-	int (*symlink) (struct inode *,struct dentry *,const char *);
-	int (*mkdir) (struct inode *,struct dentry *,int);
-	int (*rmdir) (struct inode *,struct dentry *);
-	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
-	int (*rename) (struct inode *, struct dentry *,
-			struct inode *, struct dentry *);
-	void (*truncate) (struct inode *);
-	int (*setattr) (struct dentry *, struct iattr *);
-	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
-	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
-	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
-	ssize_t (*listxattr) (struct dentry *, char *, size_t);
-	int (*removexattr) (struct dentry *, const char *);
-	void (*truncate_range)(struct inode *, loff_t, loff_t);
-	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
-		      u64 len);
+        struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
+        void * (*follow_link) (struct dentry *, struct nameidata *);
+        int (*permission) (struct inode *, int, unsigned int);
+        int (*check_acl)(struct inode *, int, unsigned int);
+
+        int (*readlink) (struct dentry *, char __user *,int);
+        void (*put_link) (struct dentry *, struct nameidata *, void *);
+
+        int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
+        int (*link) (struct dentry *,struct inode *,struct dentry *);
+        int (*unlink) (struct inode *,struct dentry *);
+        int (*symlink) (struct inode *,struct dentry *,const char *);
+        int (*mkdir) (struct inode *,struct dentry *,int);
+        int (*rmdir) (struct inode *,struct dentry *);
+        int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+        int (*rename) (struct inode *, struct dentry *,
+                        struct inode *, struct dentry *);
+        void (*truncate) (struct inode *);
+        int (*setattr) (struct dentry *, struct iattr *);
+        int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+        int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
+        ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
+        ssize_t (*listxattr) (struct dentry *, char *, size_t);
+        int (*removexattr) (struct dentry *, const char *);
+        void (*truncate_range)(struct inode *, loff_t, loff_t);
+        int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
+                      u64 len);
 } ____cacheline_aligned;
 
 struct seq_file;
 
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
-				unsigned long nr_segs, unsigned long fast_segs,
-				struct iovec *fast_pointer,
-				struct iovec **ret_pointer);
+                                unsigned long nr_segs, unsigned long fast_segs,
+                                struct iovec *fast_pointer,
+                                struct iovec **ret_pointer);
 
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
-		unsigned long, loff_t *);
+                unsigned long, loff_t *);
 extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
-		unsigned long, loff_t *);
+                unsigned long, loff_t *);
 
 struct super_operations {
-   	struct inode *(*alloc_inode)(struct super_block *sb);
-	void (*destroy_inode)(struct inode *);
-
-   	void (*dirty_inode) (struct inode *, int flags);
-	int (*write_inode) (struct inode *, struct writeback_control *wbc);
-	int (*drop_inode) (struct inode *);
-	void (*evict_inode) (struct inode *);
-	void (*put_super) (struct super_block *);
-	void (*write_super) (struct super_block *);
-	int (*sync_fs)(struct super_block *sb, int wait);
-	int (*freeze_fs) (struct super_block *);
-	int (*unfreeze_fs) (struct super_block *);
-	int (*statfs) (struct dentry *, struct kstatfs *);
-	int (*remount_fs) (struct super_block *, int *, char *);
-	void (*umount_begin) (struct super_block *);
-
-	int (*show_options)(struct seq_file *, struct vfsmount *);
-	int (*show_devname)(struct seq_file *, struct vfsmount *);
-	int (*show_path)(struct seq_file *, struct vfsmount *);
-	int (*show_stats)(struct seq_file *, struct vfsmount *);
+           struct inode *(*alloc_inode)(struct super_block *sb);
+        void (*destroy_inode)(struct inode *);
+
+           void (*dirty_inode) (struct inode *, int flags);
+        int (*write_inode) (struct inode *, struct writeback_control *wbc);
+        int (*drop_inode) (struct inode *);
+        void (*evict_inode) (struct inode *);
+        void (*put_super) (struct super_block *);
+        void (*write_super) (struct super_block *);
+        int (*sync_fs)(struct super_block *sb, int wait);
+        int (*freeze_fs) (struct super_block *);
+        int (*unfreeze_fs) (struct super_block *);
+        int (*statfs) (struct dentry *, struct kstatfs *);
+        int (*remount_fs) (struct super_block *, int *, char *);
+        void (*umount_begin) (struct super_block *);
+
+        int (*show_options)(struct seq_file *, struct vfsmount *);
+        int (*show_devname)(struct seq_file *, struct vfsmount *);
+        int (*show_path)(struct seq_file *, struct vfsmount *);
+        int (*show_stats)(struct seq_file *, struct vfsmount *);
 #ifdef CONFIG_QUOTA
-	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
-	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
+        ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
+        ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
-	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
+        int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
 };
 
 /*
@@ -1660,65 +1660,78 @@ struct super_operations {
  *
  * Two bits are used for locking and completion notification, I_NEW and I_SYNC.
  *
- * I_DIRTY_SYNC		Inode is dirty, but doesn't have to be written on
- *			fdatasync().  i_atime is the usual cause.
- * I_DIRTY_DATASYNC	Data-related inode changes pending. We keep track of
- *			these changes separately from I_DIRTY_SYNC so that we
- *			don't have to write inode on fdatasync() when only
- *			mtime has changed in it.
- * I_DIRTY_PAGES	Inode has dirty pages.  Inode itself may be clean.
- * I_NEW		Serves as both a mutex and completion notification.
- *			New inodes set I_NEW.  If two processes both create
- *			the same inode, one of them will release its inode and
- *			wait for I_NEW to be released before returning.
- *			Inodes in I_WILL_FREE, I_FREEING or I_CLEAR state can
- *			also cause waiting on I_NEW, without I_NEW actually
- *			being set.  find_inode() uses this to prevent returning
- *			nearly-dead inodes.
- * I_WILL_FREE		Must be set when calling write_inode_now() if i_count
- *			is zero.  I_FREEING must be set when I_WILL_FREE is
- *			cleared.
- * I_FREEING		Set when inode is about to be freed but still has dirty
- *			pages or buffers attached or the inode itself is still
- *			dirty.
- * I_CLEAR		Added by end_writeback().  In this state the inode is clean
- *			and can be destroyed.  Inode keeps I_FREEING.
+ * I_DIRTY_SYNC                Inode is dirty, but doesn't have to be written on
+ *                        fdatasync().  i_atime is the usual cause.
+ * I_DIRTY_DATASYNC        Data-related inode changes pending. We keep track of
+ *                        these changes separately from I_DIRTY_SYNC so that we
+ *                        don't have to write inode on fdatasync() when only
+ *                        mtime has changed in it.
+ * I_DIRTY_PAGES        Inode has dirty pages.  Inode itself may be clean.
+ * I_NEW                Serves as both a mutex and completion notification.
+ *                        New inodes set I_NEW.  If two processes both create
+ *                        the same inode, one of them will release its inode and
+ *                        wait for I_NEW to be released before returning.
+ *                        Inodes in I_WILL_FREE, I_FREEING or I_CLEAR state can
+ *                        also cause waiting on I_NEW, without I_NEW actually
+ *                        being set.  find_inode() uses this to prevent returning
+ *                        nearly-dead inodes.
+ * I_WILL_FREE                Must be set when calling write_inode_now() if i_count
+ *                        is zero.  I_FREEING must be set when I_WILL_FREE is
+ *                        cleared.
+ * I_FREEING                Set when inode is about to be freed but still has dirty
+ *                        pages or buffers attached or the inode itself is still
+ *                        dirty.
+ * I_CLEAR                Added by end_writeback().  In this state the inode is clean
+ *                        and can be destroyed.  Inode keeps I_FREEING.
  *
- *			Inodes that are I_WILL_FREE, I_FREEING or I_CLEAR are
- *			prohibited for many purposes.  iget() must wait for
- *			the inode to be completely released, then create it
- *			anew.  Other functions will just ignore such inodes,
- *			if appropriate.  I_NEW is used for waiting.
+ *                        Inodes that are I_WILL_FREE, I_FREEING or I_CLEAR are
+ *                        prohibited for many purposes.  iget() must wait for
+ *                        the inode to be completely released, then create it
+ *                        anew.  Other functions will just ignore such inodes,
+ *                        if appropriate.  I_NEW is used for waiting.
  *
- * I_SYNC		Synchonized write of dirty inode data.  The bits is
- *			set during data writeback, and cleared with a wakeup
- *			on the bit address once it is done.
+ * I_SYNC                Synchonized write of dirty inode data.  The bits is
+ *                        set during data writeback, and cleared with a wakeup
+ *                        on the bit address once it is done.
  *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  */
-#define I_DIRTY_SYNC		(1 << 0)
-#define I_DIRTY_DATASYNC	(1 << 1)
-#define I_DIRTY_PAGES		(1 << 2)
-#define __I_NEW			3
-#define I_NEW			(1 << __I_NEW)
-#define I_WILL_FREE		(1 << 4)
-#define I_FREEING		(1 << 5)
-#define I_CLEAR			(1 << 6)
-#define __I_SYNC		7
-#define I_SYNC			(1 << __I_SYNC)
-#define I_REFERENCED		(1 << 8)
+#define I_DIRTY_SYNC                (1 << 0)
+#define I_DIRTY_DATASYNC        (1 << 1)
+#define I_DIRTY_PAGES                (1 << 2)
+#define __I_NEW                        3
+#define I_NEW                        (1 << __I_NEW)
+#define I_WILL_FREE                (1 << 4)
+#define I_FREEING                (1 << 5)
+#define I_CLEAR                        (1 << 6)
+#define __I_SYNC                7
+#define I_SYNC                        (1 << __I_SYNC)
+#define I_REFERENCED                (1 << 8)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 
 extern void __mark_inode_dirty(struct inode *, int);
 static inline void mark_inode_dirty(struct inode *inode)
 {
-	__mark_inode_dirty(inode, I_DIRTY);
+        __mark_inode_dirty(inode, I_DIRTY);
 }
 
 static inline void mark_inode_dirty_sync(struct inode *inode)
 {
-	__mark_inode_dirty(inode, I_DIRTY_SYNC);
+        __mark_inode_dirty(inode, I_DIRTY_SYNC);
+}
+
+/**
+ * set_nlink - directly set an inode's link count
+ * @inode: inode
+ * @nlink: new nlink (should be non-zero)
+ *
+ * This is a low-level filesystem helper to replace any
+ * direct filesystem manipulation of i_nlink.
+ */
+static inline void set_nlink(struct inode *inode, unsigned int nlink)
+{
+	inode->i_nlink = nlink;
 }
 
 /**
@@ -1731,13 +1744,13 @@ static inline void mark_inode_dirty_sync(struct inode *inode)
  */
 static inline void inc_nlink(struct inode *inode)
 {
-	inode->i_nlink++;
+        inode->i_nlink++;
 }
 
 static inline void inode_inc_link_count(struct inode *inode)
 {
-	inc_nlink(inode);
-	mark_inode_dirty(inode);
+        inc_nlink(inode);
+        mark_inode_dirty(inode);
 }
 
 /**
@@ -1753,7 +1766,7 @@ static inline void inode_inc_link_count(struct inode *inode)
  */
 static inline void drop_nlink(struct inode *inode)
 {
-	inode->i_nlink--;
+        inode->i_nlink--;
 }
 
 /**
@@ -1766,13 +1779,13 @@ static inline void drop_nlink(struct inode *inode)
  */
 static inline void clear_nlink(struct inode *inode)
 {
-	inode->i_nlink = 0;
+        inode->i_nlink = 0;
 }
 
 static inline void inode_dec_link_count(struct inode *inode)
 {
-	drop_nlink(inode);
-	mark_inode_dirty(inode);
+        drop_nlink(inode);
+        mark_inode_dirty(inode);
 }
 
 /**
@@ -1793,44 +1806,46 @@ static inline void inode_inc_iversion(struct inode *inode)
 extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
 static inline void file_accessed(struct file *file)
 {
-	if (!(file->f_flags & O_NOATIME))
-		touch_atime(file->f_path.mnt, file->f_path.dentry);
+        if (!(file->f_flags & O_NOATIME))
+                touch_atime(file->f_path.mnt, file->f_path.dentry);
 }
 
 int sync_inode(struct inode *inode, struct writeback_control *wbc);
 int sync_inode_metadata(struct inode *inode, int wait);
 
 struct file_system_type {
-	const char *name;
-	int fs_flags;
-	struct dentry *(*mount) (struct file_system_type *, int,
-		       const char *, void *);
-	void (*kill_sb) (struct super_block *);
-	struct module *owner;
-	struct file_system_type * next;
-	struct list_head fs_supers;
-
-	struct lock_class_key s_lock_key;
-	struct lock_class_key s_umount_key;
-	struct lock_class_key s_vfs_rename_key;
-
-	struct lock_class_key i_lock_key;
-	struct lock_class_key i_mutex_key;
-	struct lock_class_key i_mutex_dir_key;
-	struct lock_class_key i_alloc_sem_key;
+        const char *name;
+        int fs_flags;
+        struct dentry *(*mount) (struct file_system_type *, int,
+                       const char *, void *);
+        void (*kill_sb) (struct super_block *);
+        struct module *owner;
+        struct file_system_type * next;
+        struct list_head fs_supers;
+
+        struct lock_class_key s_lock_key;
+        struct lock_class_key s_umount_key;
+        struct lock_class_key s_vfs_rename_key;
+
+        struct lock_class_key i_lock_key;
+        struct lock_class_key i_mutex_key;
+        struct lock_class_key i_mutex_dir_key;
+        struct lock_class_key i_alloc_sem_key;
 };
 
+#define MODULE_ALIAS_FS(NAME) MODULE_ALIAS("fs-" NAME)
+
 extern struct dentry *mount_ns(struct file_system_type *fs_type, int flags,
-	void *data, int (*fill_super)(struct super_block *, void *, int));
+        void *data, int (*fill_super)(struct super_block *, void *, int));
 extern struct dentry *mount_bdev(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data,
-	int (*fill_super)(struct super_block *, void *, int));
+        int flags, const char *dev_name, void *data,
+        int (*fill_super)(struct super_block *, void *, int));
 extern struct dentry *mount_single(struct file_system_type *fs_type,
-	int flags, void *data,
-	int (*fill_super)(struct super_block *, void *, int));
+        int flags, void *data,
+        int (*fill_super)(struct super_block *, void *, int));
 extern struct dentry *mount_nodev(struct file_system_type *fs_type,
-	int flags, void *data,
-	int (*fill_super)(struct super_block *, void *, int));
+        int flags, void *data,
+        int (*fill_super)(struct super_block *, void *, int));
 void generic_shutdown_super(struct super_block *sb);
 void kill_block_super(struct super_block *sb);
 void kill_anon_super(struct super_block *sb);
@@ -1839,32 +1854,32 @@ void deactivate_super(struct super_block *sb);
 void deactivate_locked_super(struct super_block *sb);
 int set_anon_super(struct super_block *s, void *data);
 struct super_block *sget(struct file_system_type *type,
-			int (*test)(struct super_block *,void *),
-			int (*set)(struct super_block *,void *),
-			void *data);
+                        int (*test)(struct super_block *,void *),
+                        int (*set)(struct super_block *,void *),
+                        void *data);
 extern struct dentry *mount_pseudo(struct file_system_type *, char *,
-	const struct super_operations *ops,
-	const struct dentry_operations *dops,
-	unsigned long);
+        const struct super_operations *ops,
+        const struct dentry_operations *dops,
+        unsigned long);
 
 static inline void sb_mark_dirty(struct super_block *sb)
 {
-	sb->s_dirt = 1;
+        sb->s_dirt = 1;
 }
 static inline void sb_mark_clean(struct super_block *sb)
 {
-	sb->s_dirt = 0;
+        sb->s_dirt = 0;
 }
 static inline int sb_is_dirty(struct super_block *sb)
 {
-	return sb->s_dirt;
+        return sb->s_dirt;
 }
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \
-	(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))
+        (((fops) && try_module_get((fops)->owner) ? (fops) : NULL))
 #define fops_put(fops) \
-	do { if (fops) module_put((fops)->owner); } while(0)
+        do { if (fops) module_put((fops)->owner); } while(0)
 
 extern int register_filesystem(struct file_system_type *);
 extern int unregister_filesystem(struct file_system_type *);
@@ -1876,7 +1891,7 @@ extern long do_mount(char *, char *, char *, unsigned long, void *);
 extern struct vfsmount *collect_mounts(struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
-			  struct vfsmount *);
+                          struct vfsmount *);
 extern int vfs_statfs(struct path *, struct kstatfs *);
 extern int user_statfs(const char __user *, struct kstatfs *);
 extern int fd_statfs(int, struct kstatfs *);
@@ -1907,7 +1922,7 @@ extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size
 
 static inline int __mandatory_lock(struct inode *ino)
 {
-	return (ino->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID;
+        return (ino->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID;
 }
 
 /*
@@ -1917,73 +1932,73 @@ static inline int __mandatory_lock(struct inode *ino)
 
 static inline int mandatory_lock(struct inode *ino)
 {
-	return IS_MANDLOCK(ino) && __mandatory_lock(ino);
+        return IS_MANDLOCK(ino) && __mandatory_lock(ino);
 }
 
 static inline int locks_verify_locked(struct inode *inode)
 {
-	if (mandatory_lock(inode))
-		return locks_mandatory_locked(inode);
-	return 0;
+        if (mandatory_lock(inode))
+                return locks_mandatory_locked(inode);
+        return 0;
 }
 
 static inline int locks_verify_truncate(struct inode *inode,
-				    struct file *filp,
-				    loff_t size)
+                                    struct file *filp,
+                                    loff_t size)
 {
-	if (inode->i_flock && mandatory_lock(inode))
-		return locks_mandatory_area(
-			FLOCK_VERIFY_WRITE, inode, filp,
-			size < inode->i_size ? size : inode->i_size,
-			(size < inode->i_size ? inode->i_size - size
-			 : size - inode->i_size)
-		);
-	return 0;
+        if (inode->i_flock && mandatory_lock(inode))
+                return locks_mandatory_area(
+                        FLOCK_VERIFY_WRITE, inode, filp,
+                        size < inode->i_size ? size : inode->i_size,
+                        (size < inode->i_size ? inode->i_size - size
+                         : size - inode->i_size)
+                );
+        return 0;
 }
 
 static inline int break_lease(struct inode *inode, unsigned int mode)
 {
-	if (inode->i_flock)
-		return __break_lease(inode, mode);
-	return 0;
+        if (inode->i_flock)
+                return __break_lease(inode, mode);
+        return 0;
 }
 #else /* !CONFIG_FILE_LOCKING */
 static inline int locks_mandatory_locked(struct inode *inode)
 {
-	return 0;
+        return 0;
 }
 
 static inline int locks_mandatory_area(int rw, struct inode *inode,
-				       struct file *filp, loff_t offset,
-				       size_t count)
+                                       struct file *filp, loff_t offset,
+                                       size_t count)
 {
-	return 0;
+        return 0;
 }
 
 static inline int __mandatory_lock(struct inode *inode)
 {
-	return 0;
+        return 0;
 }
 
 static inline int mandatory_lock(struct inode *inode)
 {
-	return 0;
+        return 0;
 }
 
 static inline int locks_verify_locked(struct inode *inode)
 {
-	return 0;
+        return 0;
 }
 
 static inline int locks_verify_truncate(struct inode *inode, struct file *filp,
-					size_t size)
+                                        size_t size)
 {
-	return 0;
+        return 0;
 }
 
 static inline int break_lease(struct inode *inode, unsigned int mode)
 {
-	return 0;
+        return 0;
 }
 
 #endif /* CONFIG_FILE_LOCKING */
@@ -1991,16 +2006,16 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 /* fs/open.c */
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
-		       struct file *filp);
+                       struct file *filp);
 extern int do_fallocate(struct file *file, int mode, loff_t offset,
-			loff_t len);
+                        loff_t len);
 extern long do_sys_open(int dfd, const char __user *filename, int flags,
-			int mode);
+                        int mode);
 extern struct file *filp_open(const char *, int, int);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
-				   const char *, int);
+                                   const char *, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
-				 const struct cred *);
+                                 const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 
@@ -2014,9 +2029,9 @@ extern void __init vfs_caches_init(unsigned long);
 
 extern struct kmem_cache *names_cachep;
 
-#define __getname_gfp(gfp)	kmem_cache_alloc(names_cachep, (gfp))
-#define __getname()		__getname_gfp(GFP_KERNEL)
-#define __putname(name)		kmem_cache_free(names_cachep, (void *)(name))
+#define __getname_gfp(gfp)        kmem_cache_alloc(names_cachep, (gfp))
+#define __getname()                __getname_gfp(GFP_KERNEL)
+#define __putname(name)                kmem_cache_free(names_cachep, (void *)(name))
 #ifndef CONFIG_AUDITSYSCALL
 #define putname(name)   __putname(name)
 #else
@@ -2045,15 +2060,16 @@ static inline void invalidate_bdev(struct block_device *bdev) {}
 
 static inline struct super_block *freeze_bdev(struct block_device *sb)
 {
-	return NULL;
+        return NULL;
 }
 
 static inline int thaw_bdev(struct block_device *bdev, struct super_block *sb)
 {
-	return 0;
+        return 0;
 }
 #endif
 extern int sync_filesystem(struct super_block *);
+extern void sync_filesystems(int wait);
 extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;
 extern const struct file_operations bad_sock_fops;
@@ -2064,63 +2080,63 @@ extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long)
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder);
 extern struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,
-					       void *holder);
+                                               void *holder);
 extern struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode,
-					      void *holder);
+                                              void *holder);
 extern int blkdev_put(struct block_device *bdev, fmode_t mode);
 #ifdef CONFIG_SYSFS
 extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
 extern void bd_unlink_disk_holder(struct block_device *bdev,
-				  struct gendisk *disk);
+                                  struct gendisk *disk);
 #else
 static inline int bd_link_disk_holder(struct block_device *bdev,
-				      struct gendisk *disk)
+                                      struct gendisk *disk)
 {
-	return 0;
+        return 0;
 }
 static inline void bd_unlink_disk_holder(struct block_device *bdev,
-					 struct gendisk *disk)
+                                         struct gendisk *disk)
 {
 }
 #endif
 #endif
 
 /* fs/char_dev.c */
-#define CHRDEV_MAJOR_HASH_SIZE	255
+#define CHRDEV_MAJOR_HASH_SIZE        255
 extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 extern int register_chrdev_region(dev_t, unsigned, const char *);
 extern int __register_chrdev(unsigned int major, unsigned int baseminor,
-			     unsigned int count, const char *name,
-			     const struct file_operations *fops);
+                             unsigned int count, const char *name,
+                             const struct file_operations *fops);
 extern void __unregister_chrdev(unsigned int major, unsigned int baseminor,
-				unsigned int count, const char *name);
+                                unsigned int count, const char *name);
 extern void unregister_chrdev_region(dev_t, unsigned);
 extern void chrdev_show(struct seq_file *,off_t);
 
 static inline int register_chrdev(unsigned int major, const char *name,
-				  const struct file_operations *fops)
+                                  const struct file_operations *fops)
 {
-	return __register_chrdev(major, 0, 256, name, fops);
+        return __register_chrdev(major, 0, 256, name, fops);
 }
 
 static inline void unregister_chrdev(unsigned int major, const char *name)
 {
-	__unregister_chrdev(major, 0, 256, name);
+        __unregister_chrdev(major, 0, 256, name);
 }
 
 /* fs/block_dev.c */
-#define BDEVNAME_SIZE	32	/* Largest string for a blockdev identifier */
-#define BDEVT_SIZE	10	/* Largest string for MAJ:MIN for blkdev */
+#define BDEVNAME_SIZE        32        /* Largest string for a blockdev identifier */
+#define BDEVT_SIZE        10        /* Largest string for MAJ:MIN for blkdev */
 
 #ifdef CONFIG_BLOCK
-#define BLKDEV_MAJOR_HASH_SIZE	255
+#define BLKDEV_MAJOR_HASH_SIZE        255
 extern const char *__bdevname(dev_t, char *buffer);
 extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
 extern void blkdev_show(struct seq_file *,off_t);
 
 #else
-#define BLKDEV_MAJOR_HASH_SIZE	0
+#define BLKDEV_MAJOR_HASH_SIZE        0
 #endif
 
 extern void init_special_inode(struct inode *, umode_t, dev_t);
@@ -2139,48 +2155,48 @@ extern int fs_may_remount_ro(struct super_block *);
 /*
  * return READ, READA, or WRITE
  */
-#define bio_rw(bio)		((bio)->bi_rw & (RW_MASK | RWA_MASK))
+#define bio_rw(bio)                ((bio)->bi_rw & (RW_MASK | RWA_MASK))
 
 /*
  * return data direction, READ or WRITE
  */
-#define bio_data_dir(bio)	((bio)->bi_rw & 1)
+#define bio_data_dir(bio)        ((bio)->bi_rw & 1)
 
 extern void check_disk_size_change(struct gendisk *disk,
-				   struct block_device *bdev);
+                                   struct block_device *bdev);
 extern int revalidate_disk(struct gendisk *);
 extern int check_disk_change(struct block_device *);
 extern int __invalidate_device(struct block_device *, bool);
 extern int invalidate_partition(struct gendisk *, int);
 #endif
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
-					pgoff_t start, pgoff_t end);
+                                        pgoff_t start, pgoff_t end);
 
 static inline void invalidate_remote_inode(struct inode *inode)
 {
-	if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
-	    S_ISLNK(inode->i_mode))
-		invalidate_mapping_pages(inode->i_mapping, 0, -1);
+        if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
+            S_ISLNK(inode->i_mode))
+                invalidate_mapping_pages(inode->i_mapping, 0, -1);
 }
 extern int invalidate_inode_pages2(struct address_space *mapping);
 extern int invalidate_inode_pages2_range(struct address_space *mapping,
-					 pgoff_t start, pgoff_t end);
+                                         pgoff_t start, pgoff_t end);
 extern int write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_flush(struct address_space *);
 extern int filemap_fdatawait(struct address_space *);
 extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
-				   loff_t lend);
+                                   loff_t lend);
 extern int filemap_write_and_wait(struct address_space *mapping);
 extern int filemap_write_and_wait_range(struct address_space *mapping,
-				        loff_t lstart, loff_t lend);
+                                        loff_t lstart, loff_t lend);
 extern int __filemap_fdatawrite_range(struct address_space *mapping,
-				loff_t start, loff_t end, int sync_mode);
+                                loff_t start, loff_t end, int sync_mode);
 extern int filemap_fdatawrite_range(struct address_space *mapping,
-				loff_t start, loff_t end);
+                                loff_t start, loff_t end);
 
 extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
-			   int datasync);
+                           int datasync);
 extern int vfs_fsync(struct file *file, int datasync);
 extern int generic_write_sync(struct file *file, loff_t pos, loff_t count);
 extern void sync_supers(void);
@@ -2192,42 +2208,47 @@ extern sector_t bmap(struct inode *, sector_t);
 extern int notify_change(struct dentry *, struct iattr *);
 extern int inode_permission(struct inode *, int);
 extern int generic_permission(struct inode *, int, unsigned int,
-		int (*check_acl)(struct inode *, int, unsigned int));
+                int (*check_acl)(struct inode *, int, unsigned int));
 
 static inline bool execute_ok(struct inode *inode)
 {
-	return (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);
+        return (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);
+}
+
+static inline struct inode *file_inode(struct file *f)
+{
+	return f->f_path.dentry->d_inode;
 }
 
 extern int get_write_access(struct inode *);
 extern int deny_write_access(struct file *);
 static inline void put_write_access(struct inode * inode)
 {
-	atomic_dec(&inode->i_writecount);
+        atomic_dec(&inode->i_writecount);
 }
 static inline void allow_write_access(struct file *file)
 {
 	if (file)
-		atomic_inc(&file->f_path.dentry->d_inode->i_writecount);
+		atomic_inc(&file_inode(file)->i_writecount);
 }
 #ifdef CONFIG_IMA
 static inline void i_readcount_dec(struct inode *inode)
 {
-	BUG_ON(!atomic_read(&inode->i_readcount));
-	atomic_dec(&inode->i_readcount);
+        BUG_ON(!atomic_read(&inode->i_readcount));
+        atomic_dec(&inode->i_readcount);
 }
 static inline void i_readcount_inc(struct inode *inode)
 {
-	atomic_inc(&inode->i_readcount);
+        atomic_inc(&inode->i_readcount);
 }
 #else
 static inline void i_readcount_dec(struct inode *inode)
 {
-	return;
+        return;
 }
 static inline void i_readcount_inc(struct inode *inode)
 {
-	return;
+        return;
 }
 #endif
 extern int do_pipe_flags(int *, int);
@@ -2237,7 +2258,7 @@ extern void free_write_pipe(struct file *);
 
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern struct file * open_exec(const char *);
- 
+
 /* fs/dcache.c -- generic fs support functions */
 extern int is_subdir(struct dentry *, struct dentry *);
 extern int path_is_under(struct path *, struct path *);
@@ -2262,10 +2283,10 @@ extern int generic_delete_inode(struct inode *inode);
 extern int generic_drop_inode(struct inode *inode);
 
 extern struct inode *ilookup5_nowait(struct super_block *sb,
-		unsigned long hashval, int (*test)(struct inode *, void *),
-		void *data);
+                unsigned long hashval, int (*test)(struct inode *, void *),
+                void *data);
 extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
-		int (*test)(struct inode *, void *), void *data);
+                int (*test)(struct inode *, void *), void *data);
 extern struct inode *ilookup(struct super_block *sb, unsigned long ino);
 
 extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
@@ -2288,7 +2309,7 @@ extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 extern void remove_inode_hash(struct inode *);
 static inline void insert_inode_hash(struct inode *inode)
 {
-	__insert_inode_hash(inode, inode->i_ino);
+        __insert_inode_hash(inode, inode->i_ino);
 }
 extern void inode_sb_list_add(struct inode *inode);
 
@@ -2306,33 +2327,33 @@ extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long,
-		loff_t *);
+                loff_t *);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
-		unsigned long *, loff_t, loff_t *, size_t, size_t);
+                unsigned long *, loff_t, loff_t *, size_t, size_t);
 extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
-		unsigned long, loff_t, loff_t *, size_t, ssize_t);
+                unsigned long, loff_t, loff_t *, size_t, ssize_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 extern int generic_segment_checks(const struct iovec *iov,
-		unsigned long *nr_segs, size_t *count, int access_flags);
+                unsigned long *nr_segs, size_t *count, int access_flags);
 
 /* fs/block_dev.c */
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
-				unsigned long nr_segs, loff_t pos);
+                                unsigned long nr_segs, loff_t pos);
 extern int blkdev_fsync(struct file *filp, int datasync);
 
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,
-		struct pipe_inode_info *, size_t, unsigned int);
+                struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t default_file_splice_read(struct file *, loff_t *,
-		struct pipe_inode_info *, size_t, unsigned int);
+                struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
-		struct file *, loff_t *, size_t, unsigned int);
+                struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
-		struct file *out, loff_t *, size_t len, unsigned int flags);
+                struct file *out, loff_t *, size_t len, unsigned int flags);
 extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
-		size_t len, unsigned int flags);
+                size_t len, unsigned int flags);
 
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
@@ -2340,51 +2361,51 @@ extern loff_t noop_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek_unlocked(struct file *file, loff_t offset,
-			int origin);
+                        int origin);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 
 #ifdef CONFIG_FS_XIP
 extern ssize_t xip_file_read(struct file *filp, char __user *buf, size_t len,
-			     loff_t *ppos);
+                             loff_t *ppos);
 extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);
 extern ssize_t xip_file_write(struct file *filp, const char __user *buf,
-			      size_t len, loff_t *ppos);
+                              size_t len, loff_t *ppos);
 extern int xip_truncate_page(struct address_space *mapping, loff_t from);
 #else
 static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
 {
-	return 0;
+        return 0;
 }
 #endif
 
 #ifdef CONFIG_BLOCK
 typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
-			    loff_t file_offset);
+                            loff_t file_offset);
 
 enum {
-	/* need locking between buffered and direct access */
-	DIO_LOCKING	= 0x01,
+        /* need locking between buffered and direct access */
+        DIO_LOCKING        = 0x01,
 
-	/* filesystem does not support filling holes */
-	DIO_SKIP_HOLES	= 0x02,
+        /* filesystem does not support filling holes */
+        DIO_SKIP_HOLES        = 0x02,
 };
 
 void dio_end_io(struct bio *bio, int error);
 
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
-	struct block_device *bdev, const struct iovec *iov, loff_t offset,
-	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
-	dio_submit_t submit_io,	int flags);
+        struct block_device *bdev, const struct iovec *iov, loff_t offset,
+        unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
+        dio_submit_t submit_io,        int flags);
 
 static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
-	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_block_t get_block,
-	dio_iodone_t end_io)
+        struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+        loff_t offset, unsigned long nr_segs, get_block_t get_block,
+        dio_iodone_t end_io)
 {
-	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				    nr_segs, get_block, end_io, NULL,
-				    DIO_LOCKING | DIO_SKIP_HOLES);
+        return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+                                    nr_segs, get_block, end_io, NULL,
+                                    DIO_LOCKING | DIO_SKIP_HOLES);
 }
 #endif
 
@@ -2398,7 +2419,7 @@ extern int page_readlink(struct dentry *, char __user *, int);
 extern void *page_follow_link_light(struct dentry *, struct nameidata *);
 extern void page_put_link(struct dentry *, struct nameidata *, void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
-		int nofs);
+                int nofs);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
 extern int generic_readlink(struct dentry *, char __user *, int);
@@ -2418,14 +2439,14 @@ extern int vfs_fstat(unsigned int, struct kstat *);
 extern int vfs_fstatat(int , const char __user *, struct kstat *, int);
 
 extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
-		    unsigned long arg);
+                    unsigned long arg);
 extern int __generic_block_fiemap(struct inode *inode,
-				  struct fiemap_extent_info *fieinfo,
-				  loff_t start, loff_t len,
-				  get_block_t *get_block);
+                                  struct fiemap_extent_info *fieinfo,
+                                  loff_t start, loff_t len,
+                                  get_block_t *get_block);
 extern int generic_block_fiemap(struct inode *inode,
-				struct fiemap_extent_info *fieinfo, u64 start,
-				u64 len, get_block_t *get_block);
+                                struct fiemap_extent_info *fieinfo, u64 start,
+                                u64 len, get_block_t *get_block);
 
 extern void get_filesystem(struct file_system_type *fs);
 extern void put_filesystem(struct file_system_type *fs);
@@ -2451,11 +2472,11 @@ extern int noop_fsync(struct file *, int);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
 extern int simple_write_begin(struct file *file, struct address_space *mapping,
-			loff_t pos, unsigned len, unsigned flags,
-			struct page **pagep, void **fsdata);
+                        loff_t pos, unsigned len, unsigned flags,
+                        struct page **pagep, void **fsdata);
 extern int simple_write_end(struct file *file, struct address_space *mapping,
-			loff_t pos, unsigned len, unsigned copied,
-			struct page *page, void *fsdata);
+                        loff_t pos, unsigned len, unsigned copied,
+                        struct page *page, void *fsdata);
 
 extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
@@ -2468,9 +2489,9 @@ extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int
 extern void simple_release_fs(struct vfsmount **mount, int *count);
 
 extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
-			loff_t *ppos, const void *from, size_t available);
+                        loff_t *ppos, const void *from, size_t available);
 extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
-		const void __user *from, size_t count);
+                const void __user *from, size_t count);
 
 extern int generic_file_fsync(struct file *, int);
 
@@ -2478,7 +2499,8 @@ extern int generic_check_addressable(unsigned, u64);
 
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,
-				struct page *, struct page *);
+				struct page *, struct page *,
+				enum migrate_mode);
 #else
 #define buffer_migrate_page NULL
 #endif
@@ -2495,16 +2517,16 @@ extern void replace_mount_options(struct super_block *sb, char *options);
 
 static inline ino_t parent_ino(struct dentry *dentry)
 {
-	ino_t res;
+        ino_t res;
 
-	/*
-	 * Don't strictly need d_lock here? If the parent ino could change
-	 * then surely we'd have a deeper race in the caller?
-	 */
-	spin_lock(&dentry->d_lock);
-	res = dentry->d_parent->d_inode->i_ino;
-	spin_unlock(&dentry->d_lock);
-	return res;
+        /*
+         * Don't strictly need d_lock here? If the parent ino could change
+         * then surely we'd have a deeper race in the caller?
+         */
+        spin_lock(&dentry->d_lock);
+        res = dentry->d_parent->d_inode->i_ino;
+        spin_unlock(&dentry->d_lock);
+        return res;
 }
 
 /* Transaction based IO helpers */
@@ -2514,16 +2536,16 @@ static inline ino_t parent_ino(struct dentry *dentry)
  * size of the argument or response, along with its content
  */
 struct simple_transaction_argresp {
-	ssize_t size;
-	char data[0];
+        ssize_t size;
+        char data[0];
 };
 
 #define SIMPLE_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct simple_transaction_argresp))
 
 char *simple_transaction_get(struct file *file, const char __user *buf,
-				size_t size);
+                                size_t size);
 ssize_t simple_transaction_read(struct file *file, char __user *buf,
-				size_t size, loff_t *pos);
+                                size_t size, loff_t *pos);
 int simple_transaction_release(struct inode *inode, struct file *file);
 
 void simple_transaction_set(struct file *file, size_t n);
@@ -2544,61 +2566,61 @@ void simple_transaction_set(struct file *file, size_t n);
  * All attributes contain a text representation of a numeric value
  * that are accessed with the get() and set() functions.
  */
-#define DEFINE_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)		\
-static int __fops ## _open(struct inode *inode, struct file *file)	\
-{									\
-	__simple_attr_check_format(__fmt, 0ull);			\
-	return simple_attr_open(inode, file, __get, __set, __fmt);	\
-}									\
-static const struct file_operations __fops = {				\
-	.owner	 = THIS_MODULE,						\
-	.open	 = __fops ## _open,					\
-	.release = simple_attr_release,					\
-	.read	 = simple_attr_read,					\
-	.write	 = simple_attr_write,					\
-	.llseek	 = generic_file_llseek,					\
+#define DEFINE_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)                \
+static int __fops ## _open(struct inode *inode, struct file *file)        \
+{                                                                        \
+        __simple_attr_check_format(__fmt, 0ull);                        \
+        return simple_attr_open(inode, file, __get, __set, __fmt);        \
+}                                                                        \
+static const struct file_operations __fops = {                                \
+        .owner         = THIS_MODULE,                                                \
+        .open         = __fops ## _open,                                        \
+        .release = simple_attr_release,                                        \
+        .read         = simple_attr_read,                                        \
+        .write         = simple_attr_write,                                        \
+        .llseek         = generic_file_llseek,                                        \
 };
 
 static inline void __attribute__((format(printf, 1, 2)))
 __simple_attr_check_format(const char *fmt, ...)
 {
-	/* don't do anything, just let the compiler check the arguments; */
+        /* don't do anything, just let the compiler check the arguments; */
 }
 
 int simple_attr_open(struct inode *inode, struct file *file,
-		     int (*get)(void *, u64 *), int (*set)(void *, u64),
-		     const char *fmt);
+                     int (*get)(void *, u64 *), int (*set)(void *, u64),
+                     const char *fmt);
 int simple_attr_release(struct inode *inode, struct file *file);
 ssize_t simple_attr_read(struct file *file, char __user *buf,
-			 size_t len, loff_t *ppos);
+                         size_t len, loff_t *ppos);
 ssize_t simple_attr_write(struct file *file, const char __user *buf,
-			  size_t len, loff_t *ppos);
+                          size_t len, loff_t *ppos);
 
 struct ctl_table;
 int proc_nr_files(struct ctl_table *table, int write,
-		  void __user *buffer, size_t *lenp, loff_t *ppos);
+                  void __user *buffer, size_t *lenp, loff_t *ppos);
 int proc_nr_dentry(struct ctl_table *table, int write,
-		  void __user *buffer, size_t *lenp, loff_t *ppos);
+                  void __user *buffer, size_t *lenp, loff_t *ppos);
 int proc_nr_inodes(struct ctl_table *table, int write,
-		   void __user *buffer, size_t *lenp, loff_t *ppos);
+                   void __user *buffer, size_t *lenp, loff_t *ppos);
 int __init get_filesystem_list(char *buf);
 
-#define __FMODE_EXEC		((__force int) FMODE_EXEC)
-#define __FMODE_NONOTIFY	((__force int) FMODE_NONOTIFY)
+#define __FMODE_EXEC                ((__force int) FMODE_EXEC)
+#define __FMODE_NONOTIFY        ((__force int) FMODE_NONOTIFY)
 
 #define ACC_MODE(x) ("\004\002\006\006"[(x)&O_ACCMODE])
 #define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \
-					    (flag & __FMODE_NONOTIFY)))
+                                            (flag & __FMODE_NONOTIFY)))
 
 static inline int is_sxid(mode_t mode)
 {
-	return (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));
+        return (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));
 }
 
 static inline void inode_has_no_xattr(struct inode *inode)
 {
-	if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & MS_NOSEC))
-		inode->i_flags |= S_NOSEC;
+        if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & MS_NOSEC))
+                inode->i_flags |= S_NOSEC;
 }
 
 #endif /* __KERNEL__ */
diff --git a/include/linux/migrate.h b/include/linux/migrate.h
index 8982004..7b064ab 100644
--- a/include/linux/migrate.h
+++ b/include/linux/migrate.h
@@ -6,18 +6,41 @@
 
 typedef struct page *new_page_t(struct page *, unsigned long private, int **);
 
+/*
+ * MIGRATE_ASYNC means never block
+ * MIGRATE_SYNC_LIGHT in the current implementation means to allow blocking
+ *	on most operations but not ->writepage as the potential stall time
+ *	is too significant
+ * MIGRATE_SYNC will block when migrating pages
+ */
+enum migrate_mode {
+	MIGRATE_ASYNC,
+	MIGRATE_SYNC_LIGHT,
+	MIGRATE_SYNC,
+};
+
 #ifdef CONFIG_MIGRATION
 #define PAGE_MIGRATION 1
 
 extern void putback_lru_pages(struct list_head *l);
 extern int migrate_page(struct address_space *,
-			struct page *, struct page *);
+			struct page *, struct page *, enum migrate_mode);
+#ifndef CONFIG_DMA_CMA
+extern int migrate_pages(struct list_head *l, new_page_t x,
+			unsigned long private, bool offlining,
+			enum migrate_mode mode);
+#else
 extern int migrate_pages(struct list_head *l, new_page_t x,
 			unsigned long private, bool offlining,
-			bool sync, int tries);
+			enum migrate_mode mode, int tries);
+
+extern int migrate_replace_cma_page(struct page *oldpage,
+				       struct page **newpage);
+#endif
+
 extern int migrate_huge_pages(struct list_head *l, new_page_t x,
 			unsigned long private, bool offlining,
-			bool sync);
+			enum migrate_mode mode);
 
 extern int fail_migrate_page(struct address_space *,
 			struct page *, struct page *);
@@ -34,12 +57,22 @@ extern int migrate_huge_page_move_mapping(struct address_space *mapping,
 #define PAGE_MIGRATION 0
 
 static inline void putback_lru_pages(struct list_head *l) {}
+#ifndef CONFIG_DMA_CMA
+static inline int migrate_pages(struct list_head *l, new_page_t x,
+		unsigned long private, bool offlining,
+		enum migrate_mode mode) { return -ENOSYS; }
+#else
 static inline int migrate_pages(struct list_head *l, new_page_t x,
 		unsigned long private, bool offlining,
-		bool sync, int tries) { return -ENOSYS; }
+		enum migrate_mode mode, int tries) { return -ENOSYS; }
+
+static inline int migrate_replace_cma_page(struct page *oldpage,
+		struct page **newpage) { return -ENOSYS; }
+#endif
+
 static inline int migrate_huge_pages(struct list_head *l, new_page_t x,
 		unsigned long private, bool offlining,
-		bool sync) { return -ENOSYS; }
+		enum migrate_mode mode) { return -ENOSYS; }
 
 static inline int migrate_prep(void) { return -ENOSYS; }
 static inline int migrate_prep_local(void) { return -ENOSYS; }
diff --git a/include/linux/posix_acl.h b/include/linux/posix_acl.h
index 54211c1..2ee5c52 100644
--- a/include/linux/posix_acl.h
+++ b/include/linux/posix_acl.h
@@ -4,7 +4,6 @@
   (C) 2002 Andreas Gruenbacher, <a.gruenbacher@computer.org>
 */
 
-
 #ifndef __LINUX_POSIX_ACL_H
 #define __LINUX_POSIX_ACL_H
 
@@ -46,7 +45,6 @@ struct posix_acl {
 #define FOREACH_ACL_ENTRY(pa, acl, pe) \
 	for(pa=(acl)->a_entries, pe=pa+(acl)->a_count; pa<pe; pa++)
 
-
 /*
  * Duplicate an ACL handle.
  */
@@ -68,7 +66,6 @@ posix_acl_release(struct posix_acl *acl)
 		kfree(acl);
 }
 
-
 /* posix_acl.c */
 
 extern void posix_acl_init(struct posix_acl *, int);
@@ -80,6 +77,8 @@ extern struct posix_acl *posix_acl_from_mode(mode_t, gfp_t);
 extern int posix_acl_equiv_mode(const struct posix_acl *, mode_t *);
 extern int posix_acl_create_masq(struct posix_acl *, mode_t *);
 extern int posix_acl_chmod_masq(struct posix_acl *, mode_t);
+extern int posix_acl_create(struct posix_acl **, gfp_t, mode_t *);
+extern int posix_acl_chmod(struct posix_acl **, gfp_t, mode_t);
 
 extern struct posix_acl *get_posix_acl(struct inode *, int);
 extern int set_posix_acl(struct inode *, int, struct posix_acl *);

diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index 86d79d9..2e3fdab 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -292,6 +292,7 @@ struct rproc {
 	struct work_struct error_work;
 	struct blocking_notifier_head nbh;
 	struct completion error_comp;
+	void *cdump_buf0, *cdump_buf1;
 #ifdef CONFIG_REMOTE_PROC_AUTOSUSPEND
 	unsigned sus_timeout;
 	bool force_suspend;
diff --git a/include/linux/rwsem.h b/include/linux/rwsem.h
index a8afe9c..4659c3f 100644
--- a/include/linux/rwsem.h
+++ b/include/linux/rwsem.h
@@ -133,7 +133,8 @@ extern void down_write_nested(struct rw_semaphore *sem, int subclass);
 extern void down_read_non_owner(struct rw_semaphore *sem);
 extern void up_read_non_owner(struct rw_semaphore *sem);
 #else
-# define down_read_nested(sem, subclass)		down_read(sem)
+# define down_read_nested(sem, subclass)	down_read(sem)
+# define down_write_nest_lock(sem, nest_lock)   down_write(sem)
 # define down_write_nested(sem, subclass)	down_write(sem)
 # define down_read_non_owner(sem)		down_read(sem)
 # define up_read_non_owner(sem)			up_read(sem)
diff --git a/include/linux/swap.h b/include/linux/swap.h
index e73799d..31e8364 100644
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -194,6 +194,10 @@ struct swap_info_struct {
 	struct block_device *bdev;	/* swap device or bdev of swap file */
 	struct file *swap_file;		/* seldom referenced */
 	unsigned int old_block_size;	/* seldom referenced */
+#ifdef CONFIG_FRONTSWAP
+	unsigned long *frontswap_map;	/* frontswap in-use, one bit per page */
+	atomic_t frontswap_pages;		/* frontswap pages in-use counter */
+#endif
 };
 
 struct swap_list_t {
@@ -201,7 +205,7 @@ struct swap_list_t {
 	int next;	/* swapfile to be used next */
 };
 
-/* Swap 50% full? Release swapcache more aggressively.. */
+/* Swap 50% full?  */
 #define vm_swap_full() (nr_swap_pages*2 < total_swap_pages)
 
 /* linux/mm/page_alloc.c */
diff --git a/init/Kconfig b/init/Kconfig
index fe338c9..acfc9b1 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -76,7 +76,6 @@ config INIT_ENV_ARG_LIMIT
 	  Maximum of each of the number of arguments and environment
 	  variables passed to init from the kernel command line.
 
-
 config CROSS_COMPILE
 	string "Cross-compiler tool prefix"
 	help
@@ -1199,7 +1198,7 @@ config PCI_QUIRKS
           unaffected by PCI quirks.
 
 config SLUB_DEBUG
-	default y
+	default n
 	bool "Enable SLUB debugging support" if EXPERT
 	depends on SLUB && SYSFS
 	help
@@ -1218,7 +1217,7 @@ config COMPAT_BRK
 	  disabled, and can be overridden at runtime by setting
 	  /proc/sys/kernel/randomize_va_space to 2.
 
-	  On non-ancient distros (post-2000 ones) N is usually a safe choice.
+	  N is usually a safe choice.
 
 choice
 	prompt "Choose SLAB allocator"
@@ -1281,10 +1280,8 @@ config PROFILING
 	  Say Y here to enable the extended profiling support mechanisms used
 	  by profilers such as OProfile.
 
-#
 # Place an empty function call at each tracepoint site. Can be
 # dynamically changed for a probe function.
-#
 config TRACEPOINTS
 	bool
 
@@ -1326,6 +1323,7 @@ config BASE_SMALL
 
 menuconfig MODULES
 	bool "Enable loadable module support"
+	default y
 	help
 	  Kernel modules are small pieces of compiled code which can
 	  be inserted in the running kernel, rather than being
diff --git a/init/main.c b/init/main.c
index 72491c4..db0979d 100644
--- a/init/main.c
+++ b/init/main.c
@@ -6,7 +6,7 @@
  *  GK 2/5/95  -  Changed to support mounting root fs via NFS
  *  Added initrd & change_root: Werner Almesberger & Hans Lermen, Feb '96
  *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May '96
- *  Simplified starting of init:  Michael A. Griffith <grif@acm.org> 
+ *  Simplified starting of init:  Michael A. Griffith <grif@acm.org>
  */
 
 #include <linux/types.h>
@@ -176,8 +176,6 @@ static int __init obsolete_checksetup(char *line)
 				if (line[n] == '\0' || line[n] == '=')
 					had_early_param = 1;
 			} else if (!p->setup_func) {
-				printk(KERN_WARNING "Parameter %s is obsolete,"
-				       " ignored\n", p->str);
 				return 1;
 			} else if (p->setup_func(line + n))
 				return 1;
@@ -528,8 +526,6 @@ asmlinkage void __init start_kernel(void)
 	 */
 	preempt_disable();
 	if (!irqs_disabled()) {
-		printk(KERN_WARNING "start_kernel(): bug: interrupts were "
-				"enabled *very* early, fixing it\n");
 		local_irq_disable();
 	}
 	idr_init_cache();
@@ -652,14 +648,11 @@ static int __init_or_module do_one_initcall_debug(initcall_t fn)
 	unsigned long long duration;
 	int ret;
 
-	printk(KERN_DEBUG "calling  %pF @ %i\n", fn, task_pid_nr(current));
 	calltime = ktime_get();
 	ret = fn();
 	rettime = ktime_get();
 	delta = ktime_sub(rettime, calltime);
 	duration = (unsigned long long) ktime_to_ns(delta) >> 10;
-	printk(KERN_DEBUG "initcall %pF returned %d after %lld usecs\n", fn,
-		ret, duration);
 
 	return ret;
 }
@@ -694,7 +687,6 @@ int __init_or_module do_one_initcall(initcall_t fn)
 	return ret;
 }
 
-
 extern initcall_t __initcall_start[], __initcall_end[], __early_initcall_end[];
 
 static void __init do_initcalls(void)
@@ -748,14 +740,11 @@ void do_deferred_initcalls(void)
 	static int already_run;
 
 	if (already_run) {
-		pr_warn("%s() has already run\n", __func__);
 		return;
 	}
 
 	already_run = 1;
 
-	pr_info("%s()is running\n", __func__);
-
 	for (call = __deferred_initcall_start;
 			call < __deferred_initcall_end; call++)
 		do_one_initcall(*call);
@@ -766,11 +755,10 @@ void do_deferred_initcalls(void)
 }
 #endif /* CONFIG_DEFERRED_INITCALLS */
 
-/* This is a non __init function. Force it to be noinline otherwise gcc
- * makes it inline to init() and it becomes part of init.text section
- */
-static noinline int init_post(void)
+static void __init kernel_init_freeable(void);
+static int __ref kernel_init(void *unused)
 {
+	kernel_init_freeable();
 	/* need to finish all async __init code before freeing the memory */
 	async_synchronize_full();
 #if !defined(CONFIG_DEFERRED_INITCALLS)
@@ -780,45 +768,29 @@ static noinline int init_post(void)
 	system_state = SYSTEM_RUNNING;
 	numa_default_policy();
 
-
 	current->signal->flags |= SIGNAL_UNKILLABLE;
 
 	if (ramdisk_execute_command) {
 		run_init_process(ramdisk_execute_command);
-		printk(KERN_WARNING "Failed to execute %s\n",
-				ramdisk_execute_command);
+		printk(KERN_WARNING "Failed to execute %s\n", ramdisk_execute_command);
 	}
 
-	/*
-	 * We try each of these until one succeeds.
-	 *
-	 * The Bourne shell can be used instead of init if we are
-	 * trying to recover a really broken machine.
-	 */
 	if (execute_command) {
 		run_init_process(execute_command);
-		printk(KERN_WARNING "Failed to execute %s.  Attempting "
-					"defaults...\n", execute_command);
 	}
 	run_init_process("/sbin/init");
-	run_init_process("/etc/init");
-	run_init_process("/bin/init");
-	run_init_process("/bin/sh");
 
-	panic("No init found.  Try passing init= option to kernel. "
-	      "See Linux Documentation/init.txt for guidance.");
+	panic("No init found.  Try passing init= option to kernel. ");
 }
 
-static int __init kernel_init(void * unused)
+static void __init kernel_init_freeable(void)
 {
 	/*
 	 * Wait until kthreadd is all set-up.
 	 */
 	wait_for_completion(&kthreadd_done);
-
 	/* Now the scheduler is fully set up and can do blocking allocations */
 	gfp_allowed_mask = __GFP_BITS_MASK;
-
 	/*
 	 * init can allocate pages on any node
 	 */
@@ -847,10 +819,8 @@ static int __init kernel_init(void * unused)
 	(void) sys_dup(0);
 	(void) sys_dup(0);
 	/*
-	 * check if there is an early userspace init.  If yes, let it do all
-	 * the work
+	 * check if there is an early userspace init.  If yes, let it do all the work
 	 */
-
 	if (!ramdisk_execute_command)
 		ramdisk_execute_command = "/init";
 
@@ -860,11 +830,6 @@ static int __init kernel_init(void * unused)
 	}
 
 	/*
-	 * Ok, we have completed the initial bootup, and
-	 * we're essentially up and running. Get rid of the
-	 * initmem segments and start the user-mode stuff..
+	 * Ok, we have completed the initial bootup
 	 */
-
-	init_post();
-	return 0;
 }

diff --git a/kernel/power/earlysuspend.c b/kernel/power/earlysuspend.c
index 95998fe..503e5b8 100644
--- a/kernel/power/earlysuspend.c
+++ b/kernel/power/earlysuspend.c
@@ -77,7 +77,6 @@ static void early_suspend(struct work_struct *work)
 	struct early_suspend *pos;
 	unsigned long irqflags;
 	int abort = 0;
-	char symname[KSYM_NAME_LEN];
 
 	mutex_lock(&early_suspend_lock);
 	spin_lock_irqsave(&state_lock, irqflags);
@@ -88,22 +87,12 @@ static void early_suspend(struct work_struct *work)
 	spin_unlock_irqrestore(&state_lock, irqflags);
 
 	if (abort) {
-		if (debug_mask & DEBUG_SUSPEND)
-			pr_info("early_suspend: abort, state %d\n", state);
 		mutex_unlock(&early_suspend_lock);
 		goto abort;
 	}
 
-	if (debug_mask & DEBUG_SUSPEND)
-		pr_info("early_suspend: call handlers\n");
 	list_for_each_entry(pos, &early_suspend_handlers, link) {
 		if (pos->suspend != NULL) {
-			if (debug_mask & DEBUG_VERBOSE) {
-				lookup_symbol_name(
-					(unsigned long)pos->suspend, symname);
-				pr_info("early_suspend: %s\n", symname);
-			}
-
 			pos->suspend(pos);
 		}
 	}
@@ -112,9 +101,6 @@ static void early_suspend(struct work_struct *work)
 	/*run sys_sync workqueue*/
 	suspend_sys_sync_queue();
 
-	if (debug_mask & DEBUG_SUSPEND)
-		pr_info("early_suspend: sync\n");
-
 abort:
 	spin_lock_irqsave(&state_lock, irqflags);
 	if (state == SUSPEND_REQUESTED_AND_SUSPENDED)
@@ -127,7 +113,6 @@ static void late_resume(struct work_struct *work)
 	struct early_suspend *pos;
 	unsigned long irqflags;
 	int abort = 0;
-	char symname[KSYM_NAME_LEN];
 
 	mutex_lock(&early_suspend_lock);
 	spin_lock_irqsave(&state_lock, irqflags);
@@ -138,25 +123,14 @@ static void late_resume(struct work_struct *work)
 	spin_unlock_irqrestore(&state_lock, irqflags);
 
 	if (abort) {
-		if (debug_mask & DEBUG_SUSPEND)
-			pr_info("late_resume: abort, state %d\n", state);
 		goto abort;
 	}
-	if (debug_mask & DEBUG_SUSPEND)
-		pr_info("late_resume: call handlers\n");
 	list_for_each_entry_reverse(pos, &early_suspend_handlers, link) {
 		if (pos->resume != NULL) {
-			if (debug_mask & DEBUG_VERBOSE) {
-				lookup_symbol_name(
-					(unsigned long)pos->resume, symname);
-				pr_info("late_resume: %s\n", symname);
-			}
-
 			pos->resume(pos);
 		}
 	}
-	if (debug_mask & DEBUG_SUSPEND)
-		pr_info("late_resume: done\n");
+
 abort:
 	mutex_unlock(&early_suspend_lock);
 }
@@ -173,13 +147,6 @@ void request_suspend_state(suspend_state_t new_state)
 		struct rtc_time tm;
 		getnstimeofday(&ts);
 		rtc_time_to_tm(ts.tv_sec, &tm);
-		pr_info("request_suspend_state: %s (%d->%d) at %lld "
-			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n",
-			new_state != PM_SUSPEND_ON ? "sleep" : "wakeup",
-			requested_suspend_state, new_state,
-			ktime_to_ns(ktime_get()),
-			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
-			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
 	}
 	if (!old_sleep && new_state != PM_SUSPEND_ON) {
 		state |= SUSPEND_REQUESTED;
diff --git a/kernel/power/power.h b/kernel/power/power.h
index 37843ad..9352666 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -66,7 +66,7 @@ extern int pfn_is_nosave(unsigned long);
 static struct kobj_attribute _name##_attr = {	\
 	.attr	= {				\
 		.name = __stringify(_name),	\
-		.mode = 0644,			\
+		.mode = 0664,			\
 	},					\
 	.show	= _name##_show,			\
 	.store	= _name##_store,		\
diff --git a/kernel/sched_features.h b/kernel/sched_features.h
index 1e7066d..69956b4 100644
--- a/kernel/sched_features.h
+++ b/kernel/sched_features.h
@@ -3,7 +3,7 @@
  * them to run sooner, but does not allow tons of sleepers to
  * rip the spread apart.
  */
-SCHED_FEAT(GENTLE_FAIR_SLEEPERS, 1)
+SCHED_FEAT(GENTLE_FAIR_SLEEPERS, 0)
 
 /*
  * Place new tasks ahead so that they do not starve already running
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 856cc66..97ded87 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -83,7 +83,6 @@
 #include <linux/nmi.h>
 #endif
 
-
 #if defined(CONFIG_SYSCTL)
 
 /* External variables not in a header file. */
@@ -247,7 +246,6 @@ int rom_feature_set_sysctl(struct ctl_table *table, int write,
 			return 0;
 		}
 		rom_feature_set_save = rom_feature_set;
-		printk("Initializing USB with rom_feature_set: %d\n", rom_feature_set);
 		late_init_android_gadget(rom_feature_set);
 	}
 	return 0;
@@ -312,7 +310,7 @@ static struct ctl_table kern_table[] = {
 		.procname	= "rom_feature_set",
 		.data		= &rom_feature_set,
 		.maxlen		= sizeof(unsigned int),
-		.mode		= 0644,
+		.mode		= 0664,
 		.proc_handler	= rom_feature_set_sysctl,
 	},
 #endif
@@ -1065,7 +1063,7 @@ static struct ctl_table vm_table[] = {
 		.proc_handler	= proc_dointvec,
 	},
 	{
-		.procname	= "page-cluster", 
+		.procname	= "page-cluster",
 		.data		= &page_cluster,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
@@ -1076,7 +1074,7 @@ static struct ctl_table vm_table[] = {
 		.procname	= "dirty_background_ratio",
 		.data		= &dirty_background_ratio,
 		.maxlen		= sizeof(dirty_background_ratio),
-		.mode		= 0644,
+		.mode		= 0444 /* read-only*/,
 		.proc_handler	= dirty_background_ratio_handler,
 		.extra1		= &zero,
 		.extra2		= &one_hundred,
@@ -1085,7 +1083,7 @@ static struct ctl_table vm_table[] = {
 		.procname	= "dirty_background_bytes",
 		.data		= &dirty_background_bytes,
 		.maxlen		= sizeof(dirty_background_bytes),
-		.mode		= 0644,
+		.mode		= 0444 /* read-only*/,
 		.proc_handler	= dirty_background_bytes_handler,
 		.extra1		= &one_ul,
 	},
@@ -1093,7 +1091,7 @@ static struct ctl_table vm_table[] = {
 		.procname	= "dirty_ratio",
 		.data		= &vm_dirty_ratio,
 		.maxlen		= sizeof(vm_dirty_ratio),
-		.mode		= 0644,
+		.mode		= 0444 /* read-only*/,
 		.proc_handler	= dirty_ratio_handler,
 		.extra1		= &zero,
 		.extra2		= &one_hundred,
@@ -1102,7 +1100,7 @@ static struct ctl_table vm_table[] = {
 		.procname	= "dirty_bytes",
 		.data		= &vm_dirty_bytes,
 		.maxlen		= sizeof(vm_dirty_bytes),
-		.mode		= 0644,
+		.mode		= 0444 /* read-only*/,
 		.proc_handler	= dirty_bytes_handler,
 		.extra1		= &dirty_bytes_min,
 	},
@@ -1110,14 +1108,14 @@ static struct ctl_table vm_table[] = {
 		.procname	= "dirty_writeback_centisecs",
 		.data		= &dirty_writeback_interval,
 		.maxlen		= sizeof(dirty_writeback_interval),
-		.mode		= 0644,
+		.mode		= 0444 /* read-only*/,
 		.proc_handler	= dirty_writeback_centisecs_handler,
 	},
 	{
 		.procname	= "dirty_expire_centisecs",
 		.data		= &dirty_expire_interval,
 		.maxlen		= sizeof(dirty_expire_interval),
-		.mode		= 0644,
+		.mode		= 0444 /* read-only*/,
 		.proc_handler	= proc_dointvec_minmax,
 		.extra1		= &zero,
 	},
@@ -1132,7 +1130,7 @@ static struct ctl_table vm_table[] = {
 		.procname	= "swappiness",
 		.data		= &vm_swappiness,
 		.maxlen		= sizeof(vm_swappiness),
-		.mode		= 0644,
+		.mode		= 0444 /* read-only*/,
 		.proc_handler	= proc_dointvec_minmax,
 		.extra1		= &zero,
 		.extra2		= &one_hundred,
@@ -1518,7 +1516,7 @@ static struct ctl_table fs_table[] = {
 		.mode		= 0555,
 		.child		= inotify_table,
 	},
-#endif	
+#endif
 #ifdef CONFIG_EPOLL
 	{
 		.procname	= "epoll",
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 9e53052..7191b7d 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -141,7 +141,6 @@ static inline s64 timekeeping_get_ns_raw(void)
  */
 __cacheline_aligned_in_smp DEFINE_SEQLOCK(xtime_lock);
 
-
 /*
  * The current time
  * wall_to_monotonic is what we need to add to xtime (or xtime corrected
@@ -193,8 +192,6 @@ static void timekeeping_update(bool clearntp)
 			 timekeeper.clock, timekeeper.mult);
 }
 
-
-
 /* flag for if timekeeping is suspended */
 int __read_mostly timekeeping_suspended;
 
@@ -407,7 +404,6 @@ int do_settimeofday(const struct timespec *tv)
 
 EXPORT_SYMBOL(do_settimeofday);
 
-
 /**
  * timekeeping_inject_offset - Adds or subtracts from the current time.
  * @tv:		pointer to the timespec variable containing the offset
@@ -521,7 +517,6 @@ void getrawmonotonic(struct timespec *ts)
 }
 EXPORT_SYMBOL(getrawmonotonic);
 
-
 /**
  * timekeeping_valid_for_hres - Check if timekeeping is suitable for hres
  */
@@ -592,16 +587,12 @@ void __init timekeeping_init(void)
 
 	read_persistent_clock(&now);
 	if (!timespec_valid_strict(&now)) {
-		pr_warn("WARNING: Persistent clock returned invalid value!\n"
-			"         Check your CMOS/BIOS settings.\n");
 		now.tv_sec = 0;
 		now.tv_nsec = 0;
 	}
 
 	read_boot_clock(&boot);
 	if (!timespec_valid_strict(&boot)) {
-		pr_warn("WARNING: Boot clock returned invalid value!\n"
-			"         Check your CMOS/BIOS settings.\n");
 		boot.tv_sec = 0;
 		boot.tv_nsec = 0;
 	}
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 0d704b0..71edb70 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -1516,7 +1516,6 @@ static void ftrace_bug(int failed, unsigned long ip)
 	}
 }
 
-
 /* Return 1 if the address range is reserved for ftrace */
 int ftrace_text_reserved(void *start, void *end)
 {
@@ -1531,7 +1530,6 @@ int ftrace_text_reserved(void *start, void *end)
 	return 0;
 }
 
-
 static int
 __ftrace_replace_code(struct dyn_ftrace *rec, int update)
 {
@@ -2577,7 +2575,6 @@ static void __disable_ftrace_function_probe(void)
 	ftrace_probe_registered = 0;
 }
 
-
 static void ftrace_free_entry_rcu(struct rcu_head *rhp)
 {
 	struct ftrace_func_probe *entry =
@@ -2588,7 +2585,6 @@ static void ftrace_free_entry_rcu(struct rcu_head *rhp)
 	kfree(entry);
 }
 
-
 int
 register_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,
 			      void *data)
@@ -3021,8 +3017,7 @@ static void __init set_ftrace_early_graph(char *buf)
 		ret = ftrace_set_func(ftrace_graph_funcs, &ftrace_graph_count,
 				      func);
 		if (ret)
-			printk(KERN_DEBUG "ftrace: function %s not "
-					  "traceable\n", func);
+			printk(KERN_DEBUG "ftrace: function %s not traceable\n", func);
 	}
 }
 #endif /* CONFIG_FUNCTION_GRAPH_TRACER */
@@ -3349,10 +3344,10 @@ static __init int ftrace_init_dyn_debugfs(struct dentry *d_tracer)
 	trace_create_file("enabled_functions", 0444,
 			d_tracer, NULL, &ftrace_enabled_fops);
 
-	trace_create_file("set_ftrace_filter", 0644, d_tracer,
+	trace_create_file("set_ftrace_filter", 0664, d_tracer,
 			NULL, &ftrace_filter_fops);
 
-	trace_create_file("set_ftrace_notrace", 0644, d_tracer,
+	trace_create_file("set_ftrace_notrace", 0664, d_tracer,
 				    NULL, &ftrace_notrace_fops);
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
@@ -3509,12 +3504,7 @@ void __init ftrace_init(void)
 				  __stop_mcount_loc);
 
 	ret = register_module_notifier(&ftrace_module_enter_nb);
-	if (ret)
-		pr_warning("Failed to register trace ftrace module enter notifier\n");
-
 	ret = register_module_notifier(&ftrace_module_exit_nb);
-	if (ret)
-		pr_warning("Failed to register trace ftrace module exit notifier\n");
 
 	set_ftrace_early_filters();
 
@@ -3883,7 +3873,6 @@ int register_ftrace_function(struct ftrace_ops *ops)
 	if (!ret)
 		ret = ftrace_startup(ops, 0);
 
-
  out_unlock:
 	mutex_unlock(&ftrace_lock);
 	return ret;
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 1747a71..b1d0119 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -477,13 +477,8 @@ static struct cpu_workqueue_struct *get_cwq(unsigned int cpu,
 					    struct workqueue_struct *wq)
 {
 	if (!(wq->flags & WQ_UNBOUND)) {
-		if (likely(cpu < nr_cpu_ids)) {
-#ifdef CONFIG_SMP
+		if (likely(cpu < nr_cpu_ids))
 			return per_cpu_ptr(wq->cpu_wq.pcpu, cpu);
-#else
-			return wq->cpu_wq.single;
-#endif
-		}
 	} else if (likely(cpu == WORK_CPU_UNBOUND))
 		return wq->cpu_wq.single;
 	return NULL;
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 26af27a..34e4eeb 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1,4 +1,3 @@
-
 config PRINTK_TIME
 	bool "Show timing information on printks"
 	depends on PRINTK
@@ -19,13 +18,13 @@ config PRINTK_CPU_ID
 	  See Documentation/kernel-parameters.txt
 
 config PRINTK_PID
-        bool "Show pid on printks"
-        depends on PRINTK
-        help
-          Selecting this option causes current task's pid to be
-          included in printk output. Or add printk.pid=1 at boot-time.
-          This allows you to see the running process with kernel log.
-          See Documentation/kernel-parameters.txt
+    bool "Show pid on printks"
+    depends on PRINTK
+    help
+      Selecting this option causes current task's pid to be
+      included in printk output. Or add printk.pid=1 at boot-time.
+      This allows you to see the running process with kernel log.
+      See Documentation/kernel-parameters.txt
 
 config DEFAULT_MESSAGE_LOGLEVEL
 	int "Default message log level (1-7)"
@@ -702,7 +701,7 @@ config DEBUG_KOBJECT
 	depends on DEBUG_KERNEL
 	help
 	  If you say Y here, some extra kobject debugging messages will be sent
-	  to the syslog. 
+	  to the syslog.
 
 config DEBUG_HIGHMEM
 	bool "Highmem debugging"
@@ -1271,8 +1270,6 @@ config ASYNC_RAID6_TEST
 
 	  If unsure, say N.
 
-source "samples/Kconfig"
-
 source "lib/Kconfig.kgdb"
 
 source "lib/Kconfig.kmemcheck"
diff --git a/mm/Makefile b/mm/Makefile
index 70e47dc..19d5c10 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -25,28 +25,29 @@ obj-$(CONFIG_HAVE_MEMBLOCK) += memblock.o
 
 obj-$(CONFIG_BOUNCE)	+= bounce.o
 obj-$(CONFIG_SWAP)	+= page_io.o swap_state.o swapfile.o thrash.o
+obj-$(CONFIG_FRONTSWAP)	+= frontswap.o
 obj-$(CONFIG_HAS_DMA)	+= dmapool.o
 obj-$(CONFIG_HUGETLBFS)	+= hugetlb.o
 obj-$(CONFIG_NUMA) 	+= mempolicy.o
 obj-$(CONFIG_SPARSEMEM)	+= sparse.o
 obj-$(CONFIG_SPARSEMEM_VMEMMAP) += sparse-vmemmap.o
-obj-$(CONFIG_ASHMEM) += ashmem.o
-obj-$(CONFIG_SLOB) += slob.o
+obj-$(CONFIG_ASHMEM) 	+= ashmem.o
 obj-$(CONFIG_MMU_NOTIFIER) += mmu_notifier.o
-obj-$(CONFIG_KSM) += ksm.o
+obj-$(CONFIG_KSM) 	+= ksm.o
 obj-$(CONFIG_PAGE_POISONING) += debug-pagealloc.o
-obj-$(CONFIG_SLAB) += slab.o
-obj-$(CONFIG_SLUB) += slub.o
+obj-$(CONFIG_SLAB) 	+= slab.o
+obj-$(CONFIG_SLOB) 	+= slob.o
+obj-$(CONFIG_SLUB) 	+= slub.o
 obj-$(CONFIG_KMEMCHECK) += kmemcheck.o
-obj-$(CONFIG_FAILSLAB) += failslab.o
+obj-$(CONFIG_FAILSLAB) 	+= failslab.o
 obj-$(CONFIG_MEMORY_HOTPLUG) += memory_hotplug.o
-obj-$(CONFIG_FS_XIP) += filemap_xip.o
+obj-$(CONFIG_FS_XIP) 	+= filemap_xip.o
 obj-$(CONFIG_MIGRATION) += migrate.o
 obj-$(CONFIG_QUICKLIST) += quicklist.o
 obj-$(CONFIG_TRANSPARENT_HUGEPAGE) += huge_memory.o
-obj-$(CONFIG_CGROUP_MEM_RES_CTLR) += memcontrol.o page_cgroup.o
-obj-$(CONFIG_MEMORY_FAILURE) += memory-failure.o
+obj-$(CONFIG_CGROUP_MEM_RES_CTLR)  += memcontrol.o page_cgroup.o
+obj-$(CONFIG_MEMORY_FAILURE)  += memory-failure.o
 obj-$(CONFIG_HWPOISON_INJECT) += hwpoison-inject.o
-obj-$(CONFIG_DEBUG_KMEMLEAK) += kmemleak.o
+obj-$(CONFIG_DEBUG_KMEMLEAK)  += kmemleak.o
 obj-$(CONFIG_DEBUG_KMEMLEAK_TEST) += kmemleak-test.o
-obj-$(CONFIG_CLEANCACHE) += cleancache.o
+obj-$(CONFIG_CLEANCACHE)      += cleancache.o
diff --git a/mm/madvise.c b/mm/madvise.c
index a659bd3..a62a2dc 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -207,8 +207,9 @@ static long madvise_remove(struct vm_area_struct *vma,
 
 	f = vma->vm_file;
 
-	if (!f || !f->f_mapping || !f->f_mapping->host)
-			return -EINVAL;
+	if (!f || !f->f_mapping || !f->f_mapping->host) {
+		return -EINVAL;
+	}
 
 	if ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))
 		return -EACCES;
diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index bd788ae..5de8362 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -9,23 +9,23 @@
  * High level machine check handler. Handles pages reported by the
  * hardware as being corrupted usually due to a multi-bit ECC memory or cache
  * failure.
- * 
+ *
  * In addition there is a "soft offline" entry point that allows stop using
  * not-yet-corrupted-by-suspicious pages without killing anything.
  *
  * Handles page cache pages in various states.	The tricky part
- * here is that we can access any page asynchronously in respect to 
- * other VM users, because memory failures could happen anytime and 
- * anywhere. This could violate some of their assumptions. This is why 
- * this code has to be extremely careful. Generally it tries to use 
- * normal locking rules, as in get the standard locks, even if that means 
+ * here is that we can access any page asynchronously in respect to
+ * other VM users, because memory failures could happen anytime and
+ * anywhere. This could violate some of their assumptions. This is why
+ * this code has to be extremely careful. Generally it tries to use
+ * normal locking rules, as in get the standard locks, even if that means
  * the error handling takes potentially a long time.
- * 
+ *
  * There are several operations here with exponential complexity because
- * of unsuitable VM data structures. For example the operation to map back 
- * from RMAP chains to processes has to walk the complete process list and 
+ * of unsuitable VM data structures. For example the operation to map back
+ * from RMAP chains to processes has to walk the complete process list and
  * has non linear complexity with the number. But since memory corruptions
- * are rare we hope to get away with this. This avoids impacting the core 
+ * are rare we hope to get away with this. This avoids impacting the core
  * VM.
  */
 
@@ -800,16 +800,6 @@ static struct page_state {
 #undef slab
 #undef reserved
 
-static void action_result(unsigned long pfn, char *msg, int result)
-{
-	struct page *page = pfn_to_page(pfn);
-
-	printk(KERN_ERR "MCE %#lx: %s%s page recovery: %s\n",
-		pfn,
-		PageDirty(page) ? "dirty " : "",
-		msg, action_name[result]);
-}
-
 static int page_action(struct page_state *ps, struct page *p,
 			unsigned long pfn)
 {
@@ -817,15 +807,11 @@ static int page_action(struct page_state *ps, struct page *p,
 	int count;
 
 	result = ps->action(p, pfn);
-	action_result(pfn, ps->msg, result);
 
 	count = page_count(p) - 1;
 	if (ps->action == me_swapcache_dirty && result == DELAYED)
 		count--;
 	if (count != 0) {
-		printk(KERN_ERR
-		       "MCE %#lx: %s page still referenced by %d users\n",
-		       pfn, ps->msg, count);
 		result = FAILED;
 	}
 
@@ -866,8 +852,6 @@ static int hwpoison_user_mappings(struct page *p, unsigned long pfn,
 		return SWAP_FAIL;
 
 	if (PageSwapCache(p)) {
-		printk(KERN_ERR
-		       "MCE %#lx: keeping poisoned page in swap cache\n", pfn);
 		ttu |= TTU_IGNORE_HWPOISON;
 	}
 
@@ -885,9 +869,6 @@ static int hwpoison_user_mappings(struct page *p, unsigned long pfn,
 		} else {
 			kill = 0;
 			ttu |= TTU_IGNORE_HWPOISON;
-			printk(KERN_INFO
-	"MCE %#lx: corrupted page was clean: dropped without side effects\n",
-				pfn);
 		}
 	}
 
@@ -918,9 +899,6 @@ static int hwpoison_user_mappings(struct page *p, unsigned long pfn,
 				 * than causing panic by unmapping. System might
 				 * survive if the page is freed later.
 				 */
-				printk(KERN_INFO
-					"MCE %#lx: failed to split THP\n", pfn);
-
 				BUG_ON(!PageHWPoison(p));
 				return SWAP_FAIL;
 			}
@@ -944,9 +922,6 @@ static int hwpoison_user_mappings(struct page *p, unsigned long pfn,
 		lock_page(ppage);
 
 	ret = try_to_unmap(ppage, ttu);
-	if (ret != SWAP_SUCCESS)
-		printk(KERN_ERR "MCE %#lx: failed to unmap page (mapcount=%d)\n",
-				pfn, page_mapcount(ppage));
 
 	if (hpage != ppage)
 		unlock_page(ppage);
@@ -994,16 +969,12 @@ int __memory_failure(unsigned long pfn, int trapno, int flags)
 		panic("Memory failure from trap %d on page %lx", trapno, pfn);
 
 	if (!pfn_valid(pfn)) {
-		printk(KERN_ERR
-		       "MCE %#lx: memory outside kernel control\n",
-		       pfn);
 		return -ENXIO;
 	}
 
 	p = pfn_to_page(pfn);
 	hpage = compound_head(p);
 	if (TestSetPageHWPoison(p)) {
-		printk(KERN_ERR "MCE %#lx: already hardware poisoned\n", pfn);
 		return 0;
 	}
 
@@ -1027,7 +998,6 @@ int __memory_failure(unsigned long pfn, int trapno, int flags)
 	if (!(flags & MF_COUNT_INCREASED) &&
 		!get_page_unless_zero(hpage)) {
 		if (is_free_buddy_page(p)) {
-			action_result(pfn, "free buddy", DELAYED);
 			return 0;
 		} else if (PageHuge(hpage)) {
 			/*
@@ -1043,12 +1013,9 @@ int __memory_failure(unsigned long pfn, int trapno, int flags)
 			}
 			set_page_hwpoison_huge_page(hpage);
 			res = dequeue_hwpoisoned_huge_page(hpage);
-			action_result(pfn, "free huge",
-				      res ? IGNORED : DELAYED);
 			unlock_page(hpage);
 			return res;
 		} else {
-			action_result(pfn, "high order kernel", IGNORED);
 			return -EBUSY;
 		}
 	}
@@ -1069,11 +1036,8 @@ int __memory_failure(unsigned long pfn, int trapno, int flags)
 			 * shake_page could have turned it free.
 			 */
 			if (is_free_buddy_page(p)) {
-				action_result(pfn, "free buddy, 2nd try",
-						DELAYED);
 				return 0;
 			}
-			action_result(pfn, "non LRU", IGNORED);
 			put_page(p);
 			return -EBUSY;
 		}
@@ -1090,7 +1054,6 @@ int __memory_failure(unsigned long pfn, int trapno, int flags)
 	 * unpoison always clear PG_hwpoison inside page lock
 	 */
 	if (!PageHWPoison(p)) {
-		printk(KERN_ERR "MCE %#lx: just unpoisoned\n", pfn);
 		res = 0;
 		goto out;
 	}
@@ -1107,8 +1070,6 @@ int __memory_failure(unsigned long pfn, int trapno, int flags)
 	 * on the head page to show that the hugepage is hwpoisoned
 	 */
 	if (PageHuge(p) && PageTail(p) && TestSetPageHWPoison(hpage)) {
-		action_result(pfn, "hugepage already hardware poisoned",
-				IGNORED);
 		unlock_page(hpage);
 		put_page(hpage);
 		return 0;
@@ -1129,7 +1090,6 @@ int __memory_failure(unsigned long pfn, int trapno, int flags)
 	 * Abort on fail: __delete_from_page_cache() assumes unmapped page.
 	 */
 	if (hwpoison_user_mappings(p, pfn, trapno) != SWAP_SUCCESS) {
-		printk(KERN_ERR "MCE %#lx: cannot unmap page, give up\n", pfn);
 		res = -EBUSY;
 		goto out;
 	}
@@ -1138,7 +1098,6 @@ int __memory_failure(unsigned long pfn, int trapno, int flags)
 	 * Torn down by someone else?
 	 */
 	if (PageLRU(p) && !PageSwapCache(p) && p->mapping == NULL) {
-		action_result(pfn, "already truncated LRU", IGNORED);
 		res = -EBUSY;
 		goto out;
 	}
@@ -1204,7 +1163,6 @@ int unpoison_memory(unsigned long pfn)
 	page = compound_head(p);
 
 	if (!PageHWPoison(p)) {
-		pr_info("MCE: Page was already unpoisoned %#lx\n", pfn);
 		return 0;
 	}
 
@@ -1218,12 +1176,10 @@ int unpoison_memory(unsigned long pfn)
 		 * to the end.
 		 */
 		if (PageHuge(page)) {
-			pr_debug("MCE: Memory failure is now running on free hugepage %#lx\n", pfn);
 			return 0;
 		}
 		if (TestClearPageHWPoison(p))
 			atomic_long_sub(nr_pages, &mce_bad_pages);
-		pr_info("MCE: Software-unpoisoned free page %#lx\n", pfn);
 		return 0;
 	}
 
@@ -1235,7 +1191,6 @@ int unpoison_memory(unsigned long pfn)
 	 * the free buddy page pool.
 	 */
 	if (TestClearPageHWPoison(page)) {
-		pr_info("MCE: Software-unpoisoned page %#lx\n", pfn);
 		atomic_long_sub(nr_pages, &mce_bad_pages);
 		freeit = 1;
 		if (PageHuge(page))
@@ -1291,16 +1246,12 @@ static int get_any_page(struct page *p, unsigned long pfn, int flags)
 	 */
 	if (!get_page_unless_zero(compound_head(p))) {
 		if (PageHuge(p)) {
-			pr_info("get_any_page: %#lx free huge page\n", pfn);
 			ret = dequeue_hwpoisoned_huge_page(compound_head(p));
 		} else if (is_free_buddy_page(p)) {
-			pr_info("get_any_page: %#lx free buddy page\n", pfn);
 			/* Set hwpoison bit while page is still isolated */
 			SetPageHWPoison(p);
 			ret = 0;
 		} else {
-			pr_info("get_any_page: %#lx: unknown zero refcount page type %lx\n",
-				pfn, p->flags);
 			ret = -EIO;
 		}
 	} else {
@@ -1327,22 +1278,18 @@ static int soft_offline_huge_page(struct page *page, int flags)
 
 	if (PageHWPoison(hpage)) {
 		put_page(hpage);
-		pr_debug("soft offline: %#lx hugepage already poisoned\n", pfn);
 		return -EBUSY;
 	}
 
 	/* Keep page count to indicate a given hugepage is isolated. */
 
 	list_add(&hpage->lru, &pagelist);
-	ret = migrate_huge_pages(&pagelist, new_page, MPOL_MF_MOVE_ALL, false,
-				MIGRATE_SYNC);
+	ret = migrate_huge_pages(&pagelist, new_page, MPOL_MF_MOVE_ALL, false, MIGRATE_SYNC);
 	if (ret) {
 		struct page *page1, *page2;
 		list_for_each_entry_safe(page1, page2, &pagelist, lru)
 			put_page(page1);
 
-		pr_debug("soft offline: %#lx: migration failed %d, type %lx\n",
-			 pfn, ret, page->flags);
 		if (ret > 0)
 			ret = -EIO;
 		return ret;
@@ -1388,8 +1335,6 @@ int soft_offline_page(struct page *page, int flags)
 		return soft_offline_huge_page(page, flags);
 	if (PageTransHuge(hpage)) {
 		if (PageAnon(hpage) && unlikely(split_huge_page(hpage))) {
-			pr_info("soft offline: %#lx: failed to split THP\n",
-				pfn);
 			return -EBUSY;
 		}
 	}
@@ -1420,8 +1365,6 @@ int soft_offline_page(struct page *page, int flags)
 			goto done;
 	}
 	if (!PageLRU(page)) {
-		pr_info("soft_offline: %#lx: unknown non LRU page type %lx\n",
-				pfn, page->flags);
 		return -EIO;
 	}
 
@@ -1434,7 +1377,6 @@ int soft_offline_page(struct page *page, int flags)
 	if (PageHWPoison(page)) {
 		unlock_page(page);
 		put_page(page);
-		pr_info("soft offline: %#lx page already poisoned\n", pfn);
 		return -EBUSY;
 	}
 
@@ -1451,7 +1393,6 @@ int soft_offline_page(struct page *page, int flags)
 	if (ret == 1) {
 		put_page(page);
 		ret = 0;
-		pr_info("soft_offline: %#lx: invalidated\n", pfn);
 		goto done;
 	}
 
@@ -1471,18 +1412,12 @@ int soft_offline_page(struct page *page, int flags)
 		inc_zone_page_state(page, NR_ISOLATED_ANON +
 					    page_is_file_cache(page));
 		list_add(&page->lru, &pagelist);
-		ret = migrate_pages(&pagelist, new_page, MPOL_MF_MOVE_ALL,
-							false, MIGRATE_SYNC);
+		ret = migrate_pages(&pagelist, new_page, MPOL_MF_MOVE_ALL, false, MIGRATE_SYNC);
 		if (ret) {
 			putback_lru_pages(&pagelist);
-			pr_info("soft offline: %#lx: migration failed %d, type %lx\n",
-				pfn, ret, page->flags);
 			if (ret > 0)
 				ret = -EIO;
 		}
-	} else {
-		pr_info("soft offline: %#lx: isolation failed: %d, page count %d, type %lx\n",
-				pfn, ret, page_count(page), page->flags);
 	}
 	if (ret)
 		return ret;
diff --git a/mm/memory.c b/mm/memory.c
index 6d516db..24436aa 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -123,7 +123,6 @@ static int __init init_zero_pfn(void)
 }
 core_initcall(init_zero_pfn);
 
-
 #if defined(SPLIT_RSS_COUNTING)
 
 static void __sync_task_rss_stat(struct task_struct *task, struct mm_struct *mm)
@@ -1659,7 +1658,7 @@ int __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 
 	VM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));
 
-	/* 
+	/*
 	 * Require read or write permissions.
 	 * If FOLL_FORCE is set, we only require the "MAY" flags.
 	 */
@@ -2906,7 +2905,6 @@ void unmap_mapping_range(struct address_space *mapping,
 	if (details.last_index < details.first_index)
 		details.last_index = ULONG_MAX;
 
-
 	mutex_lock(&mapping->i_mmap_mutex);
 	if (unlikely(!prio_tree_empty(&mapping->i_mmap)))
 		unmap_mapping_range_tree(&mapping->i_mmap, &details);
@@ -3066,7 +3064,7 @@ static int do_swap_page(struct mm_struct *mm, struct vm_area_struct *vma,
 	mem_cgroup_commit_charge_swapin(page, ptr);
 
 	swap_free(entry);
-	if (vm_swap_full() || (vma->vm_flags & VM_LOCKED) || PageMlocked(page))
+	if ((vma->vm_flags & VM_LOCKED) || PageMlocked(page))
 		try_to_free_swap(page);
 	unlock_page(page);
 	if (swapcache) {
diff --git a/mm/mempolicy.c b/mm/mempolicy.c
index 70ff1e0..25b3564 100644
--- a/mm/mempolicy.c
+++ b/mm/mempolicy.c
@@ -572,7 +572,6 @@ check_range(struct mm_struct *mm, unsigned long start, unsigned long end,
 	int err;
 	struct vm_area_struct *first, *vma, *prev;
 
-
 	first = find_vma(mm, start);
 	if (!first)
 		return ERR_PTR(-EFAULT);
@@ -617,11 +616,6 @@ static int vma_replace_policy(struct vm_area_struct *vma,
 	struct mempolicy *old;
 	struct mempolicy *new;
 
-	pr_debug("vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\n",
-		 vma->vm_start, vma->vm_end, vma->vm_pgoff,
-		 vma->vm_ops, vma->vm_file,
-		 vma->vm_ops ? vma->vm_ops->set_policy : NULL);
-
 	new = mpol_dup(pol);
 	if (IS_ERR(new))
 		return PTR_ERR(new);
@@ -1378,7 +1372,6 @@ out:
 	return err;
 }
 
-
 /* Retrieve NUMA policy */
 SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,
 		unsigned long __user *, nmask, unsigned long, maxnode,
@@ -1842,18 +1835,24 @@ struct page *
 alloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,
 		unsigned long addr, int node)
 {
diff --git a/mm/migrate.c b/mm/migrate.c
index 75f9c01..3e315a7 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -233,30 +233,55 @@ void migration_entry_wait_huge(struct mm_struct *mm, pte_t *pte)
 	__migration_entry_wait(mm, pte, ptl);
 }
 
-#ifdef CONFIG_CMA
-extern struct page *failed_pages[5][10];
-
-static int is_failed_page(struct page *page, int pass, int tries)
+#ifdef CONFIG_BLOCK
+/* Returns true if all buffers are successfully locked */
+static bool buffer_migrate_lock_buffers(struct buffer_head *head,
+							enum migrate_mode mode)
 {
-	if (tries == 4 && pass == 9) {
-		int i, j, k = 1;
+	struct buffer_head *bh = head;
 
-		for (i = 0; i < 5; i++) {
-			for (j = 0; j < 10; j++) {
-				if (failed_pages[i][j] == page)
-					k++;
-			}
-		}
+	/* Simple case, sync compaction */
+	if (mode != MIGRATE_ASYNC) {
+		do {
+			get_bh(bh);
+			lock_buffer(bh);
+			bh = bh->b_this_page;
+
+		} while (bh != head);
 
-		printk(KERN_ERR "%s[%d]: %d fails\n", __func__, __LINE__, k);
-		return 1;
+		return true;
 	}
 
-	return 0;
+	/* async case, we cannot block on lock_buffer so use trylock_buffer */
+	do {
+		get_bh(bh);
+		if (!trylock_buffer(bh)) {
+			/*
+			 * We failed to lock the buffer and cannot stall in
+			 * async migration. Release the taken locks
+			 */
+			struct buffer_head *failed_bh = bh;
+			put_bh(failed_bh);
+			bh = head;
+			while (bh != failed_bh) {
+				unlock_buffer(bh);
+				put_bh(bh);
+				bh = bh->b_this_page;
+			}
+			return false;
+		}
+
+		bh = bh->b_this_page;
+	} while (bh != head);
+	return true;
 }
 #else
-#define is_failed_page(page, pass, tries)	0
-#endif
+static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,
+							enum migrate_mode mode)
+{
+	return true;
+}
+#endif /* CONFIG_BLOCK */
 
 /*
  * Replace the page in the mapping.
@@ -268,21 +293,15 @@ static int is_failed_page(struct page *page, int pass, int tries)
  */
 static int migrate_page_move_mapping(struct address_space *mapping,
 		struct page *newpage, struct page *page,
-		int pass, int tries)
+		struct buffer_head *head, enum migrate_mode mode)
 {
 	int expected_count;
 	void **pslot;
 
 	if (!mapping) {
 		/* Anonymous page without mapping */
-		if (page_count(page) != 1) {
-			if (is_failed_page(page, pass, tries)) {
-				printk(KERN_ERR "%s[%d]: 1 ",
-						 __func__, __LINE__);
-				dump_page(page);
-			}
+		if (page_count(page) != 1)
 			return -EAGAIN;
-		}
 		return 0;
 	}
 
@@ -295,19 +314,25 @@ static int migrate_page_move_mapping(struct address_space *mapping,
 	if (page_count(page) != expected_count ||
 		radix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {
 		spin_unlock_irq(&mapping->tree_lock);
-		if (is_failed_page(page, pass, tries)) {
-			printk("%s[%d]: 2 ", __func__, __LINE__);
-			dump_page(page);
-		}
 		return -EAGAIN;
 	}
 
 	if (!page_freeze_refs(page, expected_count)) {
 		spin_unlock_irq(&mapping->tree_lock);
-		if (is_failed_page(page, pass, tries)) {
-			printk("%s[%d]: 3 ", __func__, __LINE__);
-			dump_page(page);
-		}
+		return -EAGAIN;
+	}
+
+	/*
+	 * In the async migration case of moving a page with buffers, lock the
+	 * buffers using trylock before the mapping is moved. If the mapping
+	 * was moved, we later failed to lock the buffers and could not move
+	 * the mapping back due to an elevated page count, we would have to
+	 * block waiting on other references to be dropped.
+	 */
+	if (mode == MIGRATE_ASYNC && head &&
+			!buffer_migrate_lock_buffers(head, mode)) {
+		page_unfreeze_refs(page, expected_count);
+		spin_unlock_irq(&mapping->tree_lock);
 		return -EAGAIN;
 	}
 
@@ -467,33 +492,22 @@ EXPORT_SYMBOL(fail_migrate_page);
  *
  * Pages are locked upon entry and exit.
  */
-static int __migrate_page(struct address_space *mapping,
+int migrate_page(struct address_space *mapping,
 		struct page *newpage, struct page *page,
-		int pass, int tries)
+		enum migrate_mode mode)
 {
 	int rc;
 
 	BUG_ON(PageWriteback(page));	/* Writeback must be complete */
 
-	rc = migrate_page_move_mapping(mapping, newpage, page, pass, tries);
+	rc = migrate_page_move_mapping(mapping, newpage, page, NULL, mode);
 
-	if (rc) {
-		if (is_failed_page(page, pass, tries)) {
-			printk("%s[%d]: 1 ", __func__, __LINE__);
-			dump_page(page);
-		}
+	if (rc)
 		return rc;
-	}
 
 	migrate_page_copy(newpage, page);
 	return 0;
 }
-
-int migrate_page(struct address_space *mapping,
-		struct page *newpage, struct page *page)
-{
-	return __migrate_page(mapping, newpage, page, 0, 0);
-}
 EXPORT_SYMBOL(migrate_page);
 
 #ifdef CONFIG_BLOCK
@@ -503,28 +517,28 @@ EXPORT_SYMBOL(migrate_page);
  * exist.
  */
 int buffer_migrate_page(struct address_space *mapping,
-		struct page *newpage, struct page *page)
+		struct page *newpage, struct page *page, enum migrate_mode mode)
 {
 	struct buffer_head *bh, *head;
 	int rc;
 
 	if (!page_has_buffers(page))
-		return migrate_page(mapping, newpage, page);
+		return migrate_page(mapping, newpage, page, mode);
 
 	head = page_buffers(page);
 
-	rc = migrate_page_move_mapping(mapping, newpage, page, 0, 0);
+	rc = migrate_page_move_mapping(mapping, newpage, page, head, mode);
 
 	if (rc)
 		return rc;
 
-	bh = head;
-	do {
-		get_bh(bh);
-		lock_buffer(bh);
-		bh = bh->b_this_page;
-
-	} while (bh != head);
+	/*
+	 * In the async case, migrate_page_move_mapping locked the buffers
+	 * with an IRQ-safe spinlock held. In the sync case, the buffers
+	 * need to be locked now
+	 */
+	if (mode != MIGRATE_ASYNC)
+		BUG_ON(!buffer_migrate_lock_buffers(head, mode));
 
 	ClearPagePrivate(page);
 	set_page_private(newpage, page_private(page));
@@ -601,17 +615,13 @@ static int writeout(struct address_space *mapping, struct page *page)
  * Default handling if a filesystem does not provide a migration function.
  */
 static int fallback_migrate_page(struct address_space *mapping,
-	struct page *newpage, struct page *page, int pass, int tries)
+	struct page *newpage, struct page *page, enum migrate_mode mode)
 {
-	int rc;
-
 	if (PageDirty(page)) {
-		rc = writeout(mapping, page);
-		if (is_failed_page(page, pass, tries)) {
-			printk("%s[%d] 1 ", __func__, __LINE__);
-			dump_page(page);
-		}
-		return rc;
+		/* Only writeback pages in full synchronous migration */
+		if (mode != MIGRATE_SYNC)
+			return -EBUSY;
+		return writeout(mapping, page);
 	}
 
 	/*
@@ -619,22 +629,10 @@ static int fallback_migrate_page(struct address_space *mapping,
 	 * We must have no buffers or drop them.
 	 */
 	if (page_has_private(page) &&
-	    !try_to_release_page(page, GFP_KERNEL)) {
-		if (is_failed_page(page, pass, tries)) {
-			printk("%s[%d] 2 ", __func__, __LINE__);
-			dump_page(page);
-		}
+	    !try_to_release_page(page, GFP_KERNEL))
 		return -EAGAIN;
-	}
 
-	rc = __migrate_page(mapping, newpage, page, pass, tries);
-	if (rc) {
-		if (is_failed_page(page, pass, tries)) {
-			printk("%s[%d] 3 ", __func__, __LINE__);
-			dump_page(page);
-		}
-	}
-	return rc;
+	return migrate_page(mapping, newpage, page, mode);
 }
 
 /*
@@ -649,11 +647,10 @@ static int fallback_migrate_page(struct address_space *mapping,
  *  == 0 - success
  */
 static int move_to_new_page(struct page *newpage, struct page *page,
-					int remap_swapcache, bool sync,
-					int pass, int tries)
+				int remap_swapcache, enum migrate_mode mode)
 {
 	struct address_space *mapping;
-	int rc = 0;
+	int rc;
 
 	/*
 	 * Block others from accessing the page when we get around to
@@ -670,59 +667,19 @@ static int move_to_new_page(struct page *newpage, struct page *page,
 		SetPageSwapBacked(newpage);
 
 	mapping = page_mapping(page);
-	if (!mapping) {
-		rc = __migrate_page(mapping, newpage, page, pass, tries);
-		if (rc) {
-			if (is_failed_page(page, pass, tries)) {
-				printk("%s[%d]: 1 ", __func__, __LINE__);
-				dump_page(page);
-			}
-		}
-	} else {
+	if (!mapping)
+		rc = migrate_page(mapping, newpage, page, mode);
+	else if (mapping->a_ops->migratepage)
 		/*
-		 * Do not writeback pages if !sync and migratepage is
-		 * not pointing to migrate_page() which is nonblocking
-		 * (swapcache/tmpfs uses migratepage = migrate_page).
+		 * Most pages have a mapping and most filesystems provide a
+		 * migratepage callback. Anonymous pages are part of swap
+		 * space which also has its own migratepage callback. This
+		 * is the most common path for page migration.
 		 */
-		if (PageDirty(page) && !sync &&
-		    mapping->a_ops->migratepage != migrate_page) {
-			rc = -EBUSY;
-			if (rc) {
-				if (is_failed_page(page, pass, tries)) {
-					printk(KERN_ERR "%s[%d]: 2 ",
-							 __func__, __LINE__);
-					dump_page(page);
-				}
-			}
-		} else if (mapping->a_ops->migratepage) {
-			/*
-			 * Most pages have a mapping and most filesystems
-			 * should provide a migration function. Anonymous
-			 * pages are part of swap space which also has its
-			 * own migration function. This is the most common
-			 * path for page migration.
-			 */
-			rc = mapping->a_ops->migratepage(mapping,
-							newpage, page);
-			if (rc) {
-				if (is_failed_page(page, pass, tries)) {
-					printk(KERN_ERR "%s[%d]: 3 ",
-							__func__, __LINE__);
-					dump_page(page);
-				}
-			}
-		} else	{
-			rc = fallback_migrate_page(mapping, newpage, page,
-							 pass, tries);
-			if (rc) {
-				if (is_failed_page(page, pass, tries)) {
-					printk(KERN_ERR "%s[%d]: 4 ",
-							__func__, __LINE__);
-					dump_page(page);
-				}
-			}
-		}
-	}
+		rc = mapping->a_ops->migratepage(mapping,
+						newpage, page, mode);
+	else
+		rc = fallback_migrate_page(mapping, newpage, page, mode);
 
 	if (rc) {
 		newpage->mapping = NULL;
@@ -736,44 +693,18 @@ static int move_to_new_page(struct page *newpage, struct page *page,
 	return rc;
 }
 
-/*
- * Obtain the lock on page, remove all ptes and migrate the page
- * to the newly allocated page in newpage.
- */
-static int unmap_and_move(new_page_t get_new_page, unsigned long private,
-			struct page *page, int force, bool offlining, bool sync,
-			int pass, int tries)
+static int __unmap_and_move(struct page *page, struct page *newpage,
+			int force, bool offlining, enum migrate_mode mode)
 {
-	int rc = 0;
-	int *result = NULL;
-	struct page *newpage = get_new_page(page, private, &result);
+	int rc = -EAGAIN;
 	int remap_swapcache = 1;
 	int charge = 0;
 	struct mem_cgroup *mem;
 	struct anon_vma *anon_vma = NULL;
 
-	if (!newpage)
-		return -ENOMEM;
-
-	if (page_count(page) == 1) {
-		/* page was freed from under us. So we are done. */
-		goto move_newpage;
-	}
-	if (unlikely(PageTransHuge(page)))
-		if (unlikely(split_huge_page(page)))
-			goto move_newpage;
-
-	/* prepare cgroup just returns 0 or -ENOMEM */
-	rc = -EAGAIN;
-
 	if (!trylock_page(page)) {
-		if (!force || !sync) {
-			if (is_failed_page(page, pass, tries)) {
-				printk("%s[%d] 1 ", __func__, __LINE__);
-				dump_page(page);
-			}
-			goto move_newpage;
-		}
+		if (!force || mode == MIGRATE_ASYNC)
+			goto out;
 
 		/*
 		 * It's not safe for direct compaction to call lock_page.
@@ -788,13 +719,8 @@ static int unmap_and_move(new_page_t get_new_page, unsigned long private,
 		 * avoid the use of lock_page for direct compaction
 		 * altogether.
 		 */
-		if (current->flags & PF_MEMALLOC) {
-			if (is_failed_page(page, pass, tries)) {
-				printk("%s[%d] 2 ", __func__, __LINE__);
-				dump_page(page);
-			}
-			goto move_newpage;
-		}
+		if (current->flags & PF_MEMALLOC)
+			goto out;
 
 		lock_page(page);
 	}
@@ -813,11 +739,6 @@ static int unmap_and_move(new_page_t get_new_page, unsigned long private,
 		goto unlock;
 	}
 
-	if (invalidate_inode_page(page)) {
-		rc = 0;
-		goto unlock;
-	}
-
 	/* charge against new page */
 	charge = mem_cgroup_prepare_migration(page, newpage, &mem, GFP_KERNEL);
 	if (charge == -ENOMEM) {
@@ -828,10 +749,12 @@ static int unmap_and_move(new_page_t get_new_page, unsigned long private,
 
 	if (PageWriteback(page)) {
 		/*
-		 * For !sync, there is no point retrying as the retry loop
-		 * is expected to be too short for PageWriteback to be cleared
+		 * Only in the case of a full syncronous migration is it
+		 * necessary to wait for PageWriteback. In the async case,
+		 * the retry loop is too short and in the sync-light case,
+		 * the overhead of stalling is too much
 		 */
-		if (!sync) {
+		if (mode != MIGRATE_SYNC) {
 			rc = -EBUSY;
 			goto uncharge;
 		}
@@ -872,10 +795,6 @@ static int unmap_and_move(new_page_t get_new_page, unsigned long private,
 			 */
 			remap_swapcache = 0;
 		} else {
-			if (is_failed_page(page, pass, tries)) {
-				printk("%s[%d] 3 ", __func__, __LINE__);
-				dump_page(page);
-			}
 			goto uncharge;
 		}
 	}
@@ -896,10 +815,6 @@ static int unmap_and_move(new_page_t get_new_page, unsigned long private,
 		VM_BUG_ON(PageAnon(page));
 		if (page_has_private(page)) {
 			try_to_free_buffers(page);
-			if (is_failed_page(page, pass, tries)) {
-				printk("%s[%d] 4 ", __func__, __LINE__);
-				dump_page(page);
-			}
 			goto uncharge;
 		}
 		goto skip_unmap;
@@ -909,16 +824,8 @@ static int unmap_and_move(new_page_t get_new_page, unsigned long private,
 	try_to_unmap(page, TTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);
 
 skip_unmap:
-	if (!page_mapped(page)) {
-		rc = move_to_new_page(newpage, page, remap_swapcache, sync,
-					pass, tries);
-		if (rc) {
-			if (is_failed_page(page, pass, tries)) {
-				printk("%s[%d] 5 ", __func__, __LINE__);
-				dump_page(page);
-			}
-		}
-	}
+	if (!page_mapped(page))
+		rc = move_to_new_page(newpage, page, remap_swapcache, mode);
 
 	if (rc && remap_swapcache)
 		remove_migration_ptes(page, page);
@@ -932,27 +839,53 @@ uncharge:
 		mem_cgroup_end_migration(mem, page, newpage, rc == 0);
 unlock:
 	unlock_page(page);
+out:
+	return rc;
+}
+
+/*
+ * Obtain the lock on page, remove all ptes and migrate the page
+ * to the newly allocated page in newpage.
+ */
+static int unmap_and_move(new_page_t get_new_page, unsigned long private,
+			struct page *page, int force, bool offlining,
+			enum migrate_mode mode)
+{
+	int rc = 0;
+	int *result = NULL;
+	struct page *newpage = get_new_page(page, private, &result);
+
+	if (!newpage)
+		return -ENOMEM;
 
-move_newpage:
+	if (page_count(page) == 1) {
+		/* page was freed from under us. So we are done. */
+		goto out;
+	}
+
+	if (unlikely(PageTransHuge(page)))
+		if (unlikely(split_huge_page(page)))
+			goto out;
+
+	rc = __unmap_and_move(page, newpage, force, offlining, mode);
+out:
 	if (rc != -EAGAIN) {
- 		/*
- 		 * A page that has been migrated has all references
- 		 * removed and will be freed. A page that has not been
- 		 * migrated will have kepts its references and be
- 		 * restored.
- 		 */
- 		list_del(&page->lru);
+		/*
+		 * A page that has been migrated has all references
+		 * removed and will be freed. A page that has not been
+		 * migrated will have kepts its references and be
+		 * restored.
+		 */
+		list_del(&page->lru);
 		dec_zone_page_state(page, NR_ISOLATED_ANON +
 				page_is_file_cache(page));
 		putback_lru_page(page);
 	}
-
 	/*
 	 * Move the new page to the LRU. If migration was not successful
 	 * then this will free the page.
 	 */
 	putback_lru_page(newpage);
-
 	if (result) {
 		if (rc)
 			*result = rc;
@@ -982,7 +915,8 @@ move_newpage:
  */
 static int unmap_and_move_huge_page(new_page_t get_new_page,
 				unsigned long private, struct page *hpage,
-				int force, bool offlining, bool sync)
+				int force, bool offlining,
+				enum migrate_mode mode)
 {
 	int rc = 0;
 	int *result = NULL;
@@ -995,7 +929,7 @@ static int unmap_and_move_huge_page(new_page_t get_new_page,
 	rc = -EAGAIN;
 
 	if (!trylock_page(hpage)) {
-		if (!force || !sync)
+		if (!force || mode != MIGRATE_SYNC)
 			goto out;
 		lock_page(hpage);
 	}
@@ -1006,7 +940,7 @@ static int unmap_and_move_huge_page(new_page_t get_new_page,
 	try_to_unmap(hpage, TTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);
 
 	if (!page_mapped(hpage))
-		rc = move_to_new_page(new_hpage, hpage, 1, sync, 0, 0);
+		rc = move_to_new_page(new_hpage, hpage, 1, mode);
 
 	if (rc)
 		remove_migration_ptes(hpage, hpage);
@@ -1032,8 +966,6 @@ out:
 	return rc;
 }
 
-struct page *migrate_pages_current = NULL;
-
 /*
  * migrate_pages
  *
@@ -1051,7 +983,7 @@ struct page *migrate_pages_current = NULL;
  */
 int migrate_pages(struct list_head *from,
 		new_page_t get_new_page, unsigned long private, bool offlining,
-		bool sync, int tries)
+		enum migrate_mode mode)
 {
 	int retry = 1;
 	int nr_failed = 0;
@@ -1072,11 +1004,7 @@ int migrate_pages(struct list_head *from,
 
 			rc = unmap_and_move(get_new_page, private,
 						page, pass > 2, offlining,
-						sync, pass, tries);
-#ifdef CONFIG_CMA
-			if (rc)
-				failed_pages[tries][pass] = page;
-#endif
+						mode);
 
 			switch(rc) {
 			case -ENOMEM:
@@ -1106,7 +1034,7 @@ out:
 
 int migrate_huge_pages(struct list_head *from,
 		new_page_t get_new_page, unsigned long private, bool offlining,
-		bool sync)
+		enum migrate_mode mode)
 {
 	int retry = 1;
 	int nr_failed = 0;
@@ -1123,7 +1051,7 @@ int migrate_huge_pages(struct list_head *from,
 
 			rc = unmap_and_move_huge_page(get_new_page,
 					private, page, pass > 2, offlining,
-					sync);
+					mode);
 
 			switch(rc) {
 			case -ENOMEM:
@@ -1252,7 +1180,7 @@ set_status:
 	err = 0;
 	if (!list_empty(&pagelist)) {
 		err = migrate_pages(&pagelist, new_page_node,
-				(unsigned long)pm, 0, true, 0);
+				(unsigned long)pm, 0, MIGRATE_SYNC);
 		if (err)
 			putback_lru_pages(&pagelist);
 	}
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 21d589e..0fe209a 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -203,7 +203,7 @@ static char * const zone_names[MAX_NR_ZONES] = {
 };
 
 int min_free_kbytes = 1024;
-int min_free_order_shift = 1;
+int min_free_order_shift = 4;
 
 static unsigned long __meminitdata nr_kernel_pages;
 static unsigned long __meminitdata nr_all_pages;
@@ -935,7 +935,6 @@ struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,
 	return NULL;
 }
 
-
 /*
  * This array describes the order lists are fallen back to when
  * the free lists for the desirable migrate type are depleted
@@ -1154,7 +1153,6 @@ static struct page *__rmqueue_cma(struct zone *zone, unsigned int order,
 retry_reserve :
 		page = __rmqueue_smallest(zone, order, migratetype);
 
-
 	if (unlikely(!page) && migratetype != MIGRATE_RESERVE) {
 		page = __rmqueue_fallback(zone, order, migratetype);
 
@@ -1456,8 +1454,7 @@ int split_free_page(struct page *page, bool for_cma)
 		for (; page < endpage; page += pageblock_nr_pages) {
 			int mt = get_pageblock_migratetype(page);
 			if (mt != MIGRATE_ISOLATE && !is_migrate_cma(mt))
-				set_pageblock_migratetype(page,
-							  MIGRATE_MOVABLE);
+				set_pageblock_migratetype(page, MIGRATE_MOVABLE);
 		}
 	}
 
@@ -2562,8 +2559,9 @@ __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
 {
 	enum zone_type high_zoneidx = gfp_zone(gfp_mask);
 	struct zone *preferred_zone;
-	struct page *page;
+	struct page *page = NULL;
 	int migratetype = allocflags_to_migratetype(gfp_mask);
+	unsigned int cpuset_mems_cookie;
 
 	gfp_mask &= gfp_allowed_mask;
 
@@ -2582,15 +2580,15 @@ __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
 	if (unlikely(!zonelist->_zonerefs->zone))
 		return NULL;
 
-	get_mems_allowed();
+retry_cpuset:
+	cpuset_mems_cookie = get_mems_allowed();
+
 	/* The preferred zone is used for statistics later */
 	first_zones_zonelist(zonelist, high_zoneidx,
 				nodemask ? : &cpuset_current_mems_allowed,
 				&preferred_zone);
-	if (!preferred_zone) {
-		put_mems_allowed();
-		return NULL;
-	}
+	if (!preferred_zone)
+		goto out;
 
 	/* First allocation attempt */
 	page = get_page_from_freelist(gfp_mask|__GFP_HARDWALL, nodemask, order,
@@ -2600,9 +2598,19 @@ __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
 		page = __alloc_pages_slowpath(gfp_mask, order,
 				zonelist, high_zoneidx, nodemask,
 				preferred_zone, migratetype);
-	put_mems_allowed();
 
 	trace_mm_page_alloc(page, order, gfp_mask, migratetype);
+
+out:
+	/*
+	 * When updating a task's mems_allowed, it is possible to race with
+	 * parallel threads in such a way that an allocation can fail while
+	 * the mask is being updated. If a page allocation is about to fail,
+	 * check if the cpuset changed during allocation and if so, retry.
+	 */
+	if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))
+		goto retry_cpuset;
+
 	return page;
 }
 EXPORT_SYMBOL(__alloc_pages_nodemask);
@@ -2826,13 +2834,15 @@ void si_meminfo_node(struct sysinfo *val, int nid)
 bool skip_free_areas_node(unsigned int flags, int nid)
 {
 	bool ret = false;
+	unsigned int cpuset_mems_cookie;
 
 	if (!(flags & SHOW_MEM_FILTER_NODES))
 		goto out;
 
-	get_mems_allowed();
-	ret = !node_isset(nid, cpuset_current_mems_allowed);
-	put_mems_allowed();
+	do {
+		cpuset_mems_cookie = get_mems_allowed();
+		ret = !node_isset(nid, cpuset_current_mems_allowed);
+	} while (!put_mems_allowed(cpuset_mems_cookie));
 out:
 	return ret;
 }
@@ -3052,7 +3062,6 @@ static int build_zonelists_node(pg_data_t *pgdat, struct zonelist *zonelist,
 	return nr_zones;
 }
 
-
 /*
  *  zonelist_order:
  *  0 = automatic detection of better ordering.
@@ -3072,7 +3081,6 @@ static int build_zonelists_node(pg_data_t *pgdat, struct zonelist *zonelist,
 static int current_zonelist_order = ZONELIST_ORDER_DEFAULT;
 static char zonelist_order_name[3][8] = {"Default", "Node", "Zone"};
 
-
 #ifdef CONFIG_NUMA
 /* The value user specified ....changed by config */
 static int user_zonelist_order = ZONELIST_ORDER_DEFAULT;
@@ -3157,7 +3165,6 @@ out:
 	return ret;
 }
 
-
 #define MAX_NODE_LOAD (nr_online_nodes)
 static int node_load[MAX_NUMNODES];
 
@@ -3221,7 +3228,6 @@ static int find_next_best_node(int node, nodemask_t *used_node_mask)
 	return best_node;
 }
 
-
 /*
  * Build zonelists ordered by node and zones within node.
  * This results in maximum locality--normal zone overflows into local
@@ -6179,8 +6185,6 @@ int alloc_contig_range(unsigned long start, unsigned long end,
 	ret = start_isolate_page_range(pfn_max_align_down(start),
 				       pfn_max_align_up(end), migratetype);
 	if (ret) {
-		printk(KERN_ERR "%s : start_isolate_page_range failed\n",
-					__func__);
 		goto done;
 	}
 
@@ -6188,11 +6192,8 @@ int alloc_contig_range(unsigned long start, unsigned long end,
 	zone->cma_alloc = 1;
 
 migrate:
-	printk(KERN_DEBUG "migrating range %lx %lx, retry (%d)\n",
-				start, end, retry);
 	ret = __alloc_contig_migrate_range(start, end);
 	if (ret) {
-		printk(KERN_ERR "__alloc_contig_migrate_range failed\n");
 		goto done;
 	}
 
@@ -6227,8 +6228,6 @@ migrate:
 
 	/* Make sure the range is really isolated. */
 	if (test_pages_isolated(outer_start, end)) {
-		printk(KERN_ERR "%s: test_pages_isolated(%lx, %lx) failed\n",
-					__func__, outer_start, end);
 		ret = -EBUSY;
 		goto done;
 	}
@@ -6243,8 +6242,6 @@ migrate:
 	outer_end = isolate_freepages_range(outer_start, end, true);
 	if (!outer_end) {
 		ret = -EBUSY;
-		printk(KERN_ERR "%s : isolate_freepages_range failed %lu\n",
-				 __func__, outer_end);
 		goto done;
 	}
 
@@ -6257,16 +6254,11 @@ migrate:
 done:
 	if ((ret == -EBUSY || ret == -EAGAIN) && retry++ < 5) {
 		unsigned long count, cf;
-		/* FIXME kmpark: temporaily drop the cma free pages */
 		count = zone_page_state(zone, NR_FREE_CMA_PAGES);
 		cf = zone_page_state(zone, NR_FREE_PAGES);
-		printk(KERN_ERR "%s[%d] free %lu, cma count %lu\n",
-					__func__, __LINE__, cf, count);
 		msleep(100);
 		count = zone_page_state(zone, NR_FREE_CMA_PAGES);
 		cf = zone_page_state(zone, NR_FREE_PAGES);
-		printk(KERN_ERR "%s[%d] free %lu, cma count %lu\n",
-					 __func__, __LINE__, cf, count);
 		goto migrate;
 	}
 
diff --git a/mm/page_io.c b/mm/page_io.c
index dc76b4d..91076b8 100644
--- a/mm/page_io.c
+++ b/mm/page_io.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds
  *
- *  Swap reorganised 29.12.95, 
+ *  Swap reorganised 29.12.95,
  *  Asynchronous swapping added 30.12.95. Stephen Tweedie
  *  Removed race in async swapping. 14.4.1996. Bruno Haible
  *  Add swap of shared pages through the page cache. 20.2.1998. Stephen Tweedie
diff --git a/mm/page_isolation.c b/mm/page_isolation.c
index 07de2e0..c9f0477 100644
--- a/mm/page_isolation.c
+++ b/mm/page_isolation.c
@@ -103,15 +103,10 @@ __test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn)
 		if (PageBuddy(page))
 			pfn += 1 << page_order(page);
 		else if (page_count(page) == 0 &&
-				page_private(page) == MIGRATE_ISOLATE) {
+				page_private(page) == MIGRATE_ISOLATE)
 			pfn += 1;
-			printk(KERN_INFO "%s:%d ", __func__, __LINE__);
-			dump_page(page);
-		} else {
-			printk(KERN_INFO "%s:%d ", __func__, __LINE__);
-			dump_page(page);
+		else
 			break;
-		}
 	}
 	if (pfn < end_pfn)
 		return 0;
diff --git a/mm/shmem.c b/mm/shmem.c
index e17c52e..f014e35 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -2194,7 +2185,6 @@ out:
 	return err;
 }
 
-
 static const struct xattr_handler *shmem_xattr_handlers[] = {
 #ifdef CONFIG_TMPFS_POSIX_ACL
 	&generic_acl_access_handler,
@@ -2425,6 +2415,7 @@ static int shmem_parse_options(char *options, struct shmem_sb_info *sbinfo,
 			       bool remount)
 {
 	char *this_char, *value, *rest;
+	struct mempolicy *mpol = NULL;
 
 	while (options != NULL) {
 		this_char = options;
@@ -2448,10 +2439,8 @@ static int shmem_parse_options(char *options, struct shmem_sb_info *sbinfo,
 		if ((value = strchr(this_char,'=')) != NULL) {
 			*value++ = 0;
 		} else {
-			printk(KERN_ERR
-			    "tmpfs: No value for mount option '%s'\n",
-			    this_char);
-			return 1;
+			printk(KERN_ERR "tmpfs: No value for mount option '%s'\n", this_char);
+			goto error;
 		}
 
 		if (!strcmp(this_char,"size")) {
@@ -2494,19 +2483,25 @@ static int shmem_parse_options(char *options, struct shmem_sb_info *sbinfo,
 			if (*rest)
 				goto bad_val;
 		} else if (!strcmp(this_char,"mpol")) {
-			if (mpol_parse_str(value, &sbinfo->mpol, 1))
+			mpol_put(mpol);
+			if (mpol_parse_str(value, &mpol, 1)) {
+				mpol = NULL;
 				goto bad_val;
+			}
 		} else {
-			printk(KERN_ERR "tmpfs: Bad mount option %s\n",
-			       this_char);
-			return 1;
+			printk(KERN_ERR "tmpfs: Bad mount option %s\n", this_char);
+			goto error;
 		}
 	}
+	sbinfo->mpol = mpol;
 	return 0;
 
 bad_val:
-	printk(KERN_ERR "tmpfs: Bad value '%s' for mount option '%s'\n",
-	       value, this_char);
+	printk(KERN_ERR "tmpfs: Bad value '%s' for mount option '%s'\n", value, this_char);
+
+error:
+	mpol_put(mpol);
+
 	return 1;
 
 }
@@ -2581,6 +2576,7 @@ static void shmem_put_super(struct super_block *sb)
 	struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
 
 	percpu_counter_destroy(&sbinfo->used_blocks);
+	mpol_put(sbinfo->mpol);
 	kfree(sbinfo);
 	sb->s_fs_info = NULL;
 }
@@ -2804,7 +2800,6 @@ static const struct vm_operations_struct shmem_vm_ops = {
 #endif
 };
 
-
 static struct dentry *shmem_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {

diff --git a/mm/slub.c b/mm/slub.c
index 10ab233..cdb0855 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -2470,7 +2480,6 @@ static int calculate_sizes(struct kmem_cache *s, int forced_order)
 	else
 		s->flags &= ~__OBJECT_POISON;
 
-
 	/*
 	 * If we are Redzoning then check if there is some space between the
 	 * end of the object and the free pointer. If not then add an
@@ -3049,7 +3058,7 @@ static void slab_mem_offline_callback(void *arg)
 	struct memory_notify *marg = arg;
 	int offline_node;
 
-	offline_node = marg->status_change_nid;
+	offline_node = marg->status_change_nid_normal;
 
 	/*
 	 * If the node still has available memory. we need kmem_cache_node
@@ -3082,7 +3091,7 @@ static int slab_mem_going_online_callback(void *arg)
 	struct kmem_cache_node *n;
 	struct kmem_cache *s;
 	struct memory_notify *marg = arg;
-	int nid = marg->status_change_nid;
+	int nid = marg->status_change_nid_normal;
 	int ret = 0;
 
 	/*
diff --git a/mm/swapfile.c b/mm/swapfile.c
index c8f4338..9ec0abf 100644
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@ -32,6 +32,8 @@
 #include <linux/memcontrol.h>
 #include <linux/poll.h>
 #include <linux/oom.h>
+#include <linux/frontswap.h>
+#include <linux/swapfile.h>
 
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
@@ -43,7 +45,7 @@ static bool swap_count_continued(struct swap_info_struct *, pgoff_t,
 static void free_swap_count_continuations(struct swap_info_struct *);
 static sector_t map_swap_entry(swp_entry_t, struct block_device**);
 
-static DEFINE_SPINLOCK(swap_lock);
+DEFINE_SPINLOCK(swap_lock);
 static unsigned int nr_swapfiles;
 long nr_swap_pages;
 long total_swap_pages;
@@ -54,9 +56,8 @@ static const char Unused_file[] = "Unused swap file entry ";
 static const char Bad_offset[] = "Bad swap offset entry ";
 static const char Unused_offset[] = "Unused swap offset entry ";
 
-static struct swap_list_t swap_list = {-1, -1};
-
-static struct swap_info_struct *swap_info[MAX_SWAPFILES];
+struct swap_list_t swap_list = {-1, -1};
+struct swap_info_struct *swap_info[MAX_SWAPFILES];
 
 static DEFINE_MUTEX(swapon_mutex);
 
@@ -289,7 +290,7 @@ checks:
 		scan_base = offset = si->lowest_bit;
 
 	/* reuse swap entry of cache-only swap if not busy. */
-	if (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {
+	if (si->swap_map[offset] == SWAP_HAS_CACHE) {
 		int swap_was_freed;
 		spin_unlock(&swap_lock);
 		swap_was_freed = __try_to_reclaim_swap(si, offset);
@@ -378,7 +379,7 @@ scan:
 			spin_lock(&swap_lock);
 			goto checks;
 		}
-		if (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {
+		if (si->swap_map[offset] == SWAP_HAS_CACHE) {
 			spin_lock(&swap_lock);
 			goto checks;
 		}
@@ -393,7 +394,7 @@ scan:
 			spin_lock(&swap_lock);
 			goto checks;
 		}
-		if (vm_swap_full() && si->swap_map[offset] == SWAP_HAS_CACHE) {
+		if (si->swap_map[offset] == SWAP_HAS_CACHE) {
 			spin_lock(&swap_lock);
 			goto checks;
 		}
@@ -707,8 +708,7 @@ int free_swap_and_cache(swp_entry_t entry)
 		 * Not mapped elsewhere, or swap space full? Free it!
 		 * Also recheck PageSwapCache now page is locked (above).
 		 */
-		if (PageSwapCache(page) && !PageWriteback(page) &&
-				(!page_mapped(page) || vm_swap_full())) {
+		if (PageSwapCache(page) && !PageWriteback(page)) {
 			delete_from_swap_cache(page);
 			SetPageDirty(page);
 		}
@@ -1020,7 +1020,7 @@ static int unuse_mm(struct mm_struct *mm,
  * Recycle to start on reaching the end, returning 0 when empty.
  */
 static unsigned int find_next_to_unuse(struct swap_info_struct *si,
-					unsigned int prev)
+									   unsigned int prev, bool frontswap)
 {
 	unsigned int max = si->max;
 	unsigned int i = prev;
@@ -1046,6 +1046,12 @@ static unsigned int find_next_to_unuse(struct swap_info_struct *si,
 			prev = 0;
 			i = 1;
 		}
+		if (frontswap) {
+			if (frontswap_test(si, i))
+				break;
+			else
+				continue;
+		}
 		count = si->swap_map[i];
 		if (count && swap_count(count) != SWAP_MAP_BAD)
 			break;
@@ -1058,7 +1064,8 @@ static unsigned int find_next_to_unuse(struct swap_info_struct *si,
  * and then search for the process using it.  All the necessary
  * page table adjustments can then be made atomically.
  */
-static int try_to_unuse(unsigned int type)
+int try_to_unuse(unsigned int type, bool frontswap,
+				 unsigned long pages_to_unuse)
 {
 	struct swap_info_struct *si = swap_info[type];
 	struct mm_struct *start_mm;
@@ -1091,7 +1098,7 @@ static int try_to_unuse(unsigned int type)
 	 * one pass through swap_map is enough, but not necessarily:
 	 * there are races when an instance of an entry might be missed.
 	 */
-	while ((i = find_next_to_unuse(si, i)) != 0) {
+	while ((i = find_next_to_unuse(si, i, frontswap)) != 0) {
 		if (signal_pending(current)) {
 			retval = -EINTR;
 			break;
@@ -1104,8 +1111,7 @@ static int try_to_unuse(unsigned int type)
 		 */
 		swap_map = &si->swap_map[i];
 		entry = swp_entry(type, i);
-		page = read_swap_cache_async(entry,
-					GFP_HIGHUSER_MOVABLE, NULL, 0);
+		page = read_swap_cache_async(entry, GFP_HIGHUSER_MOVABLE, NULL, 0);
 		if (!page) {
 			/*
 			 * Either swap_duplicate() failed because entry
@@ -1166,36 +1172,36 @@ static int try_to_unuse(unsigned int type)
 			atomic_inc(&prev_mm->mm_users);
 			spin_lock(&mmlist_lock);
 			while (swap_count(*swap_map) && !retval &&
-					(p = p->next) != &start_mm->mmlist) {
+				(p = p->next) != &start_mm->mmlist) {
 				mm = list_entry(p, struct mm_struct, mmlist);
-				if (!atomic_inc_not_zero(&mm->mm_users))
-					continue;
-				spin_unlock(&mmlist_lock);
-				mmput(prev_mm);
-				prev_mm = mm;
+			if (!atomic_inc_not_zero(&mm->mm_users))
+				continue;
+			spin_unlock(&mmlist_lock);
+			mmput(prev_mm);
+			prev_mm = mm;
 
-				cond_resched();
+			cond_resched();
 
-				swcount = *swap_map;
-				if (!swap_count(swcount)) /* any usage ? */
-					;
-				else if (mm == &init_mm)
-					set_start_mm = 1;
-				else
-					retval = unuse_mm(mm, entry, page);
-
-				if (set_start_mm && *swap_map < swcount) {
-					mmput(new_start_mm);
-					atomic_inc(&mm->mm_users);
-					new_start_mm = mm;
-					set_start_mm = 0;
-				}
-				spin_lock(&mmlist_lock);
+			swcount = *swap_map;
+			if (!swap_count(swcount)) /* any usage ? */
+				;
+			else if (mm == &init_mm)
+				set_start_mm = 1;
+			else
+				retval = unuse_mm(mm, entry, page);
+
+			if (set_start_mm && *swap_map < swcount) {
+				mmput(new_start_mm);
+				atomic_inc(&mm->mm_users);
+				new_start_mm = mm;
+				set_start_mm = 0;
 			}
-			spin_unlock(&mmlist_lock);
-			mmput(prev_mm);
-			mmput(start_mm);
-			start_mm = new_start_mm;
+			spin_lock(&mmlist_lock);
+				}
+				spin_unlock(&mmlist_lock);
+				mmput(prev_mm);
+				mmput(start_mm);
+				start_mm = new_start_mm;
 		}
 		if (retval) {
 			unlock_page(page);
@@ -1223,41 +1229,45 @@ static int try_to_unuse(unsigned int type)
 		 * is unnecessarily slow, but we can fix that later on.
 		 */
 		if (swap_count(*swap_map) &&
-		     PageDirty(page) && PageSwapCache(page)) {
+			PageDirty(page) && PageSwapCache(page)) {
 			struct writeback_control wbc = {
 				.sync_mode = WB_SYNC_NONE,
 			};
 
-			swap_writepage(page, &wbc);
-			lock_page(page);
-			wait_on_page_writeback(page);
-		}
+		swap_writepage(page, &wbc);
+		lock_page(page);
+		wait_on_page_writeback(page);
+			}
 
-		/*
-		 * It is conceivable that a racing task removed this page from
-		 * swap cache just before we acquired the page lock at the top,
-		 * or while we dropped it in unuse_mm().  The page might even
-		 * be back in swap cache on another swap area: that we must not
-		 * delete, since it may not have been written out to swap yet.
-		 */
-		if (PageSwapCache(page) &&
-		    likely(page_private(page) == entry.val))
-			delete_from_swap_cache(page);
+			/*
+			 * It is conceivable that a racing task removed this page from
+			 * swap cache just before we acquired the page lock at the top,
+			 * or while we dropped it in unuse_mm().  The page might even
+			 * be back in swap cache on another swap area: that we must not
+			 * delete, since it may not have been written out to swap yet.
+			 */
+			if (PageSwapCache(page) &&
+				likely(page_private(page) == entry.val))
+				delete_from_swap_cache(page);
 
-		/*
-		 * So we could skip searching mms once swap count went
-		 * to 1, we did not mark any present ptes as dirty: must
-		 * mark page dirty so shrink_page_list will preserve it.
-		 */
-		SetPageDirty(page);
-		unlock_page(page);
-		page_cache_release(page);
+			/*
+			 * So we could skip searching mms once swap count went
+			 * to 1, we did not mark any present ptes as dirty: must
+			 * mark page dirty so shrink_page_list will preserve it.
+			 */
+			SetPageDirty(page);
+			unlock_page(page);
+			page_cache_release(page);
 
-		/*
-		 * Make sure that we aren't completely killing
-		 * interactive performance.
-		 */
-		cond_resched();
+			/*
+			 * Make sure that we aren't completely killing
+			 * interactive performance.
+			 */
+			cond_resched();
+			if (frontswap && pages_to_unuse > 0) {
+				if (!--pages_to_unuse)
+					break;
+			}
 	}
 
 	mmput(start_mm);
@@ -1511,7 +1521,6 @@ reprobe:
 out:
 	return ret;
 bad_bmap:
-	printk(KERN_ERR "swapon: swapfile has holes\n");
 	ret = -EINVAL;
 	goto out;
 }
@@ -1614,7 +1623,7 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)
 	spin_unlock(&swap_lock);
 
 	oom_score_adj = test_set_oom_score_adj(OOM_SCORE_ADJ_MAX);
-	err = try_to_unuse(type);
+	err = try_to_unuse(type, false, 0); /* force all pages to be unused */
 	test_set_oom_score_adj(oom_score_adj);
 
 	if (err) {
@@ -2012,6 +2021,151 @@ static int setup_swap_map_and_extents(struct swap_info_struct *p,
 	return nr_extents;
 }
 
+#ifdef CONFIG_ZRAM_FOR_ANDROID
+int swapon(char *name, int swap_flags)
+{
+	struct swap_info_struct *p;
+
+	struct file *swap_file = NULL;
+	struct address_space *mapping;
+	int i;
+	int prio;
+	int error;
+	union swap_header *swap_header;
+	int nr_extents;
+	sector_t span;
+	unsigned long maxpages;
+	unsigned char *swap_map = NULL;
+	struct page *page = NULL;
+	struct inode *inode = NULL;
+
+	p = alloc_swap_info();
+	if (IS_ERR(p))
+		return PTR_ERR(p);
+
+	swap_file = filp_open(name, O_RDWR | O_LARGEFILE, 0);
+	if (IS_ERR(swap_file)) {
+		error = PTR_ERR(swap_file);
+		swap_file = NULL;
+		printk("zfqin, filp_open failed\n");
+		goto bad_swap;
+	}
+
+	p->swap_file = swap_file;
+	mapping = swap_file->f_mapping;
+
+	for (i = 0; i < nr_swapfiles; i++) {
+		struct swap_info_struct *q = swap_info[i];
+
+		if (q == p || !q->swap_file)
+			continue;
+		if (mapping == q->swap_file->f_mapping) {
+			error = -EBUSY;
+			goto bad_swap;
+		}
+	}
+
+	inode = mapping->host;
+	/* If S_ISREG(inode->i_mode) will do mutex_lock(&inode->i_mutex); */
+	error = claim_swapfile(p, inode);
+	if (unlikely(error))
+		goto bad_swap;
+
+	/*
+	 * Read the swap header.
+	 */
+	if (!mapping->a_ops->readpage) {
+		error = -EINVAL;
+		goto bad_swap;
+	}
+	page = read_mapping_page(mapping, 0, swap_file);
+	if (IS_ERR(page)) {
+		error = PTR_ERR(page);
+		goto bad_swap;
+	}
+	swap_header = kmap(page);
+
+	maxpages = read_swap_header(p, swap_header, inode);
+	if (unlikely(!maxpages)) {
+		error = -EINVAL;
+		goto bad_swap;
+	}
+
+	/* OK, set up the swap map and apply the bad block list */
+	swap_map = vzalloc(maxpages);
+	if (!swap_map) {
+		error = -ENOMEM;
+		goto bad_swap;
+	}
+
+	error = swap_cgroup_swapon(p->type, maxpages);
+	if (error)
+		goto bad_swap;
+
+	nr_extents = setup_swap_map_and_extents(p, swap_header, swap_map,
+						maxpages, &span);
+	if (unlikely(nr_extents < 0)) {
+		error = nr_extents;
+		goto bad_swap;
+	}
+
+	if (p->bdev) {
+		if (blk_queue_nonrot(bdev_get_queue(p->bdev))) {
+			p->flags |= SWP_SOLIDSTATE;
+			p->cluster_next = 1 + (random32() % p->highest_bit);
+		}
+		if (discard_swap(p) == 0 && (swap_flags & SWAP_FLAG_DISCARD))
+			p->flags |= SWP_DISCARDABLE;
+	}
+
+	mutex_lock(&swapon_mutex);
+	prio = -1;
+	if (swap_flags & SWAP_FLAG_PREFER)
+		prio =
+		    (swap_flags & SWAP_FLAG_PRIO_MASK) >> SWAP_FLAG_PRIO_SHIFT;
+	enable_swap_info(p, prio, swap_map);
+
+	mutex_unlock(&swapon_mutex);
+	atomic_inc(&proc_poll_event);
+	wake_up_interruptible(&proc_poll_wait);
+
+	if (S_ISREG(inode->i_mode))
+		inode->i_flags |= S_SWAPFILE;
+	error = 0;
+	goto out;
+ bad_swap:
+	if (inode && S_ISBLK(inode->i_mode) && p->bdev) {
+		set_blocksize(p->bdev, p->old_block_size);
+		blkdev_put(p->bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);
+	}
+	destroy_swap_extents(p);
+	swap_cgroup_swapoff(p->type);
+	spin_lock(&swap_lock);
+	p->swap_file = NULL;
+	p->flags = 0;
+	spin_unlock(&swap_lock);
+	vfree(swap_map);
+	if (swap_file) {
+		if (inode && S_ISREG(inode->i_mode)) {
+			mutex_unlock(&inode->i_mutex);
+			inode = NULL;
+		}
+		filp_close(swap_file, NULL);
+	}
+ out:
+	if (page && !IS_ERR(page)) {
+		kunmap(page);
+		page_cache_release(page);
+	}
+
+	if (inode && S_ISREG(inode->i_mode))
+		mutex_unlock(&inode->i_mutex);
+	return error;
+}
+
+EXPORT_SYMBOL(swapon);
+#endif /* CONFIG_ZRAM_FOR_ANDROID */
+
 SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)
 {
 	struct swap_info_struct *p;
@@ -2123,13 +2277,6 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)
 		  (swap_flags & SWAP_FLAG_PRIO_MASK) >> SWAP_FLAG_PRIO_SHIFT;
 	enable_swap_info(p, prio, swap_map);
 
-	printk(KERN_INFO "Adding %uk swap on %s.  "
-			"Priority:%d extents:%d across:%lluk %s%s\n",
-		p->pages<<(PAGE_SHIFT-10), name, p->prio,
-		nr_extents, (unsigned long long)span<<(PAGE_SHIFT-10),
-		(p->flags & SWP_SOLIDSTATE) ? "SS" : "",
-		(p->flags & SWP_DISCARDABLE) ? "D" : "");
-
 	mutex_unlock(&swapon_mutex);
 	atomic_inc(&proc_poll_event);
 	wake_up_interruptible(&proc_poll_wait);
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 7a6886a..4159bfe 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -990,7 +983,7 @@ cull_mlocked:
 
 activate_locked:
 		/* Not a candidate for swapping, so reclaim swap space. */
-		if (PageSwapCache(page) && vm_swap_full())
+		if (PageSwapCache(page))
 			try_to_free_swap(page);
 		VM_BUG_ON(PageActive(page));
 		SetPageActive(page);
@@ -1061,9 +1054,6 @@ int __isolate_lru_page(struct page *page, isolate_mode_t mode, int file)
 	if (PageUnevictable(page))
 #ifndef CONFIG_CMA
 		return ret;
-#else
-		printk(KERN_ERR "%s[%d] Unevictable page %p\n",
-					__func__, __LINE__, page);
 #endif
 	ret = -EBUSY;
 
@@ -2164,17 +2143,18 @@ static inline bool compaction_ready(struct zone *zone, struct scan_control *sc)
  *
  * If a zone is deemed to be full of pinned pages then just give it a light
  * scan then give up on it.
+ *
+ * This function returns true if a zone is being reclaimed for a costly
+ * high-order allocation and compaction is ready to begin. This indicates to
+ * the caller that it should consider retrying the allocation instead of
+ * further reclaim.
  */
 static bool shrink_zones(int priority, struct zonelist *zonelist,
 					struct scan_control *sc)
@@ -2523,6 +2498,10 @@ static bool sleeping_prematurely(pg_data_t *pgdat, int order, long remaining,
 	unsigned long balanced = 0;
 	bool all_zones_ok = true;
 
+	/* If kswapd has been running too long, just sleep */
+	if (need_resched())
+		return false;
+
 	/* If a direct reclaimer woke kswapd within HZ/10, it's premature */
 	if (remaining)
 		return true;

diff --git a/net/bluetooth/Kconfig b/net/bluetooth/Kconfig
index bfb3dc0..5f54e5b 100644
--- a/net/bluetooth/Kconfig
+++ b/net/bluetooth/Kconfig
@@ -2,9 +2,11 @@
 # Bluetooth subsystem configuration
 #
 
+if CONFIG_BT_MGMT = n
+
 menuconfig BT
 	tristate "Bluetooth subsystem support"
-	depends on NET && !S390
+	depends on NET
 	depends on RFKILL || !RFKILL
 	select CRYPTO
 	help
@@ -19,7 +21,7 @@ menuconfig BT
 	     HCI Device drivers (Interface to the hardware)
 	     SCO Module (SCO audio links)
 	     L2CAP Module (Logical Link Control and Adaptation Protocol)
-	     RFCOMM Module (RFCOMM Protocol)  
+	     RFCOMM Module (RFCOMM Protocol)
 	     BNEP Module (Bluetooth Network Encapsulation Protocol)
 	     CMTP Module (CAPI Message Transport Protocol)
 	     HIDP Module (Human Interface Device Protocol)
@@ -68,3 +70,4 @@ source "net/bluetooth/hidp/Kconfig"
 
 source "drivers/bluetooth/Kconfig"
 
+endif
diff --git a/net/bluetooth_mgmt/Kconfig b/net/bluetooth_mgmt/Kconfig
old mode 100755
new mode 100644
index 002b302..117aea1
--- a/net/bluetooth_mgmt/Kconfig
+++ b/net/bluetooth_mgmt/Kconfig
@@ -3,8 +3,8 @@
 #
 
 menuconfig BT
-	tristate "Bluetooth subsystem support"
-	depends on NET && !S390
+	tristate "Bluetooth MGMT subsystem support"
+	depends on NET
 	depends on RFKILL || !RFKILL
 	select CRYPTO
 	help
@@ -67,4 +67,3 @@ source "net/bluetooth_mgmt/cmtp/Kconfig"
 source "net/bluetooth_mgmt/hidp/Kconfig"
 
 source "drivers/bluetooth/Kconfig"
-
diff --git a/net/bluetooth_mgmt/mgmt.c b/net/bluetooth_mgmt/mgmt.c
old mode 100755
new mode 100644
index 8027e52..741bdae
--- a/net/bluetooth_mgmt/mgmt.c
+++ b/net/bluetooth_mgmt/mgmt.c
@@ -128,83 +128,13 @@ struct pending_cmd {
 	void *user_data;
 };
 
-/* HCI to MGMT error code conversion table */
-static u8 mgmt_status_table[] = {
-	MGMT_STATUS_SUCCESS,
-	MGMT_STATUS_UNKNOWN_COMMAND,	/* Unknown Command */
-	MGMT_STATUS_NOT_CONNECTED,	/* No Connection */
-	MGMT_STATUS_FAILED,		/* Hardware Failure */
-	MGMT_STATUS_CONNECT_FAILED,	/* Page Timeout */
-	MGMT_STATUS_AUTH_FAILED,	/* Authentication Failed */
-	MGMT_STATUS_NOT_PAIRED,		/* PIN or Key Missing */
-	MGMT_STATUS_NO_RESOURCES,	/* Memory Full */
-	MGMT_STATUS_TIMEOUT,		/* Connection Timeout */
-	MGMT_STATUS_NO_RESOURCES,	/* Max Number of Connections */
-	MGMT_STATUS_NO_RESOURCES,	/* Max Number of SCO Connections */
-	MGMT_STATUS_ALREADY_CONNECTED,	/* ACL Connection Exists */
-	MGMT_STATUS_BUSY,		/* Command Disallowed */
-	MGMT_STATUS_NO_RESOURCES,	/* Rejected Limited Resources */
-	MGMT_STATUS_REJECTED,		/* Rejected Security */
-	MGMT_STATUS_REJECTED,		/* Rejected Personal */
-	MGMT_STATUS_TIMEOUT,		/* Host Timeout */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported Feature */
-	MGMT_STATUS_INVALID_PARAMS,	/* Invalid Parameters */
-	MGMT_STATUS_DISCONNECTED,	/* OE User Ended Connection */
-	MGMT_STATUS_NO_RESOURCES,	/* OE Low Resources */
-	MGMT_STATUS_DISCONNECTED,	/* OE Power Off */
-	MGMT_STATUS_DISCONNECTED,	/* Connection Terminated */
-	MGMT_STATUS_BUSY,		/* Repeated Attempts */
-	MGMT_STATUS_REJECTED,		/* Pairing Not Allowed */
-	MGMT_STATUS_FAILED,		/* Unknown LMP PDU */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported Remote Feature */
-	MGMT_STATUS_REJECTED,		/* SCO Offset Rejected */
-	MGMT_STATUS_REJECTED,		/* SCO Interval Rejected */
-	MGMT_STATUS_REJECTED,		/* Air Mode Rejected */
-	MGMT_STATUS_INVALID_PARAMS,	/* Invalid LMP Parameters */
-	MGMT_STATUS_FAILED,		/* Unspecified Error */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported LMP Parameter Value */
-	MGMT_STATUS_FAILED,		/* Role Change Not Allowed */
-	MGMT_STATUS_TIMEOUT,		/* LMP Response Timeout */
-	MGMT_STATUS_FAILED,		/* LMP Error Transaction Collision */
-	MGMT_STATUS_FAILED,		/* LMP PDU Not Allowed */
-	MGMT_STATUS_REJECTED,		/* Encryption Mode Not Accepted */
-	MGMT_STATUS_FAILED,		/* Unit Link Key Used */
-	MGMT_STATUS_NOT_SUPPORTED,	/* QoS Not Supported */
-	MGMT_STATUS_TIMEOUT,		/* Instant Passed */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Pairing Not Supported */
-	MGMT_STATUS_FAILED,		/* Transaction Collision */
-	MGMT_STATUS_INVALID_PARAMS,	/* Unacceptable Parameter */
-	MGMT_STATUS_REJECTED,		/* QoS Rejected */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Classification Not Supported */
-	MGMT_STATUS_REJECTED,		/* Insufficient Security */
-	MGMT_STATUS_INVALID_PARAMS,	/* Parameter Out Of Range */
-	MGMT_STATUS_BUSY,		/* Role Switch Pending */
-	MGMT_STATUS_FAILED,		/* Slot Violation */
-	MGMT_STATUS_FAILED,		/* Role Switch Failed */
-	MGMT_STATUS_INVALID_PARAMS,	/* EIR Too Large */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Simple Pairing Not Supported */
-	MGMT_STATUS_BUSY,		/* Host Busy Pairing */
-	MGMT_STATUS_REJECTED,		/* Rejected, No Suitable Channel */
-	MGMT_STATUS_BUSY,		/* Controller Busy */
-	MGMT_STATUS_INVALID_PARAMS,	/* Unsuitable Connection Interval */
-	MGMT_STATUS_TIMEOUT,		/* Directed Advertising Timeout */
-	MGMT_STATUS_AUTH_FAILED,	/* Terminated Due to MIC Failure */
-	MGMT_STATUS_CONNECT_FAILED,	/* Connection Establishment Failed */
-	MGMT_STATUS_CONNECT_FAILED,	/* MAC Connection Failed */
-};
-
 static u8 mgmt_status(u8 hci_status)
 {
-	/* bluetoothd is still checking hci status. so no need to check
-	* mgmt status but this should be checked after bluetoothd update */
-	return hci_status;
-
 	/*
-	* if (hci_status < ARRAY_SIZE(mgmt_status_table))
-	*		return mgmt_status_table[hci_status];
-	*
-	* return MGMT_STATUS_FAILED;
-	*/
+	 * bluetoothd is still checking hci status. so no need to check
+	 * mgmt status but this should be checked after bluetoothd update
+	 */
+	return hci_status;
 }
 
 static int cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)
@@ -214,8 +144,6 @@ static int cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)
 	struct mgmt_ev_cmd_status *ev;
 	int err;
 
-	BT_DBG("sock %p, index %u, cmd %u, status %u", sk, index, cmd, status);
-
 	skb = alloc_skb(sizeof(*hdr) + sizeof(*ev), GFP_ATOMIC);
 	if (!skb)
 		return -ENOMEM;
@@ -245,8 +173,6 @@ static int cmd_complete(struct sock *sk, u16 index, u16 cmd, void *rp,
 	struct mgmt_ev_cmd_complete *ev;
 	int err;
 
-	BT_DBG("sock %p", sk);
-
 	skb = alloc_skb(sizeof(*hdr) + sizeof(*ev) + rp_len, GFP_ATOMIC);
 	if (!skb)
 		return -ENOMEM;
@@ -274,8 +200,6 @@ static int read_version(struct sock *sk)
 {
 	struct mgmt_rp_read_version rp;
 
-	BT_DBG("sock %p", sk);
-
 	rp.version = MGMT_VERSION;
 	put_unaligned_le16(MGMT_REVISION, &rp.revision);
 
@@ -292,8 +216,6 @@ static int read_commands(struct sock *sk)
 	size_t rp_size;
 	int i, err;
 
-	BT_DBG("sock %p", sk);
-
 	rp_size = sizeof(*rp) + ((num_commands + num_events) * sizeof(u16));
 
 	rp = kmalloc(rp_size, GFP_KERNEL);
@@ -324,8 +246,6 @@ static int read_index_list(struct sock *sk)
 	u16 count;
 	int i, err;
 
-	BT_DBG("sock %p", sk);
-
 	read_lock(&hci_dev_list_lock);
 
 	count = 0;
@@ -352,7 +272,6 @@ static int read_index_list(struct sock *sk)
 
 		put_unaligned_le16(d->id, &rp->index[i++]);
 		put_unaligned_le16((u16)i, &rp->num_controllers);
-		BT_DBG("Added hci%u", d->id);
 	}
 
 	read_unlock(&hci_dev_list_lock);
@@ -393,8 +312,6 @@ static u32 get_current_settings(struct hci_dev *hdev)
 {
 	u32 settings = 0;
 
-	BT_DBG("hdev->flags %lx", hdev->flags);
-
 	if (test_bit(HCI_UP, &hdev->flags))
 		settings |= MGMT_SETTING_POWERED;
 	else
@@ -573,8 +490,6 @@ static int update_class(struct hci_dev *hdev)
 {
 	u8 cod[3];
 
-	BT_DBG("%s", hdev->name);
-
 	if (test_bit(HCI_SERVICE_CACHE, &hdev->dev_flags))
 		return 0;
 
@@ -618,8 +533,6 @@ static int read_controller_info(struct sock *sk, u16 index)
 	struct mgmt_rp_read_info rp;
 	struct hci_dev *hdev;
 
-	BT_DBG("sock %p hci%u", sk, index);
-
 	hdev = hci_dev_get(index);
 	if (!hdev)
 		return cmd_status(sk, index, MGMT_OP_READ_INFO,
@@ -741,8 +654,6 @@ static int set_powered(struct sock *sk, u16 index, void *data, u16 len)
 	struct pending_cmd *cmd;
 	int err, up;
 
-	BT_DBG("request for hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_SET_POWERED,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -793,8 +704,6 @@ static int set_discoverable(struct sock *sk, u16 index, void *data, u16 len)
 	u8 scan;
 	int err;
 
-	BT_DBG("request for hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -861,8 +770,6 @@ static int set_connectable(struct sock *sk, u16 index, void *data, u16 len)
 	u8 scan;
 	int err;
 
-	BT_DBG("request for hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -940,8 +847,6 @@ static int mgmt_event(u16 event, struct hci_dev *hdev, void *data,
 	hci_send_to_sock(NULL, skb, skip_sk);
 	kfree_skb(skb);
 
-	BT_DBG("-----> evt: %x", event);
-
 	return 0;
 }
 
@@ -960,8 +865,6 @@ static int set_pairable(struct sock *sk, u16 index, void *data, u16 len)
 	__le32 ev;
 	int err;
 
-	BT_DBG("request for hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -999,8 +902,6 @@ static int add_uuid(struct sock *sk, u16 index, void *data, u16 len)
 	struct bt_uuid *uuid;
 	int err;
 
-	BT_DBG("request for hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_ADD_UUID,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1048,8 +949,6 @@ static int remove_uuid(struct sock *sk, u16 index, void *data, u16 len)
 	u8 bt_uuid_any[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	int err, found;
 
-	BT_DBG("request for hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1107,8 +1006,6 @@ static int set_dev_class(struct sock *sk, u16 index, void *data, u16 len)
 	struct mgmt_cp_set_dev_class *cp = data;
 	int err;
 
-	BT_DBG("request for hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1168,9 +1065,6 @@ static int load_link_keys(struct sock *sk, u16 index, void *data, u16 len)
 		return cmd_status(sk, index, MGMT_OP_LOAD_LINK_KEYS,
 						MGMT_STATUS_INVALID_PARAMS);
 
-	BT_DBG("hci%u debug_keys %u key_count %u", index, cp->debug_keys,
-								key_count);
-
 	hci_dev_lock_bh(hdev);
 
 	hci_link_keys_clear(hdev);
@@ -1297,8 +1191,6 @@ static int disconnect(struct sock *sk, u16 index, void *data, u16 len)
 	struct hci_conn *conn;
 	int err;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_DISCONNECT,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1382,8 +1274,6 @@ static int get_connections(struct sock *sk, u16 index)
 	int err;
 	u16 i;
 
-	BT_DBG("");
-
 	hdev = hci_dev_get(index);
 	if (!hdev)
 		return cmd_status(sk, index, MGMT_OP_GET_CONNECTIONS,
@@ -1460,13 +1350,10 @@ static int pin_code_reply(struct sock *sk, u16 index, void *data, u16 len)
 	struct hci_dev *hdev;
 	struct hci_conn *conn;
 	struct mgmt_cp_pin_code_reply *cp = data;
-	struct mgmt_cp_pin_code_neg_reply ncp;
 	struct hci_cp_pin_code_reply reply;
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1518,8 +1405,6 @@ static int pin_code_neg_reply(struct sock *sk, u16 index, void *data, u16 len)
 	struct mgmt_cp_pin_code_neg_reply *cp = data;
 	int err;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1551,8 +1436,6 @@ static int set_io_capability(struct sock *sk, u16 index, void *data, u16 len)
 	struct hci_dev *hdev;
 	struct mgmt_cp_set_io_capability *cp = data;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1566,9 +1449,6 @@ static int set_io_capability(struct sock *sk, u16 index, void *data, u16 len)
 
 	hdev->io_capability = cp->io_capability;
 
-	BT_DBG("%s IO capability set to 0x%02x", hdev->name,
-							hdev->io_capability);
-
 	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
@@ -1618,12 +1498,8 @@ static void pairing_complete_cb(struct hci_conn *conn, u8 status)
 {
 	struct pending_cmd *cmd;
 
-	BT_DBG("status %u", status);
-
 	cmd = find_pairing(conn);
-	if (!cmd)
-		BT_DBG("Unable to find a pending command");
-	else
+	if (cmd)
 		pairing_complete(cmd, status);
 }
 
@@ -1631,15 +1507,11 @@ static void le_connect_complete_cb(struct hci_conn *conn, u8 status)
 {
 	struct pending_cmd *cmd;
 
-	BT_DBG("status %u", status);
-
 	if (!status)
 		return;
 
 	cmd = find_pairing(conn);
-	if (!cmd)
-		BT_DBG("Unable to find a pending command");
-	else
+	if (cmd)
 		pairing_complete(cmd, mgmt_status(status));
 }
 
@@ -1653,8 +1525,6 @@ static int pair_device(struct sock *sk, u16 index, void *data, u16 len)
 	struct hci_conn *conn;
 	int err;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1735,8 +1605,6 @@ static int cancel_pair_device(struct sock *sk, u16 index,
 	struct hci_conn *conn;
 	int err;
 
-	BT_DBG("");
-
 	if (len != sizeof(*addr))
 		return cmd_status(sk, index, MGMT_OP_CANCEL_PAIR_DEVICE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1850,8 +1718,6 @@ static int user_confirm_reply(struct sock *sk, u16 index, void *data, u16 len)
 {
 	struct mgmt_cp_user_confirm_reply *cp = data;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_USER_CONFIRM_REPLY,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1866,8 +1732,6 @@ static int user_confirm_neg_reply(struct sock *sk, u16 index, void *data,
 {
 	struct mgmt_cp_user_confirm_neg_reply *cp = data;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_USER_CONFIRM_NEG_REPLY,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1881,8 +1745,6 @@ static int user_passkey_reply(struct sock *sk, u16 index, void *data, u16 len)
 {
 	struct mgmt_cp_user_passkey_reply *cp = data;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_USER_PASSKEY_REPLY,
 									EINVAL);
@@ -1898,8 +1760,6 @@ static int user_passkey_neg_reply(struct sock *sk, u16 index, void *data,
 {
 	struct mgmt_cp_user_passkey_neg_reply *cp = data;
 
-	BT_DBG("");
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_USER_PASSKEY_NEG_REPLY,
 									EINVAL);
@@ -1918,8 +1778,6 @@ static int set_local_name(struct sock *sk, u16 index, void *data,
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("");
-
 	if (len != sizeof(*mgmt_cp))
 		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -1956,8 +1814,6 @@ static int read_local_oob_data(struct sock *sk, u16 index)
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("hci%u", index);
-
 	hdev = hci_dev_get(index);
 	if (!hdev)
 		return cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
@@ -2007,8 +1863,6 @@ static int add_remote_oob_data(struct sock *sk, u16 index, void *data,
 	struct mgmt_cp_add_remote_oob_data *cp = data;
 	int err;
 
-	BT_DBG("hci%u ", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -2042,8 +1896,6 @@ static int remove_remote_oob_data(struct sock *sk, u16 index,
 	struct mgmt_cp_remove_remote_oob_data *cp = data;
 	int err;
 
-	BT_DBG("hci%u ", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -2078,8 +1930,6 @@ static int start_discovery(struct sock *sk, u16 index,
 	struct hci_dev *hdev;
 	int err;
 
-	BT_DBG("hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -2138,8 +1988,6 @@ static int stop_discovery(struct sock *sk, u16 index)
 	struct inquiry_entry *e;
 	int err;
 
-	BT_DBG("hci%u", index);
-
 	hdev = hci_dev_get(index);
 	if (!hdev)
 		return cmd_status(sk, index, MGMT_OP_STOP_DISCOVERY,
@@ -2208,8 +2056,6 @@ static int test_end_le(struct sock *sk, u16 index)
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("test_end_le : hci%u", index);
-
 	hdev = hci_dev_get(index);
 	if (!hdev) {
 		BT_ERR("hci_dev_get : Failed !!!");
@@ -2240,7 +2086,6 @@ unlock:
 	return err;
 }
 
-
 static int confirm_name(struct sock *sk, u16 index, void *data, u16 len)
 {
 	struct mgmt_cp_confirm_name *cp = data;
@@ -2248,8 +2093,6 @@ static int confirm_name(struct sock *sk, u16 index, void *data, u16 len)
 	struct hci_dev *hdev;
 	int err;
 
-	BT_DBG("hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_CONFIRM_NAME,
 				MGMT_STATUS_INVALID_PARAMS);
@@ -2297,8 +2140,6 @@ static int block_device(struct sock *sk, u16 index, void *data, u16 len)
 	struct mgmt_cp_block_device *cp = data;
 	int err;
 
-	BT_DBG("hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_BLOCK_DEVICE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -2331,8 +2172,6 @@ static int unblock_device(struct sock *sk, u16 index, void *data, u16 len)
 	struct mgmt_cp_unblock_device *cp = data;
 	int err;
 
-	BT_DBG("hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_UNBLOCK_DEVICE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -2368,8 +2207,6 @@ static int set_fast_connectable(struct sock *sk, u16 index,
 	u8 type;
 	int err;
 
-	BT_DBG("hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_SET_FAST_CONNECTABLE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -2443,8 +2280,6 @@ static int load_long_term_keys(struct sock *sk, u16 index,
 		return cmd_status(sk, index, MGMT_OP_LOAD_LONG_TERM_KEYS,
 								ENODEV);
 
-	BT_DBG("hci%u key_count %u", index, key_count);
-
 	hci_dev_lock_bh(hdev);
 
 	hci_smp_ltks_clear(hdev);
@@ -2479,8 +2314,6 @@ static int encrypt_link(struct sock *sk, u16 index, unsigned char *data,
 	struct hci_conn *conn;
 	int err = 0;
 
-	BT_DBG("");
-
 	cp = (void *) data;
 
 	if (len != sizeof(*cp))
@@ -2536,8 +2369,6 @@ static int set_le(struct sock *sk, u16 index, void *data, u16 len)
 	int err;
 	u8 val;
 
-	BT_DBG("request for hci%u", index);
-
 	if (len != sizeof(*cp))
 		return cmd_status(sk, index, MGMT_OP_SET_LE,
 						MGMT_STATUS_INVALID_PARAMS);
@@ -2562,7 +2393,6 @@ static int set_le(struct sock *sk, u16 index, void *data, u16 len)
 
 		if (val != test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
 			change_bit(HCI_LE_ENABLED, &hdev->dev_flags);
-			BT_DBG("HCI_LE_ENABLED changed %d", changed);
 			changed = true;
 		}
 
@@ -2591,7 +2421,6 @@ static int set_le(struct sock *sk, u16 index, void *data, u16 len)
 
 	if (val) {
 		enable_le = true;
-		BT_DBG("enable_le %d", enable_le);
 		hci_cp.le = val;
 		hci_cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
 	}
@@ -2619,10 +2448,7 @@ static int read_rssi(struct sock *sk, u16 index, unsigned char *data, u16 len)
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("hci%u", index);
-
 	if (len != sizeof(*cp)) {
-		BT_DBG("len %d, sizeof(*cp) %d", len, sizeof(*cp));
 		return cmd_status(sk, index,
 				MGMT_OP_READ_RSSI, MGMT_STATUS_INVALID_PARAMS);
 	}
@@ -2681,8 +2507,6 @@ int mgmt_read_rssi_failed(struct hci_dev *hdev)
 	struct pending_cmd *cmd;
 	int err = 0;
 
-	BT_DBG("");
-
 	cmd = mgmt_pending_find(MGMT_OP_READ_RSSI, hdev);
 	if (!cmd)
 		return -ENOENT;
@@ -2701,8 +2525,6 @@ int mgmt_read_rssi_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 	struct mgmt_rp_read_rssi rp;
 	int err;
 
-	BT_DBG("");
-
 	cmd = mgmt_pending_find(MGMT_OP_READ_RSSI, hdev);
 	if (!cmd)
 		return -ENOENT;
@@ -2734,8 +2556,6 @@ static int le_test_end_complete(struct hci_dev *hdev, u8 status, u16 num_pkts)
 	rp.status = status;
 	rp.num_pkts = num_pkts;
 
-	BT_DBG("le_test_end_complete : %s status %d, num_pkts 0x%x(%d)"
-		, hdev->name, rp.status, rp.num_pkts, rp.num_pkts);
 	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_LE_TEST_END
 		, &rp, sizeof(rp));
 	mgmt_pending_remove(cmd);
@@ -2750,8 +2570,6 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 	u16 opcode, index, len;
 	int err;
 
-	BT_DBG("got %zu bytes", msglen);
-
 	if (msglen < sizeof(*hdr))
 		return -EINVAL;
 
@@ -2776,8 +2594,6 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 
 	cp = buf + sizeof(*hdr);
 
-	BT_DBG("opcode 0x%2.2x", opcode);
-
 	switch (opcode) {
 	case MGMT_OP_READ_VERSION:
 		err = read_version(sk);
@@ -2898,9 +2714,7 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 		err = test_end_le(sk, index);
 		break;
 	default:
-		BT_DBG("Unknown op %u", opcode);
-		err = cmd_status(sk, index, opcode,
-						MGMT_STATUS_UNKNOWN_COMMAND);
+		err = cmd_status(sk, index, opcode, MGMT_STATUS_UNKNOWN_COMMAND);
 		break;
 	}
 
@@ -2964,8 +2778,6 @@ int mgmt_powered(struct hci_dev *hdev, u8 powered)
 	__le32 ev;
 	int ret;
 
-	BT_DBG("powered %u", powered);
-
 	mgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);
 
 	if (!powered) {
@@ -3259,8 +3071,6 @@ int mgmt_user_passkey_notification(struct hci_dev *hdev, bdaddr_t *bdaddr,
 {
 	struct mgmt_ev_user_passkey_notificaion ev;
 
-	BT_DBG("%s", hdev->name);
-
 	bacpy(&ev.bdaddr, bdaddr);
 	put_unaligned_le32(value, &ev.value);
 
@@ -3274,8 +3084,6 @@ int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
 {
 	struct mgmt_ev_user_confirm_request ev;
 
-	BT_DBG("%s", hdev->name);
-
 	bacpy(&ev.addr.bdaddr, bdaddr);
 	ev.addr.type = link_to_mgmt(link_type, addr_type);
 	ev.confirm_hint = confirm_hint;
@@ -3290,8 +3098,6 @@ int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
 {
 	struct mgmt_ev_user_passkey_request ev;
 
-	BT_DBG("%s", hdev->name);
-
 	bacpy(&ev.addr.bdaddr, bdaddr);
 	ev.addr.type = link_to_mgmt(link_type, addr_type);
 
@@ -3403,8 +3209,6 @@ int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("%s status %u", hdev->name, status);
-
 	cmd = mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);
 	if (!cmd)
 		return -ENOENT;
@@ -3449,17 +3253,11 @@ int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)
 	}
 
 	if (enable) {
-		if (!test_and_set_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+		if (!test_and_set_bit(HCI_LE_ENABLED, &hdev->dev_flags))
 			changed = true;
-			BT_DBG("%s set HCI_LE_ENABLED  enable %d",
-											hdev->name, enable);
-			}
 	} else {
-		if (test_and_clear_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+		if (test_and_clear_bit(HCI_LE_ENABLED, &hdev->dev_flags))
 			changed = true;
-			BT_DBG("%s clear HCI_LE_ENABLED  enable %d",
-											hdev->name, enable);
-			}
 	}
 
 	mgmt_pending_foreach(MGMT_OP_SET_LE, hdev, settings_rsp, &match);
@@ -3475,8 +3273,6 @@ int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status)
 
 int mgmt_le_test_end_complete(struct hci_dev *hdev, u8 status, __u16 num_pkts)
 {
-	BT_DBG("mgmt_le_test_end_complete : %s status %d, num_pkts 0x%x(%d)"
-		, hdev->name, status, num_pkts, num_pkts);
 	return le_test_end_complete(hdev, status, num_pkts);
 }
 
@@ -3531,8 +3327,6 @@ int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 	eir_len = eir_append_data(ev->eir, 0, EIR_NAME_COMPLETE, name,
 								name_len);
 
-	BT_DBG("[NEO] mgmt_remote_name, name = %s", name);
-
 	put_unaligned_le16(eir_len, &ev->eir_len);
 
 	return mgmt_event(MGMT_EV_DEVICE_FOUND, hdev, ev,
@@ -3575,15 +3369,12 @@ int mgmt_discovering(struct hci_dev *hdev, u8 discovering)
 {
 	struct pending_cmd *cmd;
 
-	BT_DBG("%s discovering %u", hdev->name, discovering);
-
 	if (discovering)
 		cmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);
 	else
 		cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);
 
 	if (cmd != NULL) {
-		BT_DBG("cmd is not NULL !!!!!");
 		cmd_complete(cmd->sk, hdev->id, cmd->opcode, NULL, 0);
 		mgmt_pending_remove(cmd);
 	}
@@ -3625,13 +3416,10 @@ int mgmt_encrypt_change(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status)
 {
 	struct mgmt_ev_encrypt_change ev;
 
-	BT_DBG("status %u", status);
-
 	bacpy(&ev.bdaddr, bdaddr);
 	ev.status = status;
 
-	return mgmt_event(MGMT_EV_ENCRYPT_CHANGE, hdev, &ev, sizeof(ev),
-									NULL);
+	return mgmt_event(MGMT_EV_ENCRYPT_CHANGE, hdev, &ev, sizeof(ev), NULL);
 }
 
 int mgmt_remote_version(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 ver, u16 mnf,
@@ -3658,8 +3446,7 @@ int mgmt_remote_features(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 features[8])
 	bacpy(&ev.bdaddr, bdaddr);
 	memcpy(ev.features, features, sizeof(ev.features));
 
-	return mgmt_event(MGMT_EV_REMOTE_FEATURES, hdev, &ev, sizeof(ev),
-									NULL);
+	return mgmt_event(MGMT_EV_REMOTE_FEATURES, hdev, &ev, sizeof(ev), NULL);
 }
 
 module_param(enable_le, bool, 0644);
diff --git a/net/core/dev.c b/net/core/dev.c
index 25ef86f..4f01068 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -523,7 +523,6 @@ int netdev_boot_setup_check(struct net_device *dev)
 }
 EXPORT_SYMBOL(netdev_boot_setup_check);
 
-
 /**
  *	netdev_boot_base	- get address from boot time settings
  *	@prefix: prefix for network device
@@ -718,7 +717,6 @@ struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex)
 }
 EXPORT_SYMBOL(dev_get_by_index_rcu);
 
-
 /**
  *	dev_get_by_index - find a device by its ifindex
  *	@net: the applicable net namespace
@@ -1069,7 +1067,6 @@ int dev_set_alias(struct net_device *dev, const char *alias, size_t len)
 	return len;
 }
 
-
 /**
  *	netdev_features_change - device changes features
  *	@dev: device to cause notification
@@ -1299,7 +1296,6 @@ int dev_close(struct net_device *dev)
 }
 EXPORT_SYMBOL(dev_close);
 
-
 /**
  *	dev_disable_lro - disable Large Receive Offload on a device
  *	@dev: device
@@ -1333,7 +1329,6 @@ void dev_disable_lro(struct net_device *dev)
 }
 EXPORT_SYMBOL(dev_disable_lro);
 
-
 static int dev_boot_phase = 1;
 
 /**
@@ -1768,7 +1763,6 @@ void dev_kfree_skb_any(struct sk_buff *skb)
 }
 EXPORT_SYMBOL(dev_kfree_skb_any);
 
-
 /**
  * netif_device_detach - mark device as removed
  * @dev: network device
@@ -2492,12 +2486,11 @@ out:
 }
 EXPORT_SYMBOL(dev_queue_xmit);
 
-
 /*=======================================================================
 			Receiver routines
   =======================================================================*/
 
-int netdev_max_backlog __read_mostly = 1000;
+int netdev_max_backlog __read_mostly = 2000;
 int netdev_tstamp_prequeue __read_mostly = 1;
 int netdev_budget __read_mostly = 300;
 int weight_p __read_mostly = 64;            /* old backlog weight */
@@ -3887,7 +3880,6 @@ int register_gifconf(unsigned int family, gifconf_func_t *gifconf)
 }
 EXPORT_SYMBOL(register_gifconf);
 
-
 /*
  *	Map an interface index to its name (SIOCGIFNAME)
  */
@@ -4251,7 +4243,6 @@ static const struct file_operations ptype_seq_fops = {
 	.release = seq_release_net,
 };
 
-
 static int __net_init dev_proc_net_init(struct net *net)
 {
 	int rc = -ENOMEM;
@@ -4299,7 +4290,6 @@ static int __init dev_proc_init(void)
 #define dev_proc_init() 0
 #endif	/* CONFIG_PROC_FS */
 
-
 /**
  *	netdev_set_master	-	set up master pointer
  *	@slave: slave device
@@ -5107,7 +5097,6 @@ int dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 	}
 }
 
-
 /**
  *	dev_new_index	-	allocate an ifindex
  *	@net: the applicable net namespace
@@ -5175,7 +5164,6 @@ static void rollback_registered_many(struct list_head *head)
 		/* Shutdown queueing discipline. */
 		dev_shutdown(dev);
 
-
 		/* Notify protocols, that we are about to destroy
 		   this device. They should clean all the things.
 		*/
@@ -5594,7 +5582,6 @@ int init_dummy_netdev(struct net_device *dev)
 }
 EXPORT_SYMBOL_GPL(init_dummy_netdev);
 
-
 /**
  *	register_netdev	- register a network device
  *	@dev: device to register
@@ -6224,7 +6211,6 @@ static int dev_cpu_callback(struct notifier_block *nfb,
 	return NOTIFY_OK;
 }
 
-
 /**
  *	netdev_increment_features - increment feature set by one
  *	@all: current feature set
@@ -6542,4 +6528,3 @@ static int __init initialize_hashrnd(void)
 }
 
 late_initcall_sync(initialize_hashrnd);
-
diff --git a/net/core/sock.c b/net/core/sock.c
index b43e260..bab8c88 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -278,7 +278,6 @@ static void sock_disable_timestamp(struct sock *sk, int flag)
 	}
 }
 
-
 int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	int err;
@@ -750,7 +749,6 @@ set_rcvbuf:
 }
 EXPORT_SYMBOL(sock_setsockopt);
 
-
 void cred_to_ucred(struct pid *pid, const struct cred *cred,
 		   struct ucred *ucred, bool use_effective)
 {
@@ -926,8 +924,7 @@ int sock_getsockopt(struct socket *sock, int level, int optname,
 		struct ucred peercred;
 		if (len > sizeof(peercred))
 			len = sizeof(peercred);
-		cred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred,
-			      &peercred, true);
+		cred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred, true);
 		if (copy_to_user(optval, &peercred, len))
 			return -EFAULT;
 		goto lenout;
@@ -1321,8 +1318,8 @@ void __init sk_init(void)
 		sysctl_wmem_default = 32767;
 		sysctl_rmem_default = 32767;
 	} else if (totalram_pages >= 131072) {
-		sysctl_wmem_max = 131071;
-		sysctl_rmem_max = 131071;
+		sysctl_wmem_max = 2097152;
+		sysctl_rmem_max = 2097152;
 	}
 }
 
diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c
index fd7a3f6..0a614cf 100644
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@ -6,8 +6,8 @@
  * Some ARP specific bits are:
  *
  * Copyright (C) 2002 David S. Miller (davem@redhat.com)
- *
  */
+
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 #include <linux/kernel.h>
 #include <linux/skbuff.h>
@@ -33,21 +33,6 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David S. Miller <davem@redhat.com>");
 MODULE_DESCRIPTION("arptables core");
 
-/*#define DEBUG_ARP_TABLES*/
-/*#define DEBUG_ARP_TABLES_USER*/
-
-#ifdef DEBUG_ARP_TABLES
-#define dprintf(format, args...)  printk(format , ## args)
-#else
-#define dprintf(format, args...)
-#endif
-
-#ifdef DEBUG_ARP_TABLES_USER
-#define duprintf(format, args...) printk(format , ## args)
-#else
-#define duprintf(format, args...)
-#endif
-
 #ifdef CONFIG_NETFILTER_DEBUG
 #define ARP_NF_ASSERT(x)	WARN_ON(!(x))
 #else
@@ -113,33 +98,21 @@ static inline int arp_packet_match(const struct arphdr *arphdr,
 
 	if (FWINV((arphdr->ar_op & arpinfo->arpop_mask) != arpinfo->arpop,
 		  ARPT_INV_ARPOP)) {
-		dprintf("ARP operation field mismatch.\n");
-		dprintf("ar_op: %04x info->arpop: %04x info->arpop_mask: %04x\n",
-			arphdr->ar_op, arpinfo->arpop, arpinfo->arpop_mask);
 		return 0;
 	}
 
 	if (FWINV((arphdr->ar_hrd & arpinfo->arhrd_mask) != arpinfo->arhrd,
 		  ARPT_INV_ARPHRD)) {
-		dprintf("ARP hardware address format mismatch.\n");
-		dprintf("ar_hrd: %04x info->arhrd: %04x info->arhrd_mask: %04x\n",
-			arphdr->ar_hrd, arpinfo->arhrd, arpinfo->arhrd_mask);
 		return 0;
 	}
 
 	if (FWINV((arphdr->ar_pro & arpinfo->arpro_mask) != arpinfo->arpro,
 		  ARPT_INV_ARPPRO)) {
-		dprintf("ARP protocol address format mismatch.\n");
-		dprintf("ar_pro: %04x info->arpro: %04x info->arpro_mask: %04x\n",
-			arphdr->ar_pro, arpinfo->arpro, arpinfo->arpro_mask);
 		return 0;
 	}
 
 	if (FWINV((arphdr->ar_hln & arpinfo->arhln_mask) != arpinfo->arhln,
 		  ARPT_INV_ARPHLN)) {
-		dprintf("ARP hardware address length mismatch.\n");
-		dprintf("ar_hln: %02x info->arhln: %02x info->arhln_mask: %02x\n",
-			arphdr->ar_hln, arpinfo->arhln, arpinfo->arhln_mask);
 		return 0;
 	}
 
@@ -155,7 +128,6 @@ static inline int arp_packet_match(const struct arphdr *arphdr,
 		  ARPT_INV_SRCDEVADDR) ||
 	    FWINV(arp_devaddr_compare(&arpinfo->tgt_devaddr, tgt_devaddr, dev->addr_len),
 		  ARPT_INV_TGTDEVADDR)) {
-		dprintf("Source or target device address mismatch.\n");
 
 		return 0;
 	}
@@ -164,18 +136,7 @@ static inline int arp_packet_match(const struct arphdr *arphdr,
 		  ARPT_INV_SRCIP) ||
 	    FWINV(((tgt_ipaddr & arpinfo->tmsk.s_addr) != arpinfo->tgt.s_addr),
 		  ARPT_INV_TGTIP)) {
-		dprintf("Source or target IP address mismatch.\n");
-
-		dprintf("SRC: %pI4. Mask: %pI4. Target: %pI4.%s\n",
-			&src_ipaddr,
-			&arpinfo->smsk.s_addr,
-			&arpinfo->src.s_addr,
-			arpinfo->invflags & ARPT_INV_SRCIP ? " (INV)" : "");
-		dprintf("TGT: %pI4 Mask: %pI4 Target: %pI4.%s\n",
-			&tgt_ipaddr,
-			&arpinfo->tmsk.s_addr,
-			&arpinfo->tgt.s_addr,
-			arpinfo->invflags & ARPT_INV_TGTIP ? " (INV)" : "");
+
 		return 0;
 	}
 
@@ -183,18 +144,12 @@ static inline int arp_packet_match(const struct arphdr *arphdr,
 	ret = ifname_compare(indev, arpinfo->iniface, arpinfo->iniface_mask);
 
 	if (FWINV(ret != 0, ARPT_INV_VIA_IN)) {
-		dprintf("VIA in mismatch (%s vs %s).%s\n",
-			indev, arpinfo->iniface,
-			arpinfo->invflags&ARPT_INV_VIA_IN ?" (INV)":"");
 		return 0;
 	}
 
 	ret = ifname_compare(outdev, arpinfo->outiface, arpinfo->outiface_mask);
 
 	if (FWINV(ret != 0, ARPT_INV_VIA_OUT)) {
-		dprintf("VIA out mismatch (%s vs %s).%s\n",
-			outdev, arpinfo->outiface,
-			arpinfo->invflags&ARPT_INV_VIA_OUT ?" (INV)":"");
 		return 0;
 	}
 
@@ -205,13 +160,9 @@ static inline int arp_packet_match(const struct arphdr *arphdr,
 static inline int arp_checkentry(const struct arpt_arp *arp)
 {
 	if (arp->flags & ~ARPT_F_MASK) {
-		duprintf("Unknown flag bits set: %08X\n",
-			 arp->flags & ~ARPT_F_MASK);
 		return 0;
 	}
 	if (arp->invflags & ~ARPT_INV_MASK) {
-		duprintf("Unknown invflag bits set: %08X\n",
-			 arp->invflags & ~ARPT_INV_MASK);
 		return 0;
 	}
 
@@ -403,35 +354,27 @@ static int mark_source_chains(const struct xt_table_info *newinfo,
 				if ((strcmp(t->target.u.user.name,
 					    XT_STANDARD_TARGET) == 0) &&
 				    t->verdict < -NF_MAX_VERDICT - 1) {
-					duprintf("mark_source_chains: bad "
-						"negative verdict (%i)\n",
-								t->verdict);
 					return 0;
 				}
 
-				/* Return: backtrack through the last
-				 * big jump.
-				 */
+				/* Return: backtrack through the last big jump */
 				do {
 					e->comefrom ^= (1<<NF_ARP_NUMHOOKS);
 					oldpos = pos;
 					pos = e->counters.pcnt;
 					e->counters.pcnt = 0;
-
 					/* We're at the start. */
 					if (pos == oldpos)
-						goto next;
-
+						return 1;
 					e = (struct arpt_entry *)
 						(entry0 + pos);
 				} while (oldpos == pos + e->next_offset);
-
-				/* Move along one */
-				size = e->next_offset;
-				e = (struct arpt_entry *)
-					(entry0 + pos + size);
-				e->counters.pcnt = pos;
-				pos += size;
+					/* Move along one */
+					size = e->next_offset;
+					e = (struct arpt_entry *)
+						(entry0 + pos + size);
+					e->counters.pcnt = pos;
+					pos += size;
 			} else {
 				int newpos = t->verdict;
 
@@ -440,15 +383,9 @@ static int mark_source_chains(const struct xt_table_info *newinfo,
 				    newpos >= 0) {
 					if (newpos > newinfo->size -
 						sizeof(struct arpt_entry)) {
-						duprintf("mark_source_chains: "
-							"bad verdict (%i)\n",
-								newpos);
 						return 0;
 					}
 
-					/* This a jump; chase it. */
-					duprintf("Jump rule %u -> %u\n",
-						 pos, newpos);
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
@@ -459,9 +396,8 @@ static int mark_source_chains(const struct xt_table_info *newinfo,
 				pos = newpos;
 			}
 		}
-		next:
-		duprintf("Finished chain %u\n", hook);
 	}
+
 	return 1;
 }
 
@@ -470,7 +406,6 @@ static inline int check_entry(const struct arpt_entry *e, const char *name)
 	const struct xt_entry_target *t;
 
 	if (!arp_checkentry(&e->arp)) {
-		duprintf("arp_tables: arp check failed %p %s.\n", e, name);
 		return -EINVAL;
 	}
 
@@ -499,8 +434,6 @@ static inline int check_target(struct arpt_entry *e, const char *name)
 
 	ret = xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);
 	if (ret < 0) {
-		duprintf("arp_tables: check failed for `%s'.\n",
-			 t->u.kernel.target->name);
 		return ret;
 	}
 	return 0;
@@ -521,7 +454,6 @@ find_check_entry(struct arpt_entry *e, const char *name, unsigned int size)
 	target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,
 					t->u.user.revision);
 	if (IS_ERR(target)) {
-		duprintf("find_check_entry: `%s' not found\n", t->u.user.name);
 		ret = PTR_ERR(target);
 		goto out;
 	}
@@ -564,14 +496,11 @@ static inline int check_entry_size_and_hooks(struct arpt_entry *e,
 
 	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
 	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {
-		duprintf("Bad offset %p\n", e);
 		return -EINVAL;
 	}
 
 	if (e->next_offset
 	    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
-		duprintf("checking: element %p size %u\n",
-			 e, e->next_offset);
 		return -EINVAL;
 	}
 
@@ -631,7 +560,6 @@ static int translate_table(struct xt_table_info *newinfo, void *entry0,
 		newinfo->underflow[i] = 0xFFFFFFFF;
 	}
 
-	duprintf("translate_table: size %u\n", newinfo->size);
 	i = 0;
 
 	/* Walk through entries, checking offsets. */
@@ -648,13 +576,10 @@ static int translate_table(struct xt_table_info *newinfo, void *entry0,
 		    XT_ERROR_TARGET) == 0)
 			++newinfo->stacksize;
 	}
-	duprintf("translate_table: ARPT_ENTRY_ITERATE gives %d\n", ret);
 	if (ret != 0)
 		return ret;
 
 	if (i != repl->num_entries) {
-		duprintf("translate_table: %u not %u entries\n",
-			 i, repl->num_entries);
 		return -EINVAL;
 	}
 
@@ -664,19 +589,14 @@ static int translate_table(struct xt_table_info *newinfo, void *entry0,
 		if (!(repl->valid_hooks & (1 << i)))
 			continue;
 		if (newinfo->hook_entry[i] == 0xFFFFFFFF) {
-			duprintf("Invalid hook entry %u %u\n",
-				 i, repl->hook_entry[i]);
 			return -EINVAL;
 		}
 		if (newinfo->underflow[i] == 0xFFFFFFFF) {
-			duprintf("Invalid underflow %u %u\n",
-				 i, repl->underflow[i]);
 			return -EINVAL;
 		}
 	}
 
 	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0)) {
-		duprintf("Looping hook\n");
 		return -ELOOP;
 	}
 
@@ -887,8 +807,6 @@ static int get_info(struct net *net, void __user *user,
 	int ret;
 
 	if (*len != sizeof(struct arpt_getinfo)) {
-		duprintf("length %u != %Zu\n", *len,
-			 sizeof(struct arpt_getinfo));
 		return -EINVAL;
 	}
 
@@ -947,14 +865,11 @@ static int get_entries(struct net *net, struct arpt_get_entries __user *uptr,
 	struct xt_table *t;
 
 	if (*len < sizeof(get)) {
-		duprintf("get_entries: %u < %Zu\n", *len, sizeof(get));
 		return -EINVAL;
 	}
 	if (copy_from_user(&get, uptr, sizeof(get)) != 0)
 		return -EFAULT;
 	if (*len != sizeof(struct arpt_get_entries) + get.size) {
-		duprintf("get_entries: %u != %Zu\n", *len,
-			 sizeof(struct arpt_get_entries) + get.size);
 		return -EINVAL;
 	}
 
@@ -962,14 +877,10 @@ static int get_entries(struct net *net, struct arpt_get_entries __user *uptr,
 	if (t && !IS_ERR(t)) {
 		const struct xt_table_info *private = t->private;
 
-		duprintf("t->private->number = %u\n",
-			 private->number);
 		if (get.size == private->size)
 			ret = copy_entries_to_user(private->size,
 						   t, uptr->entrytable);
 		else {
-			duprintf("get_entries: I've got %u not %u!\n",
-				 private->size, get.size);
 			ret = -EAGAIN;
 		}
 		module_put(t->me);
@@ -1009,8 +920,6 @@ static int __do_replace(struct net *net, const char *name,
 
 	/* You lied! */
 	if (valid_hooks != t->valid_hooks) {
-		duprintf("Valid hook crap: %08X vs %08X\n",
-			 valid_hooks, t->valid_hooks);
 		ret = -EINVAL;
 		goto put_module;
 	}
@@ -1020,8 +929,6 @@ static int __do_replace(struct net *net, const char *name,
 		goto put_module;
 
 	/* Update module usage count based on number of rules */
-	duprintf("do_replace: oldnum=%u, initnum=%u, newnum=%u\n",
-		oldinfo->number, oldinfo->initial_entries, newinfo->number);
 	if ((oldinfo->number > oldinfo->initial_entries) ||
 	    (newinfo->number <= oldinfo->initial_entries))
 		module_put(t->me);
@@ -1087,8 +994,6 @@ static int do_replace(struct net *net, const void __user *user,
 	if (ret != 0)
 		goto free_newinfo;
 
-	duprintf("arp_tables: Translated table\n");
-
 	ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,
 			   tmp.num_counters, tmp.counters);
 	if (ret)
@@ -1215,17 +1120,13 @@ check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 	unsigned int entry_offset;
 	int ret, off, h;
 
-	duprintf("check_compat_entry_size_and_hooks %p\n", e);
 	if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
 	    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {
-		duprintf("Bad offset %p, limit = %p\n", e, limit);
 		return -EINVAL;
 	}
 
 	if (e->next_offset < sizeof(struct compat_arpt_entry) +
 			     sizeof(struct compat_xt_entry_target)) {
-		duprintf("checking: element %p size %u\n",
-			 e, e->next_offset);
 		return -EINVAL;
 	}
 
@@ -1241,8 +1142,6 @@ check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 	target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,
 					t->u.user.revision);
 	if (IS_ERR(target)) {
-		duprintf("check_compat_entry_size_and_hooks: `%s' not found\n",
-			 t->u.user.name);
 		ret = PTR_ERR(target);
 		goto out;
 	}
@@ -1336,7 +1235,6 @@ static int translate_compat_table(const char *name,
 		info->underflow[i] = 0xFFFFFFFF;
 	}
 
-	duprintf("translate_compat_table: size %u\n", info->size);
 	j = 0;
 	xt_compat_lock(NFPROTO_ARP);
 	xt_compat_init_offsets(NFPROTO_ARP, number);
@@ -1355,8 +1253,6 @@ static int translate_compat_table(const char *name,
 
 	ret = -EINVAL;
 	if (j != number) {
-		duprintf("translate_compat_table: %u not %u entries\n",
-			 j, number);
 		goto out_unlock;
 	}
 
@@ -1366,13 +1262,9 @@ static int translate_compat_table(const char *name,
 		if (!(valid_hooks & (1 << i)))
 			continue;
 		if (info->hook_entry[i] == 0xFFFFFFFF) {
-			duprintf("Invalid hook entry %u %u\n",
-				 i, hook_entries[i]);
 			goto out_unlock;
 		}
 		if (info->underflow[i] == 0xFFFFFFFF) {
-			duprintf("Invalid underflow %u %u\n",
-				 i, underflows[i]);
 			goto out_unlock;
 		}
 	}
@@ -1513,8 +1405,6 @@ static int compat_do_replace(struct net *net, void __user *user,
 	if (ret != 0)
 		goto free_newinfo;
 
-	duprintf("compat_do_replace: Translated table\n");
-
 	ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,
 			   tmp.num_counters, compat_ptr(tmp.counters));
 	if (ret)
@@ -1547,7 +1437,6 @@ static int compat_do_arpt_set_ctl(struct sock *sk, int cmd, void __user *user,
 		break;
 
 	default:
-		duprintf("do_arpt_set_ctl:  unknown request %i\n", cmd);
 		ret = -EINVAL;
 	}
 
@@ -1634,14 +1523,11 @@ static int compat_get_entries(struct net *net,
 	struct xt_table *t;
 
 	if (*len < sizeof(get)) {
-		duprintf("compat_get_entries: %u < %zu\n", *len, sizeof(get));
 		return -EINVAL;
 	}
 	if (copy_from_user(&get, uptr, sizeof(get)) != 0)
 		return -EFAULT;
 	if (*len != sizeof(struct compat_arpt_get_entries) + get.size) {
-		duprintf("compat_get_entries: %u != %zu\n",
-			 *len, sizeof(get) + get.size);
 		return -EINVAL;
 	}
 
@@ -1651,14 +1537,11 @@ static int compat_get_entries(struct net *net,
 		const struct xt_table_info *private = t->private;
 		struct xt_table_info info;
 
-		duprintf("t->private->number = %u\n", private->number);
 		ret = compat_table_info(private, &info);
 		if (!ret && get.size == info.size) {
 			ret = compat_copy_entries_to_user(private->size,
 							  t, uptr->entrytable);
 		} else if (!ret) {
-			duprintf("compat_get_entries: I've got %u not %u!\n",
-				 private->size, get.size);
 			ret = -EAGAIN;
 		}
 		xt_compat_flush_offsets(NFPROTO_ARP);
@@ -1712,7 +1595,6 @@ static int do_arpt_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned
 		break;
 
 	default:
-		duprintf("do_arpt_set_ctl:  unknown request %i\n", cmd);
 		ret = -EINVAL;
 	}
 
@@ -1755,7 +1637,6 @@ static int do_arpt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len
 	}
 
 	default:
-		duprintf("do_arpt_get_ctl: unknown request %i\n", cmd);
 		ret = -EINVAL;
 	}
 
@@ -1783,7 +1664,6 @@ struct xt_table *arpt_register_table(struct net *net,
 	memcpy(loc_cpu_entry, repl->entries, repl->size);
 
 	ret = translate_table(newinfo, loc_cpu_entry, repl);
-	duprintf("arpt_register_table: translate table gives %d\n", ret);
 	if (ret != 0)
 		goto out_free;
 
@@ -1888,7 +1768,6 @@ static int __init arp_tables_init(void)
 	if (ret < 0)
 		goto err4;
 
-	printk(KERN_INFO "arp_tables: (C) 2002 David S. Miller\n");
 	return 0;
 
 err4:
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index 24e556e..db515d8 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -34,22 +34,6 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("IPv4 packet filter");
 
-/*#define DEBUG_IP_FIREWALL*/
-/*#define DEBUG_ALLOW_ALL*/ /* Useful for remote debugging */
-/*#define DEBUG_IP_FIREWALL_USER*/
-
-#ifdef DEBUG_IP_FIREWALL
-#define dprintf(format, args...) pr_info(format , ## args)
-#else
-#define dprintf(format, args...)
-#endif
-
-#ifdef DEBUG_IP_FIREWALL_USER
-#define duprintf(format, args...) pr_info(format , ## args)
-#else
-#define duprintf(format, args...)
-#endif
-
 #ifdef CONFIG_NETFILTER_DEBUG
 #define IP_NF_ASSERT(x)		WARN_ON(!(x))
 #else
@@ -85,49 +69,31 @@ ip_packet_match(const struct iphdr *ip,
 		  IPT_INV_SRCIP) ||
 	    FWINV((ip->daddr&ipinfo->dmsk.s_addr) != ipinfo->dst.s_addr,
 		  IPT_INV_DSTIP)) {
-		dprintf("Source or dest mismatch.\n");
-
-		dprintf("SRC: %pI4. Mask: %pI4. Target: %pI4.%s\n",
-			&ip->saddr, &ipinfo->smsk.s_addr, &ipinfo->src.s_addr,
-			ipinfo->invflags & IPT_INV_SRCIP ? " (INV)" : "");
-		dprintf("DST: %pI4 Mask: %pI4 Target: %pI4.%s\n",
-			&ip->daddr, &ipinfo->dmsk.s_addr, &ipinfo->dst.s_addr,
-			ipinfo->invflags & IPT_INV_DSTIP ? " (INV)" : "");
+
 		return false;
 	}
 
 	ret = ifname_compare_aligned(indev, ipinfo->iniface, ipinfo->iniface_mask);
 
 	if (FWINV(ret != 0, IPT_INV_VIA_IN)) {
-		dprintf("VIA in mismatch (%s vs %s).%s\n",
-			indev, ipinfo->iniface,
-			ipinfo->invflags&IPT_INV_VIA_IN ?" (INV)":"");
 		return false;
 	}
 
 	ret = ifname_compare_aligned(outdev, ipinfo->outiface, ipinfo->outiface_mask);
 
 	if (FWINV(ret != 0, IPT_INV_VIA_OUT)) {
-		dprintf("VIA out mismatch (%s vs %s).%s\n",
-			outdev, ipinfo->outiface,
-			ipinfo->invflags&IPT_INV_VIA_OUT ?" (INV)":"");
 		return false;
 	}
 
 	/* Check specific protocol */
 	if (ipinfo->proto &&
 	    FWINV(ip->protocol != ipinfo->proto, IPT_INV_PROTO)) {
-		dprintf("Packet protocol %hi does not match %hi.%s\n",
-			ip->protocol, ipinfo->proto,
-			ipinfo->invflags&IPT_INV_PROTO ? " (INV)":"");
 		return false;
 	}
 
 	/* If we have a fragment rule but the packet is not a fragment
 	 * then we return zero */
 	if (FWINV((ipinfo->flags&IPT_F_FRAG) && !isfrag, IPT_INV_FRAG)) {
-		dprintf("Fragment rule but not fragment.%s\n",
-			ipinfo->invflags & IPT_INV_FRAG ? " (INV)" : "");
 		return false;
 	}
 
@@ -138,13 +104,9 @@ static bool
 ip_checkentry(const struct ipt_ip *ip)
 {
 	if (ip->flags & ~IPT_F_MASK) {
-		duprintf("Unknown flag bits set: %08X\n",
-			 ip->flags & ~IPT_F_MASK);
 		return false;
 	}
 	if (ip->invflags & ~IPT_INV_MASK) {
-		duprintf("Unknown invflag bits set: %08X\n",
-			 ip->invflags & ~IPT_INV_MASK);
 		return false;
 	}
 	return true;
@@ -478,9 +440,6 @@ mark_source_chains(const struct xt_table_info *newinfo,
 				if ((strcmp(t->target.u.user.name,
 			    		    XT_STANDARD_TARGET) == 0) &&
 				    t->verdict < -NF_MAX_VERDICT - 1) {
-					duprintf("mark_source_chains: bad "
-						"negative verdict (%i)\n",
-								t->verdict);
 					return 0;
 				}
 
@@ -491,10 +450,6 @@ mark_source_chains(const struct xt_table_info *newinfo,
 #ifdef DEBUG_IP_FIREWALL_USER
 					if (e->comefrom
 					    & (1 << NF_INET_NUMHOOKS)) {
-						duprintf("Back unset "
-							 "on hook %u "
-							 "rule %u\n",
-							 hook, pos);
 					}
 #endif
 					oldpos = pos;
@@ -503,7 +458,7 @@ mark_source_chains(const struct xt_table_info *newinfo,
 
 					/* We're at the start. */
 					if (pos == oldpos)
-						goto next;
+						return 1;
 
 					e = (struct ipt_entry *)
 						(entry0 + pos);
@@ -523,14 +478,9 @@ mark_source_chains(const struct xt_table_info *newinfo,
 				    newpos >= 0) {
 					if (newpos > newinfo->size -
 						sizeof(struct ipt_entry)) {
-						duprintf("mark_source_chains: "
-							"bad verdict (%i)\n",
-								newpos);
 						return 0;
 					}
 					/* This a jump; chase it. */
-					duprintf("Jump rule %u -> %u\n",
-						 pos, newpos);
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
@@ -541,9 +491,8 @@ mark_source_chains(const struct xt_table_info *newinfo,
 				pos = newpos;
 			}
 		}
-		next:
-		duprintf("Finished chain %u\n", hook);
 	}
+
 	return 1;
 }
 
@@ -566,7 +515,6 @@ check_entry(const struct ipt_entry *e, const char *name)
 	const struct xt_entry_target *t;
 
 	if (!ip_checkentry(&e->ip)) {
-		duprintf("ip check failed %p %s.\n", e, name);
 		return -EINVAL;
 	}
 
@@ -593,7 +541,6 @@ check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
 	ret = xt_check_match(par, m->u.match_size - sizeof(*m),
 	      ip->proto, ip->invflags & IPT_INV_PROTO);
 	if (ret < 0) {
-		duprintf("check failed for `%s'.\n", par->match->name);
 		return ret;
 	}
 	return 0;
@@ -608,7 +555,6 @@ find_check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
 	match = xt_request_find_match(NFPROTO_IPV4, m->u.user.name,
 				      m->u.user.revision);
 	if (IS_ERR(match)) {
-		duprintf("find_check_match: `%s' not found\n", m->u.user.name);
 		return PTR_ERR(match);
 	}
 	m->u.kernel.match = match;
@@ -640,8 +586,6 @@ static int check_target(struct ipt_entry *e, struct net *net, const char *name)
 	ret = xt_check_target(&par, t->u.target_size - sizeof(*t),
 	      e->ip.proto, e->ip.invflags & IPT_INV_PROTO);
 	if (ret < 0) {
-		duprintf("check failed for `%s'.\n",
-			 t->u.kernel.target->name);
 		return ret;
 	}
 	return 0;
@@ -679,7 +623,6 @@ find_check_entry(struct ipt_entry *e, struct net *net, const char *name,
 	target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,
 					t->u.user.revision);
 	if (IS_ERR(target)) {
-		duprintf("find_check_entry: `%s' not found\n", t->u.user.name);
 		ret = PTR_ERR(target);
 		goto cleanup_matches;
 	}
@@ -728,14 +671,11 @@ check_entry_size_and_hooks(struct ipt_entry *e,
 
 	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
 	    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {
-		duprintf("Bad offset %p\n", e);
 		return -EINVAL;
 	}
 
 	if (e->next_offset
 	    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
-		duprintf("checking: element %p size %u\n",
-			 e, e->next_offset);
 		return -EINVAL;
 	}
 
@@ -802,7 +742,6 @@ translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,
 		newinfo->underflow[i] = 0xFFFFFFFF;
 	}
 
-	duprintf("translate_table: size %u\n", newinfo->size);
 	i = 0;
 	/* Walk through entries, checking offsets. */
 	xt_entry_foreach(iter, entry0, newinfo->size) {
@@ -820,8 +759,6 @@ translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,
 	}
 
 	if (i != repl->num_entries) {
-		duprintf("translate_table: %u not %u entries\n",
-			 i, repl->num_entries);
 		return -EINVAL;
 	}
 
@@ -831,13 +768,9 @@ translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0,
 		if (!(repl->valid_hooks & (1 << i)))
 			continue;
 		if (newinfo->hook_entry[i] == 0xFFFFFFFF) {
-			duprintf("Invalid hook entry %u %u\n",
-				 i, repl->hook_entry[i]);
 			return -EINVAL;
 		}
 		if (newinfo->underflow[i] == 0xFFFFFFFF) {
-			duprintf("Invalid underflow %u %u\n",
-				 i, repl->underflow[i]);
 			return -EINVAL;
 		}
 	}
@@ -1076,8 +1009,6 @@ static int get_info(struct net *net, void __user *user,
 	int ret;
 
 	if (*len != sizeof(struct ipt_getinfo)) {
-		duprintf("length %u != %zu\n", *len,
-			 sizeof(struct ipt_getinfo));
 		return -EINVAL;
 	}
 
@@ -1138,27 +1069,21 @@ get_entries(struct net *net, struct ipt_get_entries __user *uptr,
 	struct xt_table *t;
 
 	if (*len < sizeof(get)) {
-		duprintf("get_entries: %u < %zu\n", *len, sizeof(get));
 		return -EINVAL;
 	}
 	if (copy_from_user(&get, uptr, sizeof(get)) != 0)
 		return -EFAULT;
 	if (*len != sizeof(struct ipt_get_entries) + get.size) {
-		duprintf("get_entries: %u != %zu\n",
-			 *len, sizeof(get) + get.size);
 		return -EINVAL;
 	}
 
 	t = xt_find_table_lock(net, AF_INET, get.name);
 	if (t && !IS_ERR(t)) {
 		const struct xt_table_info *private = t->private;
-		duprintf("t->private->number = %u\n", private->number);
 		if (get.size == private->size)
 			ret = copy_entries_to_user(private->size,
 						   t, uptr->entrytable);
 		else {
-			duprintf("get_entries: I've got %u not %u!\n",
-				 private->size, get.size);
 			ret = -EAGAIN;
 		}
 		module_put(t->me);
@@ -1197,8 +1122,6 @@ __do_replace(struct net *net, const char *name, unsigned int valid_hooks,
 
 	/* You lied! */
 	if (valid_hooks != t->valid_hooks) {
-		duprintf("Valid hook crap: %08X vs %08X\n",
-			 valid_hooks, t->valid_hooks);
 		ret = -EINVAL;
 		goto put_module;
 	}
@@ -1208,8 +1131,6 @@ __do_replace(struct net *net, const char *name, unsigned int valid_hooks,
 		goto put_module;
 
 	/* Update module usage count based on number of rules */
-	duprintf("do_replace: oldnum=%u, initnum=%u, newnum=%u\n",
-		oldinfo->number, oldinfo->initial_entries, newinfo->number);
 	if ((oldinfo->number > oldinfo->initial_entries) ||
 	    (newinfo->number <= oldinfo->initial_entries))
 		module_put(t->me);
@@ -1275,8 +1196,6 @@ do_replace(struct net *net, const void __user *user, unsigned int len)
 	if (ret != 0)
 		goto free_newinfo;
 
-	duprintf("Translated table\n");
-
 	ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,
 			   tmp.num_counters, tmp.counters);
 	if (ret)
@@ -1444,8 +1363,6 @@ compat_find_calc_match(struct xt_entry_match *m,
 	match = xt_request_find_match(NFPROTO_IPV4, m->u.user.name,
 				      m->u.user.revision);
 	if (IS_ERR(match)) {
-		duprintf("compat_check_calc_match: `%s' not found\n",
-			 m->u.user.name);
 		return PTR_ERR(match);
 	}
 	m->u.kernel.match = match;
@@ -1482,17 +1399,13 @@ check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
 	unsigned int j;
 	int ret, off, h;
 
-	duprintf("check_compat_entry_size_and_hooks %p\n", e);
 	if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
 	    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit) {
-		duprintf("Bad offset %p, limit = %p\n", e, limit);
 		return -EINVAL;
 	}
 
 	if (e->next_offset < sizeof(struct compat_ipt_entry) +
 			     sizeof(struct compat_xt_entry_target)) {
-		duprintf("checking: element %p size %u\n",
-			 e, e->next_offset);
 		return -EINVAL;
 	}
 
@@ -1516,8 +1429,6 @@ check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
 	target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,
 					t->u.user.revision);
 	if (IS_ERR(target)) {
-		duprintf("check_compat_entry_size_and_hooks: `%s' not found\n",
-			 t->u.user.name);
 		ret = PTR_ERR(target);
 		goto release_matches;
 	}
@@ -1659,7 +1570,6 @@ translate_compat_table(struct net *net,
 		info->underflow[i] = 0xFFFFFFFF;
 	}
 
-	duprintf("translate_compat_table: size %u\n", info->size);
 	j = 0;
 	xt_compat_lock(AF_INET);
 	xt_compat_init_offsets(AF_INET, number);
@@ -1678,8 +1588,6 @@ translate_compat_table(struct net *net,
 
 	ret = -EINVAL;
 	if (j != number) {
-		duprintf("translate_compat_table: %u not %u entries\n",
-			 j, number);
 		goto out_unlock;
 	}
 
@@ -1689,13 +1597,9 @@ translate_compat_table(struct net *net,
 		if (!(valid_hooks & (1 << i)))
 			continue;
 		if (info->hook_entry[i] == 0xFFFFFFFF) {
-			duprintf("Invalid hook entry %u %u\n",
-				 i, hook_entries[i]);
 			goto out_unlock;
 		}
 		if (info->underflow[i] == 0xFFFFFFFF) {
-			duprintf("Invalid underflow %u %u\n",
-				 i, underflows[i]);
 			goto out_unlock;
 		}
 	}
@@ -1825,8 +1729,6 @@ compat_do_replace(struct net *net, void __user *user, unsigned int len)
 	if (ret != 0)
 		goto free_newinfo;
 
-	duprintf("compat_do_replace: Translated table\n");
-
 	ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,
 			   tmp.num_counters, compat_ptr(tmp.counters));
 	if (ret)
@@ -1860,7 +1762,6 @@ compat_do_ipt_set_ctl(struct sock *sk,	int cmd, void __user *user,
 		break;
 
 	default:
-		duprintf("do_ipt_set_ctl:  unknown request %i\n", cmd);
 		ret = -EINVAL;
 	}
 
@@ -1917,7 +1818,6 @@ compat_get_entries(struct net *net, struct compat_ipt_get_entries __user *uptr,
 	struct xt_table *t;
 
 	if (*len < sizeof(get)) {
-		duprintf("compat_get_entries: %u < %zu\n", *len, sizeof(get));
 		return -EINVAL;
 	}
 
@@ -1925,8 +1825,6 @@ compat_get_entries(struct net *net, struct compat_ipt_get_entries __user *uptr,
 		return -EFAULT;
 
 	if (*len != sizeof(struct compat_ipt_get_entries) + get.size) {
-		duprintf("compat_get_entries: %u != %zu\n",
-			 *len, sizeof(get) + get.size);
 		return -EINVAL;
 	}
 
@@ -1935,14 +1833,11 @@ compat_get_entries(struct net *net, struct compat_ipt_get_entries __user *uptr,
 	if (t && !IS_ERR(t)) {
 		const struct xt_table_info *private = t->private;
 		struct xt_table_info info;
-		duprintf("t->private->number = %u\n", private->number);
 		ret = compat_table_info(private, &info);
 		if (!ret && get.size == info.size) {
 			ret = compat_copy_entries_to_user(private->size,
 							  t, uptr->entrytable);
 		} else if (!ret) {
-			duprintf("compat_get_entries: I've got %u not %u!\n",
-				 private->size, get.size);
 			ret = -EAGAIN;
 		}
 		xt_compat_flush_offsets(AF_INET);
@@ -1997,7 +1892,6 @@ do_ipt_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)
 		break;
 
 	default:
-		duprintf("do_ipt_set_ctl:  unknown request %i\n", cmd);
 		ret = -EINVAL;
 	}
 
@@ -2049,7 +1943,6 @@ do_ipt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
 	}
 
 	default:
-		duprintf("do_ipt_get_ctl: unknown request %i\n", cmd);
 		ret = -EINVAL;
 	}
 
@@ -2139,7 +2032,6 @@ icmp_match(const struct sk_buff *skb, struct xt_action_param *par)
 		/* We've been asked to examine this packet, and we
 		 * can't.  Hence, no choice but to drop.
 		 */
-		duprintf("Dropping evil ICMP tinygram.\n");
 		par->hotdrop = true;
 		return false;
 	}
@@ -2242,7 +2134,6 @@ static int __init ip_tables_init(void)
 	if (ret < 0)
 		goto err5;
 
-	pr_info("(C) 2000-2006 Netfilter Core Team\n");
 	return 0;
 
 err5:
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index d7d63f4..282bfd7 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -1,4 +1,3 @@
-
 /* (C) 1999-2001 Paul `Rusty' Russell
  * (C) 2002-2004 Netfilter Core Team <coreteam@netfilter.org>
  *
@@ -86,9 +85,6 @@ static int ipv4_get_l4proto(const struct sk_buff *skb, unsigned int nhoff,
 
 	/* Check bogus IP headers */
 	if (*dataoff > skb->len) {
-		pr_debug("nf_conntrack_ipv4: bogus IPv4 packet: "
-			 "nhoff %u, ihl %u, skblen %u\n",
-			 nhoff, iph->ihl << 2, skb->len);
 		return -NF_ACCEPT;
 	}
 
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index dff164e..d849432 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -249,8 +249,6 @@ static void death_by_event(unsigned long ul_conntrack)
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_ecache *ecache = nf_ct_ecache_find(ct);
 
-	BUG_ON(ecache == NULL);
-
 	if (nf_conntrack_event(IPCT_DESTROY, ct) < 0) {
 		/* bad luck, let's retry again */
 		ecache->timeout.expires = jiffies +
@@ -271,8 +269,6 @@ void nf_ct_insert_dying_list(struct nf_conn *ct)
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_ecache *ecache = nf_ct_ecache_find(ct);
 
-	BUG_ON(ecache == NULL);
-
 	/* add this conntrack to the dying list */
 	spin_lock_bh(&nf_conntrack_lock);
 	hlist_nulls_add_head(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode,
diff --git a/net/netfilter/nf_tproxy_core.c b/net/netfilter/nf_tproxy_core.c
index 474d621..e7d03b1 100644
--- a/net/netfilter/nf_tproxy_core.c
+++ b/net/netfilter/nf_tproxy_core.c
@@ -18,7 +18,6 @@
 #include <net/udp.h>
 #include <net/netfilter/nf_tproxy_core.h>
 
-
 static void
 nf_tproxy_destructor(struct sk_buff *skb)
 {
@@ -51,7 +50,9 @@ EXPORT_SYMBOL_GPL(nf_tproxy_assign_sock);
 static int __init nf_tproxy_init(void)
 {
 	pr_info("NF_TPROXY: Transparent proxy support initialized, version 4.1.0\n");
+#if 0
 	pr_info("NF_TPROXY: Copyright (c) 2006-2007 BalaBit IT Ltd.\n");
+#endif
 	return 0;
 }
 
diff --git a/net/netfilter/xt_qtaguid.c b/net/netfilter/xt_qtaguid.c
index f6d4cfc..e62d349 100644
--- a/net/netfilter/xt_qtaguid.c
+++ b/net/netfilter/xt_qtaguid.c
@@ -41,7 +41,6 @@
 #define XT_SOCKET_SUPPORTED_HOOKS \
 	((1 << NF_INET_PRE_ROUTING) | (1 << NF_INET_LOCAL_IN))
 
-
 static const char *module_procdirname = "xt_qtaguid";
 static struct proc_dir_entry *xt_qtaguid_procdir;
 
@@ -123,105 +122,6 @@ static struct proc_dir_entry *iface_stat_all_procfile;
 static const char *iface_stat_fmt_procfilename = "iface_stat_fmt";
 static struct proc_dir_entry *iface_stat_fmt_procfile;
 
-
-/*
- * Ordering of locks:
- *  outer locks:
- *    iface_stat_list_lock
- *    sock_tag_list_lock
- *  inner locks:
- *    uid_tag_data_tree_lock
- *    tag_counter_set_list_lock
- * Notice how sock_tag_list_lock is held sometimes when uid_tag_data_tree_lock
- * is acquired.
- *
- * Call tree with all lock holders as of 2012-04-27:
- *
- * iface_stat_fmt_proc_read()
- *   iface_stat_list_lock
- *     (struct iface_stat)
- *
- * qtaguid_ctrl_proc_read()
- *   sock_tag_list_lock
- *     (sock_tag_tree)
- *     (struct proc_qtu_data->sock_tag_list)
- *   prdebug_full_state()
- *     sock_tag_list_lock
- *       (sock_tag_tree)
- *     uid_tag_data_tree_lock
- *       (uid_tag_data_tree)
- *       (proc_qtu_data_tree)
- *     iface_stat_list_lock
- *
- * qtaguid_stats_proc_read()
- *   iface_stat_list_lock
- *     struct iface_stat->tag_stat_list_lock
- *
- * qtudev_open()
- *   uid_tag_data_tree_lock
- *
- * qtudev_release()
- *   sock_tag_data_list_lock
- *     uid_tag_data_tree_lock
- *   prdebug_full_state()
- *     sock_tag_list_lock
- *     uid_tag_data_tree_lock
- *     iface_stat_list_lock
- *
- * iface_netdev_event_handler()
- *   iface_stat_create()
- *     iface_stat_list_lock
- *   iface_stat_update()
- *     iface_stat_list_lock
- *
- * iface_inetaddr_event_handler()
- *   iface_stat_create()
- *     iface_stat_list_lock
- *   iface_stat_update()
- *     iface_stat_list_lock
- *
- * iface_inet6addr_event_handler()
- *   iface_stat_create_ipv6()
- *     iface_stat_list_lock
- *   iface_stat_update()
- *     iface_stat_list_lock
- *
- * qtaguid_mt()
- *   account_for_uid()
- *     if_tag_stat_update()
- *       get_sock_stat()
- *         sock_tag_list_lock
- *       struct iface_stat->tag_stat_list_lock
- *         tag_stat_update()
- *           get_active_counter_set()
- *             tag_counter_set_list_lock
- *         tag_stat_update()
- *           get_active_counter_set()
- *             tag_counter_set_list_lock
- *
- *
- * qtaguid_ctrl_parse()
- *   ctrl_cmd_delete()
- *     sock_tag_list_lock
- *     tag_counter_set_list_lock
- *     iface_stat_list_lock
- *       struct iface_stat->tag_stat_list_lock
- *     uid_tag_data_tree_lock
- *   ctrl_cmd_counter_set()
- *     tag_counter_set_list_lock
- *   ctrl_cmd_tag()
- *     sock_tag_list_lock
- *       (sock_tag_tree)
- *       get_tag_ref()
- *         uid_tag_data_tree_lock
- *           (uid_tag_data_tree)
- *       uid_tag_data_tree_lock
- *         (proc_qtu_data_tree)
- *   ctrl_cmd_untag()
- *     sock_tag_list_lock
- *     uid_tag_data_tree_lock
- *
- */
 static LIST_HEAD(iface_stat_list);
 static DEFINE_SPINLOCK(iface_stat_list_lock);
 
@@ -294,12 +194,7 @@ static struct tag_node *tag_node_tree_search(struct rb_root *root, tag_t tag)
 	while (node) {
 		struct tag_node *data = rb_entry(node, struct tag_node, node);
 		int result;
-		RB_DEBUG("qtaguid: tag_node_tree_search(0x%llx): "
-			 " node=%p data=%p\n", tag, node, data);
 		result = tag_compare(tag, data->tag);
-		RB_DEBUG("qtaguid: tag_node_tree_search(0x%llx): "
-			 " data.tag=0x%llx (uid=%u) res=%d\n",
-			 tag, data->tag, get_uid_from_tag(data->tag), result);
 		if (result < 0)
 			node = node->rb_left;
 		else if (result > 0)
@@ -319,10 +214,6 @@ static void tag_node_tree_insert(struct tag_node *data, struct rb_root *root)
 		struct tag_node *this = rb_entry(*new, struct tag_node,
 						 node);
 		int result = tag_compare(data->tag, this->tag);
-		RB_DEBUG("qtaguid: %s(): tag=0x%llx"
-			 " (uid=%u)\n", __func__,
-			 this->tag,
-			 get_uid_from_tag(this->tag));
 		parent = *new;
 		if (result < 0)
 			new = &((*new)->rb_left);
@@ -428,11 +319,6 @@ static void sock_tag_tree_erase(struct rb_root *st_to_free_tree)
 	while (node) {
 		st_entry = rb_entry(node, struct sock_tag, sock_node);
 		node = rb_next(node);
-		CT_DEBUG("qtaguid: %s(): "
-			 "erase st: sk=%p tag=0x%llx (uid=%u)\n", __func__,
-			 st_entry->sk,
-			 st_entry->tag,
-			 get_uid_from_tag(st_entry->tag));
 		rb_erase(&st_entry->sock_node, st_to_free_tree);
 		sockfd_put(st_entry->socket);
 		kfree(st_entry);
@@ -539,7 +425,6 @@ struct uid_tag_data *get_uid_data(uid_t uid, bool *found_res)
 
 	/* Look for top level uid_tag_data for the UID */
 	utd_entry = uid_tag_data_tree_search(&uid_tag_data_tree, uid);
-	DR_DEBUG("qtaguid: get_uid_data(%u) utd=%p\n", uid, utd_entry);
 
 	if (found_res)
 		*found_res = utd_entry;
@@ -548,15 +433,13 @@ struct uid_tag_data *get_uid_data(uid_t uid, bool *found_res)
 
 	utd_entry = kzalloc(sizeof(*utd_entry), GFP_ATOMIC);
 	if (!utd_entry) {
-		pr_err("qtaguid: get_uid_data(%u): "
-		       "tag data alloc failed\n", uid);
+		pr_err("qtaguid: get_uid_data(%u): tag data alloc failed\n", uid);
 		return ERR_PTR(-ENOMEM);
 	}
 
 	utd_entry->uid = uid;
 	utd_entry->tag_ref_tree = RB_ROOT;
 	uid_tag_data_tree_insert(utd_entry, &uid_tag_data_tree);
-	DR_DEBUG("qtaguid: get_uid_data(%u) new utd=%p\n", uid, utd_entry);
 	return utd_entry;
 }
 
@@ -568,9 +451,6 @@ static struct tag_ref *new_tag_ref(tag_t new_tag,
 	int res;
 
 	if (utd_entry->num_active_tags + 1 > max_sock_tags) {
-		pr_info("qtaguid: new_tag_ref(0x%llx): "
-			"tag ref alloc quota exceeded. max=%d\n",
-			new_tag, max_sock_tags);
 		res = -EMFILE;
 		goto err_res;
 
@@ -578,9 +458,6 @@ static struct tag_ref *new_tag_ref(tag_t new_tag,
 
 	tr_entry = kzalloc(sizeof(*tr_entry), GFP_ATOMIC);
 	if (!tr_entry) {
-		pr_err("qtaguid: new_tag_ref(0x%llx): "
-		       "tag ref alloc failed\n",
-		       new_tag);
 		res = -ENOMEM;
 		goto err_res;
 	}
@@ -588,9 +465,6 @@ static struct tag_ref *new_tag_ref(tag_t new_tag,
 	/* tr_entry->num_sock_tags  handled by caller */
 	utd_entry->num_active_tags++;
 	tag_ref_tree_insert(tr_entry, &utd_entry->tag_ref_tree);
-	DR_DEBUG("qtaguid: new_tag_ref(0x%llx): "
-		 " inserted new tag ref %p\n",
-		 new_tag, tr_entry);
 	return tr_entry;
 
 err_res:
@@ -605,9 +479,6 @@ static struct tag_ref *lookup_tag_ref(tag_t full_tag,
 	bool found_utd;
 	uid_t uid = get_uid_from_tag(full_tag);
 
-	DR_DEBUG("qtaguid: lookup_tag_ref(tag=0x%llx (uid=%u))\n",
-		 full_tag, uid);
-
 	utd_entry = get_uid_data(uid, &found_utd);
 	if (IS_ERR_OR_NULL(utd_entry)) {
 		if (utd_res)
@@ -618,8 +489,6 @@ static struct tag_ref *lookup_tag_ref(tag_t full_tag,
 	tr_entry = tag_ref_tree_search(&utd_entry->tag_ref_tree, full_tag);
 	if (utd_res)
 		*utd_res = utd_entry;
-	DR_DEBUG("qtaguid: lookup_tag_ref(0x%llx) utd_entry=%p tr_entry=%p\n",
-		 full_tag, utd_entry, tr_entry);
 	return tr_entry;
 }
 
@@ -630,8 +499,6 @@ static struct tag_ref *get_tag_ref(tag_t full_tag,
 	struct uid_tag_data *utd_entry;
 	struct tag_ref *tr_entry;
 
-	DR_DEBUG("qtaguid: get_tag_ref(0x%llx)\n",
-		 full_tag);
 	spin_lock_bh(&uid_tag_data_tree_lock);
 	tr_entry = lookup_tag_ref(full_tag, &utd_entry);
 	BUG_ON(IS_ERR_OR_NULL(utd_entry));
@@ -641,8 +508,6 @@ static struct tag_ref *get_tag_ref(tag_t full_tag,
 	spin_unlock_bh(&uid_tag_data_tree_lock);
 	if (utd_res)
 		*utd_res = utd_entry;
-	DR_DEBUG("qtaguid: get_tag_ref(0x%llx) utd=%p tr=%p\n",
-		 full_tag, utd_entry, tr_entry);
 	return tr_entry;
 }
 
@@ -652,19 +517,10 @@ static void put_utd_entry(struct uid_tag_data *utd_entry)
 	/* Are we done with the UID tag data entry? */
 	if (RB_EMPTY_ROOT(&utd_entry->tag_ref_tree) &&
 		!utd_entry->num_pqd) {
-		DR_DEBUG("qtaguid: %s(): "
-			 "erase utd_entry=%p uid=%u "
-			 "by pid=%u tgid=%u uid=%u\n", __func__,
-			 utd_entry, utd_entry->uid,
-			 current->pid, current->tgid, current_fsuid());
 		BUG_ON(utd_entry->num_active_tags);
 		rb_erase(&utd_entry->node, &uid_tag_data_tree);
 		kfree(utd_entry);
 	} else {
-		DR_DEBUG("qtaguid: %s(): "
-			 "utd_entry=%p still has %d tags %d proc_qtu_data\n",
-			 __func__, utd_entry, utd_entry->num_active_tags,
-			 utd_entry->num_pqd);
 		BUG_ON(!(utd_entry->num_active_tags ||
 			 utd_entry->num_pqd));
 	}
@@ -678,14 +534,10 @@ static void put_utd_entry(struct uid_tag_data *utd_entry)
 static void free_tag_ref_from_utd_entry(struct tag_ref *tr_entry,
 					struct uid_tag_data *utd_entry)
 {
-	DR_DEBUG("qtaguid: %s(): %p tag=0x%llx (uid=%u)\n", __func__,
-		 tr_entry, tr_entry->tn.tag,
-		 get_uid_from_tag(tr_entry->tn.tag));
 	if (!tr_entry->num_sock_tags) {
 		BUG_ON(!utd_entry->num_active_tags);
 		utd_entry->num_active_tags--;
 		rb_erase(&tr_entry->tn.node, &utd_entry->tag_ref_tree);
-		DR_DEBUG("qtaguid: %s(): erased %p\n", __func__, tr_entry);
 		kfree(tr_entry);
 	}
 }
@@ -696,8 +548,6 @@ static void put_tag_ref_tree(tag_t full_tag, struct uid_tag_data *utd_entry)
 	struct tag_ref *tr_entry;
 	tag_t acct_tag;
 
-	DR_DEBUG("qtaguid: %s(tag=0x%llx (uid=%u))\n", __func__,
-		 full_tag, get_uid_from_tag(full_tag));
 	acct_tag = get_atag_from_tag(full_tag);
 	node = rb_first(&utd_entry->tag_ref_tree);
 	while (node) {
@@ -751,9 +601,6 @@ static int get_active_counter_set(tag_t tag)
 	int active_set = 0;
 	struct tag_counter_set *tcs;
 
-	MT_DEBUG("qtaguid: get_active_counter_set(tag=0x%llx)"
-		 " (uid=%u)\n",
-		 tag, get_uid_from_tag(tag));
 	/* For now we only handle UID tags for active sets */
 	tag = get_utag_from_tag(tag);
 	spin_lock_bh(&tag_counter_set_list_lock);
@@ -774,7 +621,6 @@ static struct iface_stat *get_iface_entry(const char *ifname)
 
 	/* Find the entry for tracking the specified tag within the interface */
 	if (ifname == NULL) {
-		pr_info("qtaguid: iface_stat: get() NULL device name\n");
 		return NULL;
 	}
 
@@ -805,14 +651,6 @@ static int iface_stat_fmt_proc_read(char *page, char **num_items_returned,
 		return 0;
 	}
 
-	CT_DEBUG("qtaguid:proc iface_stat_fmt "
-		 "pid=%u tgid=%u uid=%u "
-		 "page=%p *num_items_returned=%p off=%ld "
-		 "char_count=%d *eof=%d\n",
-		 current->pid, current->tgid, current_fsuid(),
-		 page, *num_items_returned,
-		 items_to_skip, char_count, *eof);
-
 	if (*eof)
 		return 0;
 
@@ -924,8 +762,6 @@ static void iface_create_proc_worker(struct work_struct *work)
 	create_proc_read_entry("active", proc_iface_perms, proc_entry,
 			read_proc_bool, &new_iface->active);
 
-	IF_DEBUG("qtaguid: iface_stat: create_proc(): done "
-		 "entry=%p dev=%s\n", new_iface, new_iface->ifname);
 	kfree(isw);
 }
 
@@ -940,18 +776,9 @@ static void _iface_stat_set_active(struct iface_stat *entry,
 	if (activate) {
 		entry->net_dev = net_dev;
 		entry->active = true;
-		IF_DEBUG("qtaguid: %s(%s): "
-			 "enable tracking. rfcnt=%d\n", __func__,
-			 entry->ifname,
-			 percpu_read(*net_dev->pcpu_refcnt));
 	} else {
 		entry->active = false;
 		entry->net_dev = NULL;
-		IF_DEBUG("qtaguid: %s(%s): "
-			 "disable tracking. rfcnt=%d\n", __func__,
-			 entry->ifname,
-			 percpu_read(*net_dev->pcpu_refcnt));
-
 	}
 }
 
@@ -963,14 +790,12 @@ static struct iface_stat *iface_alloc(struct net_device *net_dev)
 
 	new_iface = kzalloc(sizeof(*new_iface), GFP_ATOMIC);
 	if (new_iface == NULL) {
-		pr_err("qtaguid: iface_stat: create(%s): "
-		       "iface_stat alloc failed\n", net_dev->name);
+		pr_err("qtaguid: iface_stat: create(%s): iface_stat alloc failed\n", net_dev->name);
 		return NULL;
 	}
 	new_iface->ifname = kstrdup(net_dev->name, GFP_ATOMIC);
 	if (new_iface->ifname == NULL) {
-		pr_err("qtaguid: iface_stat: create(%s): "
-		       "ifname alloc failed\n", net_dev->name);
+		pr_err("qtaguid: iface_stat: create(%s): ifname alloc failed\n", net_dev->name);
 		kfree(new_iface);
 		return NULL;
 	}
@@ -984,8 +809,7 @@ static struct iface_stat *iface_alloc(struct net_device *net_dev)
 	 */
 	isw = kmalloc(sizeof(*isw), GFP_ATOMIC);
 	if (!isw) {
-		pr_err("qtaguid: iface_stat: create(%s): "
-		       "work alloc failed\n", new_iface->ifname);
+		pr_err("qtaguid: iface_stat: create(%s): work alloc failed\n", new_iface->ifname);
 		_iface_stat_set_active(new_iface, net_dev, false);
 		kfree(new_iface->ifname);
 		kfree(new_iface);
@@ -1010,19 +834,7 @@ static void iface_check_stats_reset_and_adjust(struct net_device *net_dev,
 		(stats->rx_bytes < iface->last_known[IFS_RX].bytes)
 		|| (stats->tx_bytes < iface->last_known[IFS_TX].bytes);
 
-	IF_DEBUG("qtaguid: %s(%s): iface=%p netdev=%p "
-		 "bytes rx/tx=%llu/%llu "
-		 "active=%d last_known=%d "
-		 "stats_rewound=%d\n", __func__,
-		 net_dev ? net_dev->name : "?",
-		 iface, net_dev,
-		 stats->rx_bytes, stats->tx_bytes,
-		 iface->active, iface->last_known_valid, stats_rewound);
-
 	if (iface->active && iface->last_known_valid && stats_rewound) {
-		pr_warn_once("qtaguid: iface_stat: %s(%s): "
-			     "iface reset its stats unexpectedly\n", __func__,
-			     net_dev->name);
 
 		iface->totals_via_dev[IFS_TX].bytes +=
 			iface->last_known[IFS_TX].bytes;
@@ -1033,10 +845,6 @@ static void iface_check_stats_reset_and_adjust(struct net_device *net_dev,
 		iface->totals_via_dev[IFS_RX].packets +=
 			iface->last_known[IFS_RX].packets;
 		iface->last_known_valid = false;
-		IF_DEBUG("qtaguid: %s(%s): iface=%p "
-			 "used last known bytes rx/tx=%llu/%llu\n", __func__,
-			 iface->ifname, iface, iface->last_known[IFS_RX].bytes,
-			 iface->last_known[IFS_TX].bytes);
 	}
 }
 
@@ -1054,9 +862,6 @@ static void iface_stat_create(struct net_device *net_dev,
 	__be32 ipaddr = 0;
 	struct iface_stat *new_iface;
 
-	IF_DEBUG("qtaguid: iface_stat: create(%s): ifa=%p netdev=%p\n",
-		 net_dev ? net_dev->name : "?",
-		 ifa, net_dev);
 	if (!net_dev) {
 		pr_err("qtaguid: iface_stat: create(): no net dev\n");
 		return;
@@ -1066,25 +871,16 @@ static void iface_stat_create(struct net_device *net_dev,
 	if (!ifa) {
 		in_dev = in_dev_get(net_dev);
 		if (!in_dev) {
-			pr_err("qtaguid: iface_stat: create(%s): no inet dev\n",
-			       ifname);
+			pr_err("qtaguid: iface_stat: create(%s): no inet dev\n", ifname);
 			return;
 		}
-		IF_DEBUG("qtaguid: iface_stat: create(%s): in_dev=%p\n",
-			 ifname, in_dev);
 		for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {
-			IF_DEBUG("qtaguid: iface_stat: create(%s): "
-				 "ifa=%p ifa_label=%s\n",
-				 ifname, ifa,
-				 ifa->ifa_label ? ifa->ifa_label : "(null)");
 			if (ifa->ifa_label && !strcmp(ifname, ifa->ifa_label))
 				break;
 		}
 	}
 
 	if (!ifa) {
-		IF_DEBUG("qtaguid: iface_stat: create(%s): no matching IP\n",
-			 ifname);
 		goto done_put;
 	}
 	ipaddr = ifa->ifa_local;
@@ -1093,23 +889,14 @@ static void iface_stat_create(struct net_device *net_dev,
 	entry = get_iface_entry(ifname);
 	if (entry != NULL) {
 		bool activate = !ipv4_is_loopback(ipaddr);
-		IF_DEBUG("qtaguid: iface_stat: create(%s): entry=%p\n",
-			 ifname, entry);
 		iface_check_stats_reset_and_adjust(net_dev, entry);
 		_iface_stat_set_active(entry, net_dev, activate);
-		IF_DEBUG("qtaguid: %s(%s): "
-			 "tracking now %d on ip=%pI4\n", __func__,
-			 entry->ifname, activate, &ipaddr);
 		goto done_unlock_put;
 	} else if (ipv4_is_loopback(ipaddr)) {
-		IF_DEBUG("qtaguid: iface_stat: create(%s): "
-			 "ignore loopback dev. ip=%pI4\n", ifname, &ipaddr);
 		goto done_unlock_put;
 	}
 
 	new_iface = iface_alloc(net_dev);
-	IF_DEBUG("qtaguid: iface_stat: create(%s): done "
-		 "entry=%p ip=%pI4\n", ifname, new_iface, &ipaddr);
 done_unlock_put:
 	spin_unlock_bh(&iface_stat_list_lock);
 done_put:
@@ -1126,8 +913,6 @@ static void iface_stat_create_ipv6(struct net_device *net_dev,
 	struct iface_stat *new_iface;
 	int addr_type;
 
-	IF_DEBUG("qtaguid: iface_stat: create6(): ifa=%p netdev=%p->name=%s\n",
-		 ifa, net_dev, net_dev ? net_dev->name : "");
 	if (!net_dev) {
 		pr_err("qtaguid: iface_stat: create6(): no net dev!\n");
 		return;
@@ -1136,17 +921,11 @@ static void iface_stat_create_ipv6(struct net_device *net_dev,
 
 	in_dev = in_dev_get(net_dev);
 	if (!in_dev) {
-		pr_err("qtaguid: iface_stat: create6(%s): no inet dev\n",
-		       ifname);
+		pr_err("qtaguid: iface_stat: create6(%s): no inet dev\n", ifname);
 		return;
 	}
 
-	IF_DEBUG("qtaguid: iface_stat: create6(%s): in_dev=%p\n",
-		 ifname, in_dev);
-
 	if (!ifa) {
-		IF_DEBUG("qtaguid: iface_stat: create6(%s): no matching IP\n",
-			 ifname);
 		goto done_put;
 	}
 	addr_type = ipv6_addr_type(&ifa->addr);
@@ -1155,24 +934,14 @@ static void iface_stat_create_ipv6(struct net_device *net_dev,
 	entry = get_iface_entry(ifname);
 	if (entry != NULL) {
 		bool activate = !(addr_type & IPV6_ADDR_LOOPBACK);
-		IF_DEBUG("qtaguid: %s(%s): entry=%p\n", __func__,
-			 ifname, entry);
 		iface_check_stats_reset_and_adjust(net_dev, entry);
 		_iface_stat_set_active(entry, net_dev, activate);
-		IF_DEBUG("qtaguid: %s(%s): "
-			 "tracking now %d on ip=%pI6c\n", __func__,
-			 entry->ifname, activate, &ifa->addr);
 		goto done_unlock_put;
 	} else if (addr_type & IPV6_ADDR_LOOPBACK) {
-		IF_DEBUG("qtaguid: %s(%s): "
-			 "ignore loopback dev. ip=%pI6c\n", __func__,
-			 ifname, &ifa->addr);
 		goto done_unlock_put;
 	}
 
 	new_iface = iface_alloc(net_dev);
-	IF_DEBUG("qtaguid: iface_stat: create6(%s): done "
-		 "entry=%p ip=%pI6c\n", ifname, new_iface, &ifa->addr);
 
 done_unlock_put:
 	spin_unlock_bh(&iface_stat_list_lock);
@@ -1182,14 +951,12 @@ done_put:
 
 static struct sock_tag *get_sock_stat_nl(const struct sock *sk)
 {
-	MT_DEBUG("qtaguid: get_sock_stat_nl(sk=%p)\n", sk);
 	return sock_tag_tree_search(&sock_tag_tree, sk);
 }
 
 static struct sock_tag *get_sock_stat(const struct sock *sk)
 {
 	struct sock_tag *sock_tag_entry;
-	MT_DEBUG("qtaguid: get_sock_stat(sk=%p)\n", sk);
 	if (!sk)
 		return NULL;
 	spin_lock_bh(&sock_tag_list_lock);
@@ -1206,9 +973,6 @@ static int ipx_proto(const struct sk_buff *skb,
 	switch (par->family) {
 	case NFPROTO_IPV6:
 		tproto = ipv6_find_hdr(skb, &thoff, -1, NULL);
-		if (tproto < 0)
-			MT_DEBUG("%s(): transport header not found in ipv6"
-				 " skb=%p\n", __func__, skb);
 		break;
 	case NFPROTO_IPV4:
 		tproto = ip_hdr(skb)->protocol;
@@ -1252,17 +1016,11 @@ static void iface_stat_update(struct net_device *net_dev, bool stash_only)
 	spin_lock_bh(&iface_stat_list_lock);
 	entry = get_iface_entry(net_dev->name);
 	if (entry == NULL) {
-		IF_DEBUG("qtaguid: iface_stat: update(%s): not tracked\n",
-			 net_dev->name);
 		spin_unlock_bh(&iface_stat_list_lock);
 		return;
 	}
 
-	IF_DEBUG("qtaguid: %s(%s): entry=%p\n", __func__,
-		 net_dev->name, entry);
 	if (!entry->active) {
-		IF_DEBUG("qtaguid: %s(%s): already disabled\n", __func__,
-			 net_dev->name);
 		spin_unlock_bh(&iface_stat_list_lock);
 		return;
 	}
@@ -1273,9 +1031,6 @@ static void iface_stat_update(struct net_device *net_dev, bool stash_only)
 		entry->last_known[IFS_RX].bytes = stats->rx_bytes;
 		entry->last_known[IFS_RX].packets = stats->rx_packets;
 		entry->last_known_valid = true;
-		IF_DEBUG("qtaguid: %s(%s): "
-			 "dev stats stashed rx/tx=%llu/%llu\n", __func__,
-			 net_dev->name, stats->rx_bytes, stats->tx_bytes);
 		spin_unlock_bh(&iface_stat_list_lock);
 		return;
 	}
@@ -1286,9 +1041,6 @@ static void iface_stat_update(struct net_device *net_dev, bool stash_only)
 	/* We don't need the last_known[] anymore */
 	entry->last_known_valid = false;
 	_iface_stat_set_active(entry, net_dev, false);
-	IF_DEBUG("qtaguid: %s(%s): "
-		 "disable tracking. rx/tx=%llu/%llu\n", __func__,
-		 net_dev->name, stats->rx_bytes, stats->tx_bytes);
 	spin_unlock_bh(&iface_stat_list_lock);
 }
 
@@ -1307,18 +1059,11 @@ static void iface_stat_update_from_skb(const struct sk_buff *skb,
 	int bytes = skb->len;
 
 	if (!skb->dev) {
-		MT_DEBUG("qtaguid[%d]: no skb->dev\n", par->hooknum);
 		el_dev = par->in ? : par->out;
 	} else {
 		const struct net_device *other_dev;
 		el_dev = skb->dev;
 		other_dev = par->in ? : par->out;
-		if (el_dev != other_dev) {
-			MT_DEBUG("qtaguid[%d]: skb->dev=%p %s vs "
-				 "par->(in/out)=%p %s\n",
-				 par->hooknum, el_dev, el_dev->name, other_dev,
-				 other_dev->name);
-		}
 	}
 
 	if (unlikely(!el_dev)) {
@@ -1329,25 +1074,15 @@ static void iface_stat_update_from_skb(const struct sk_buff *skb,
 		pr_err("qtaguid[%d]: %s(): no dev->name?!!\n",
 		       par->hooknum, __func__);
 		BUG();
-	} else {
-		int proto = ipx_proto(skb, par);
-		MT_DEBUG("qtaguid[%d]: dev name=%s type=%d fam=%d proto=%d\n",
-			 par->hooknum, el_dev->name, el_dev->type,
-			 par->family, proto);
 	}
 
 	spin_lock_bh(&iface_stat_list_lock);
 	entry = get_iface_entry(el_dev->name);
 	if (entry == NULL) {
-		IF_DEBUG("qtaguid: iface_stat: %s(%s): not tracked\n",
-			 __func__, el_dev->name);
 		spin_unlock_bh(&iface_stat_list_lock);
 		return;
 	}
 
-	IF_DEBUG("qtaguid: %s(%s): entry=%p\n", __func__,
-		 el_dev->name, entry);
-
 	entry->totals_via_skb[direction].bytes += bytes;
 	entry->totals_via_skb[direction].packets++;
 	spin_unlock_bh(&iface_stat_list_lock);
@@ -1358,10 +1093,6 @@ static void tag_stat_update(struct tag_stat *tag_entry,
 {
 	int active_set;
 	active_set = get_active_counter_set(tag_entry->tn.tag);
-	MT_DEBUG("qtaguid: tag_stat_update(tag=0x%llx (uid=%u) set=%d "
-		 "dir=%d proto=%d bytes=%d)\n",
-		 tag_entry->tn.tag, get_uid_from_tag(tag_entry->tn.tag),
-		 active_set, direction, proto, bytes);
 	data_counters_update(&tag_entry->counters, active_set, direction,
 			     proto, bytes);
 	if (tag_entry->parent_counters)
@@ -1378,12 +1109,8 @@ static struct tag_stat *create_if_tag_stat(struct iface_stat *iface_entry,
 					   tag_t tag)
 {
 	struct tag_stat *new_tag_stat_entry = NULL;
-	IF_DEBUG("qtaguid: iface_stat: %s(): ife=%p tag=0x%llx"
-		 " (uid=%u)\n", __func__,
-		 iface_entry, tag, get_uid_from_tag(tag));
 	new_tag_stat_entry = kzalloc(sizeof(*new_tag_stat_entry), GFP_ATOMIC);
 	if (!new_tag_stat_entry) {
-		pr_err("qtaguid: iface_stat: tag stat alloc failed\n");
 		goto done;
 	}
 	new_tag_stat_entry->tn.tag = tag;
@@ -1403,22 +1130,13 @@ static void if_tag_stat_update(const char *ifname, uid_t uid,
 	struct sock_tag *sock_tag_entry;
 	struct iface_stat *iface_entry;
 	struct tag_stat *new_tag_stat = NULL;
-	MT_DEBUG("qtaguid: if_tag_stat_update(ifname=%s "
-		"uid=%u sk=%p dir=%d proto=%d bytes=%d)\n",
-		 ifname, uid, sk, direction, proto, bytes);
-
 
 	iface_entry = get_iface_entry(ifname);
 	if (!iface_entry) {
-		pr_err("qtaguid: iface_stat: stat_update() %s not found\n",
-		       ifname);
 		return;
 	}
 	/* It is ok to process data when an iface_entry is inactive */
 
-	MT_DEBUG("qtaguid: iface_stat: stat_update() dev=%s entry=%p\n",
-		 ifname, iface_entry);
-
 	/*
 	 * Look for a tagged sock.
 	 * It will have an acct_uid.
@@ -1433,9 +1151,6 @@ static void if_tag_stat_update(const char *ifname, uid_t uid,
 		tag = combine_atag_with_uid(acct_tag, uid);
 		uid_tag = make_tag_from_uid(uid);
 	}
-	MT_DEBUG("qtaguid: iface_stat: stat_update(): "
-		 " looking for tag=0x%llx (uid=%u) in ife=%p\n",
-		 tag, get_uid_from_tag(tag), iface_entry);
 	/* Loop over tag list under this interface for {acct_tag,uid_tag} */
 	spin_lock_bh(&iface_entry->tag_stat_list_lock);
 
@@ -1492,10 +1207,6 @@ static int iface_netdev_event_handler(struct notifier_block *nb,
 	if (unlikely(module_passive))
 		return NOTIFY_DONE;
 
-	IF_DEBUG("qtaguid: iface_stat: netdev_event(): "
-		 "ev=0x%lx/%s netdev=%p->name=%s\n",
-		 event, netdev_evt_str(event), dev, dev ? dev->name : "");
-
 	switch (event) {
 	case NETDEV_UP:
 		iface_stat_create(dev, NULL);
@@ -1519,10 +1230,6 @@ static int iface_inet6addr_event_handler(struct notifier_block *nb,
 	if (unlikely(module_passive))
 		return NOTIFY_DONE;
 
-	IF_DEBUG("qtaguid: iface_stat: inet6addr_event(): "
-		 "ev=0x%lx/%s ifa=%p\n",
-		 event, netdev_evt_str(event), ifa);
-
 	switch (event) {
 	case NETDEV_UP:
 		BUG_ON(!ifa || !ifa->idev);
@@ -1550,10 +1257,6 @@ static int iface_inetaddr_event_handler(struct notifier_block *nb,
 	if (unlikely(module_passive))
 		return NOTIFY_DONE;
 
-	IF_DEBUG("qtaguid: iface_stat: inetaddr_event(): "
-		 "ev=0x%lx/%s ifa=%p\n",
-		 event, netdev_evt_str(event), ifa);
-
 	switch (event) {
 	case NETDEV_UP:
 		BUG_ON(!ifa || !ifa->ifa_dev);
@@ -1599,8 +1302,7 @@ static int __init iface_stat_init(struct proc_dir_entry *parent_procdir)
 						    proc_iface_perms,
 						    parent_procdir);
 	if (!iface_stat_all_procfile) {
-		pr_err("qtaguid: iface_stat: init "
-		       " failed to create stat_old proc entry\n");
+		pr_err("qtaguid: iface_stat: init failed to create stat_old proc entry\n");
 		err = -1;
 		goto err_zap_entry;
 	}
@@ -1611,32 +1313,27 @@ static int __init iface_stat_init(struct proc_dir_entry *parent_procdir)
 						    proc_iface_perms,
 						    parent_procdir);
 	if (!iface_stat_fmt_procfile) {
-		pr_err("qtaguid: iface_stat: init "
-		       " failed to create stat_all proc entry\n");
+		pr_err("qtaguid: iface_stat: init failed to create stat_all proc entry\n");
 		err = -1;
 		goto err_zap_all_stats_entry;
 	}
 	iface_stat_fmt_procfile->read_proc = iface_stat_fmt_proc_read;
 	iface_stat_fmt_procfile->data = (void *)2; /* fmt2 */
 
-
 	err = register_netdevice_notifier(&iface_netdev_notifier_blk);
 	if (err) {
-		pr_err("qtaguid: iface_stat: init "
-		       "failed to register dev event handler\n");
+		pr_err("qtaguid: iface_stat: init failed to register dev event handler\n");
 		goto err_zap_all_stats_entries;
 	}
 	err = register_inetaddr_notifier(&iface_inetaddr_notifier_blk);
 	if (err) {
-		pr_err("qtaguid: iface_stat: init "
-		       "failed to register ipv4 dev event handler\n");
+		pr_err("qtaguid: iface_stat: init failed to register ipv4 dev event handler\n");
 		goto err_unreg_nd;
 	}
 
 	err = register_inet6addr_notifier(&iface_inet6addr_notifier_blk);
 	if (err) {
-		pr_err("qtaguid: iface_stat: init "
-		       "failed to register ipv6 dev event handler\n");
+		pr_err("qtaguid: iface_stat: init failed to register ipv6 dev event handler\n");
 		goto err_unreg_ip4_addr;
 	}
 	return 0;
@@ -1661,9 +1358,6 @@ static struct sock *qtaguid_find_sk(const struct sk_buff *skb,
 	struct sock *sk;
 	unsigned int hook_mask = (1 << par->hooknum);
 
-	MT_DEBUG("qtaguid: find_sk(skb=%p) hooknum=%d family=%d\n", skb,
-		 par->hooknum, par->family);
-
 	/*
 	 * Let's not abuse the the xt_socket_get*_sk(), or else it will
 	 * return garbage SKs.
@@ -1688,8 +1382,6 @@ static struct sock *qtaguid_find_sk(const struct sk_buff *skb,
 	 * Not fixed in 3.0-r3 :(
 	 */
 	if (sk) {
-		MT_DEBUG("qtaguid: %p->sk_proto=%u "
-			 "->sk_state=%d\n", sk, sk->sk_protocol, sk->sk_state);
 		if (sk->sk_state  == TCP_TIME_WAIT) {
 			xt_socket_put_sk(sk);
 			sk = NULL;
@@ -1705,30 +1397,17 @@ static void account_for_uid(const struct sk_buff *skb,
 	const struct net_device *el_dev;
 
 	if (!skb->dev) {
-		MT_DEBUG("qtaguid[%d]: no skb->dev\n", par->hooknum);
 		el_dev = par->in ? : par->out;
 	} else {
 		const struct net_device *other_dev;
 		el_dev = skb->dev;
 		other_dev = par->in ? : par->out;
-		if (el_dev != other_dev) {
-			MT_DEBUG("qtaguid[%d]: skb->dev=%p %s vs "
-				"par->(in/out)=%p %s\n",
-				par->hooknum, el_dev, el_dev->name, other_dev,
-				other_dev->name);
-		}
 	}
 
 	if (unlikely(!el_dev)) {
-		pr_info("qtaguid[%d]: no par->in/out?!!\n", par->hooknum);
 	} else if (unlikely(!el_dev->name)) {
-		pr_info("qtaguid[%d]: no dev->name?!!\n", par->hooknum);
 	} else {
 		int proto = ipx_proto(skb, par);
-		MT_DEBUG("qtaguid[%d]: dev name=%s type=%d fam=%d proto=%d\n",
-			 par->hooknum, el_dev->name, el_dev->type,
-			 par->family, proto);
-
 		if_tag_stat_update(el_dev->name, uid,
 				skb->sk ? skb->sk : alternate_sk,
 				par->in ? IFS_RX : IFS_TX,
@@ -1748,9 +1427,6 @@ static bool qtaguid_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	if (unlikely(module_passive))
 		return (info->match ^ info->invert) == 0;
 
-	MT_DEBUG("qtaguid[%d]: entered skb=%p par->in=%p/out=%p fam=%d\n",
-		 par->hooknum, skb, par->in, par->out, par->family);
-
 	atomic64_inc(&qtu_events.match_calls);
 	if (skb == NULL) {
 		res = (info->match ^ info->invert) == 0;
@@ -1791,15 +1467,8 @@ static bool qtaguid_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	} else {
 		atomic64_inc(&qtu_events.match_found_sk);
 	}
-	MT_DEBUG("qtaguid[%d]: sk=%p got_sock=%d fam=%d proto=%d\n",
-		 par->hooknum, sk, got_sock, par->family, ipx_proto(skb, par));
 	if (sk != NULL) {
-		MT_DEBUG("qtaguid[%d]: sk=%p->sk_socket=%p->file=%p\n",
-			par->hooknum, sk, sk->sk_socket,
-			sk->sk_socket ? sk->sk_socket->file : (void *)-1LL);
 		filp = sk->sk_socket ? sk->sk_socket->file : NULL;
-		MT_DEBUG("qtaguid[%d]: filp...uid=%u\n",
-			par->hooknum, filp ? filp->f_cred->fsuid : -1);
 	}
 
 	if (sk == NULL || sk->sk_socket == NULL) {
@@ -1815,9 +1484,6 @@ static bool qtaguid_mt(const struct sk_buff *skb, struct xt_action_param *par)
 		 */
 		if (!(info->match & XT_QTAGUID_UID))
 			account_for_uid(skb, sk, 0, par);
-		MT_DEBUG("qtaguid[%d]: leaving (sk?sk->sk_socket)=%p\n",
-			par->hooknum,
-			sk ? sk->sk_socket : NULL);
 		res = (info->match ^ info->invert) == 0;
 		atomic64_inc(&qtu_events.match_no_sk);
 		goto put_sock_ret_res;
@@ -1827,7 +1493,6 @@ static bool qtaguid_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	}
 	filp = sk->sk_socket->file;
 	if (filp == NULL) {
-		MT_DEBUG("qtaguid[%d]: leaving filp=NULL\n", par->hooknum);
 		account_for_uid(skb, sk, 0, par);
 		res = ((info->match ^ info->invert) &
 			(XT_QTAGUID_UID | XT_QTAGUID_GID)) == 0;
@@ -1852,8 +1517,6 @@ static bool qtaguid_mt(const struct sk_buff *skb, struct xt_action_param *par)
 		if ((filp->f_cred->fsuid >= info->uid_min &&
 		     filp->f_cred->fsuid <= info->uid_max) ^
 		    !(info->invert & XT_QTAGUID_UID)) {
-			MT_DEBUG("qtaguid[%d]: leaving uid not matching\n",
-				 par->hooknum);
 			res = false;
 			goto put_sock_ret_res;
 		}
@@ -1861,67 +1524,19 @@ static bool qtaguid_mt(const struct sk_buff *skb, struct xt_action_param *par)
 		if ((filp->f_cred->fsgid >= info->gid_min &&
 				filp->f_cred->fsgid <= info->gid_max) ^
 			!(info->invert & XT_QTAGUID_GID)) {
-			MT_DEBUG("qtaguid[%d]: leaving gid not matching\n",
-				par->hooknum);
 			res = false;
 			goto put_sock_ret_res;
 		}
 
-	MT_DEBUG("qtaguid[%d]: leaving matched\n", par->hooknum);
 	res = true;
 
 put_sock_ret_res:
 	if (got_sock)
 		xt_socket_put_sk(sk);
 ret_res:
-	MT_DEBUG("qtaguid[%d]: left %d\n", par->hooknum, res);
 	return res;
 }
 
-#ifdef DDEBUG
-/* This function is not in xt_qtaguid_print.c because of locks visibility */
-static void prdebug_full_state(int indent_level, const char *fmt, ...)
-{
-	va_list args;
-	char *fmt_buff;
-	char *buff;
-
-	if (!unlikely(qtaguid_debug_mask & DDEBUG_MASK))
-		return;
-
-	fmt_buff = kasprintf(GFP_ATOMIC,
-			     "qtaguid: %s(): %s {\n", __func__, fmt);
-	BUG_ON(!fmt_buff);
-	va_start(args, fmt);
-	buff = kvasprintf(GFP_ATOMIC,
-			  fmt_buff, args);
-	BUG_ON(!buff);
-	pr_debug("%s", buff);
-	kfree(fmt_buff);
-	kfree(buff);
-	va_end(args);
-
-	spin_lock_bh(&sock_tag_list_lock);
-	prdebug_sock_tag_tree(indent_level, &sock_tag_tree);
-	spin_unlock_bh(&sock_tag_list_lock);
-
-	spin_lock_bh(&sock_tag_list_lock);
-	spin_lock_bh(&uid_tag_data_tree_lock);
-	prdebug_uid_tag_data_tree(indent_level, &uid_tag_data_tree);
-	prdebug_proc_qtu_data_tree(indent_level, &proc_qtu_data_tree);
-	spin_unlock_bh(&uid_tag_data_tree_lock);
-	spin_unlock_bh(&sock_tag_list_lock);
-
-	spin_lock_bh(&iface_stat_list_lock);
-	prdebug_iface_stat_list(indent_level, &iface_stat_list);
-	spin_unlock_bh(&iface_stat_list_lock);
-
-	pr_debug("qtaguid: %s(): }\n", __func__);
-}
-#else
-static void prdebug_full_state(int indent_level, const char *fmt, ...) {}
-#endif
-
 /*
  * Procfs reader to get all active socket tags using style "1)" as described in
  * fs/proc/generic.c
@@ -1936,7 +1551,6 @@ static int qtaguid_ctrl_proc_read(char *page, char **num_items_returned,
 	struct rb_node *node;
 	struct sock_tag *sock_tag_entry;
 	int item_index = 0;
-	int indent_level = 0;
 	long f_count;
 
 	if (unlikely(module_passive)) {
@@ -1947,11 +1561,6 @@ static int qtaguid_ctrl_proc_read(char *page, char **num_items_returned,
 	if (*eof)
 		return 0;
 
-	CT_DEBUG("qtaguid: proc ctrl pid=%u tgid=%u uid=%u "
-		 "page=%p off=%ld char_count=%d *eof=%d\n",
-		 current->pid, current->tgid, current_fsuid(),
-		 page, items_to_skip, char_count, *eof);
-
 	spin_lock_bh(&sock_tag_list_lock);
 	for (node = rb_first(&sock_tag_tree);
 	     node;
@@ -1960,13 +1569,6 @@ static int qtaguid_ctrl_proc_read(char *page, char **num_items_returned,
 			continue;
 		sock_tag_entry = rb_entry(node, struct sock_tag, sock_node);
 		uid = get_uid_from_tag(sock_tag_entry->tag);
-		CT_DEBUG("qtaguid: proc_read(): sk=%p tag=0x%llx (uid=%u) "
-			 "pid=%u\n",
-			 sock_tag_entry->sk,
-			 sock_tag_entry->tag,
-			 uid,
-			 sock_tag_entry->pid
-			);
 		f_count = atomic_long_read(
 			&sock_tag_entry->socket->file->f_count);
 		len = snprintf(outp, char_count,
@@ -2022,11 +1624,6 @@ static int qtaguid_ctrl_proc_read(char *page, char **num_items_returned,
 		(*num_items_returned)++;
 	}
 
-	/* Count the following as part of the last item_index */
-	if (item_index > items_to_skip) {
-		prdebug_full_state(indent_level, "proc ctrl");
-	}
-
 	*eof = 1;
 	return outp - page;
 }
@@ -2053,9 +1650,6 @@ static int ctrl_cmd_delete(const char *input)
 	struct uid_tag_data *utd_entry;
 
 	argc = sscanf(input, "%c %llu %u", &cmd, &acct_tag, &uid);
-	CT_DEBUG("qtaguid: ctrl_delete(%s): argc=%d cmd=%c "
-		 "user_tag=0x%llx uid=%u\n", input, argc, cmd,
-		 acct_tag, uid);
 	if (argc < 2) {
 		res = -EINVAL;
 		goto err;
@@ -2076,9 +1670,6 @@ static int ctrl_cmd_delete(const char *input)
 	}
 
 	tag = combine_atag_with_uid(acct_tag, uid);
-	CT_DEBUG("qtaguid: ctrl_delete(%s): "
-		 "looking for tag=0x%llx (uid=%u)\n",
-		 input, tag, uid);
 
 	/* Delete socket tags */
 	spin_lock_bh(&sock_tag_list_lock);
@@ -2090,9 +1681,6 @@ static int ctrl_cmd_delete(const char *input)
 		if (entry_uid != uid)
 			continue;
 
-		CT_DEBUG("qtaguid: ctrl_delete(%s): st tag=0x%llx (uid=%u)\n",
-			 input, st_entry->tag, entry_uid);
-
 		if (!acct_tag || st_entry->tag == tag) {
 			rb_erase(&st_entry->sock_node, &sock_tag_tree);
 			/* Can't sockfd_put() within spinlock, do it later. */
@@ -2120,12 +1708,6 @@ static int ctrl_cmd_delete(const char *input)
 	/* Counter sets are only on the uid tag, not full tag */
 	tcs_entry = tag_counter_set_tree_search(&tag_counter_set_tree, tag);
 	if (tcs_entry) {
-		CT_DEBUG("qtaguid: ctrl_delete(%s): "
-			 "erase tcs: tag=0x%llx (uid=%u) set=%d\n",
-			 input,
-			 tcs_entry->tn.tag,
-			 get_uid_from_tag(tcs_entry->tn.tag),
-			 tcs_entry->active_set);
 		rb_erase(&tcs_entry->tn.node, &tag_counter_set_tree);
 		kfree(tcs_entry);
 	}
@@ -2144,18 +1726,9 @@ static int ctrl_cmd_delete(const char *input)
 			entry_uid = get_uid_from_tag(ts_entry->tn.tag);
 			node = rb_next(node);
 
-			CT_DEBUG("qtaguid: ctrl_delete(%s): "
-				 "ts tag=0x%llx (uid=%u)\n",
-				 input, ts_entry->tn.tag, entry_uid);
-
 			if (entry_uid != uid)
 				continue;
 			if (!acct_tag || ts_entry->tn.tag == tag) {
-				CT_DEBUG("qtaguid: ctrl_delete(%s): "
-					 "erase ts: %s 0x%llx %u\n",
-					 input, iface_entry->ifname,
-					 get_atag_from_tag(ts_entry->tn.tag),
-					 entry_uid);
 				rb_erase(&ts_entry->tn.node,
 					 &iface_entry->tag_stat_tree);
 				kfree(ts_entry);
@@ -2173,10 +1746,6 @@ static int ctrl_cmd_delete(const char *input)
 		entry_uid = utd_entry->uid;
 		node = rb_next(node);
 
-		CT_DEBUG("qtaguid: ctrl_delete(%s): "
-			 "utd uid=%u\n",
-			 input, entry_uid);
-
 		if (entry_uid != uid)
 			continue;
 		/*
@@ -2205,16 +1774,12 @@ static int ctrl_cmd_counter_set(const char *input)
 	int counter_set;
 
 	argc = sscanf(input, "%c %d %u", &cmd, &counter_set, &uid);
-	CT_DEBUG("qtaguid: ctrl_counterset(%s): argc=%d cmd=%c "
-		 "set=%d uid=%u\n", input, argc, cmd,
-		 counter_set, uid);
 	if (argc != 3) {
 		res = -EINVAL;
 		goto err;
 	}
 	if (counter_set < 0 || counter_set >= IFS_MAX_COUNTER_SETS) {
-		pr_info("qtaguid: ctrl_counterset(%s): invalid counter_set range\n",
-			input);
+		pr_info("qtaguid: ctrl_counterset(%s): invalid counter_set range\n", input);
 		res = -EINVAL;
 		goto err;
 	}
@@ -2233,17 +1798,12 @@ static int ctrl_cmd_counter_set(const char *input)
 		tcs = kzalloc(sizeof(*tcs), GFP_ATOMIC);
 		if (!tcs) {
 			spin_unlock_bh(&tag_counter_set_list_lock);
-			pr_err("qtaguid: ctrl_counterset(%s): "
-			       "failed to alloc counter set\n",
-			       input);
+			pr_err("qtaguid: ctrl_counterset(%s): failed to alloc counter set\n", input);
 			res = -ENOMEM;
 			goto err;
 		}
 		tcs->tn.tag = tag;
 		tag_counter_set_tree_insert(tcs, &tag_counter_set_tree);
-		CT_DEBUG("qtaguid: ctrl_counterset(%s): added tcs tag=0x%llx "
-			 "(uid=%u) set=%d\n",
-			 input, tag, get_uid_from_tag(tag), counter_set);
 	}
 	tcs->active_set = counter_set;
 	spin_unlock_bh(&tag_counter_set_list_lock);
@@ -2270,44 +1830,23 @@ static int ctrl_cmd_tag(const char *input)
 
 	/* Unassigned args will get defaulted later. */
 	argc = sscanf(input, "%c %d %llu %u", &cmd, &sock_fd, &acct_tag, &uid);
-	CT_DEBUG("qtaguid: ctrl_tag(%s): argc=%d cmd=%c sock_fd=%d "
-		 "acct_tag=0x%llx uid=%u\n", input, argc, cmd, sock_fd,
-		 acct_tag, uid);
 	if (argc < 2) {
 		res = -EINVAL;
 		goto err;
 	}
 	el_socket = sockfd_lookup(sock_fd, &res);  /* This locks the file */
 	if (!el_socket) {
-		pr_info("qtaguid: ctrl_tag(%s): failed to lookup"
-			" sock_fd=%d err=%d pid=%u tgid=%u uid=%u\n",
-			input, sock_fd, res, current->pid, current->tgid,
-			current_fsuid());
 		goto err;
 	}
-	CT_DEBUG("qtaguid: ctrl_tag(%s): socket->...->f_count=%ld ->sk=%p\n",
-		 input, atomic_long_read(&el_socket->file->f_count),
-		 el_socket->sk);
 	if (argc < 3) {
 		acct_tag = make_atag_from_value(0);
 	} else if (!valid_atag(acct_tag)) {
-		pr_info("qtaguid: ctrl_tag(%s): invalid tag\n", input);
 		res = -EINVAL;
 		goto err_put;
 	}
-	CT_DEBUG("qtaguid: ctrl_tag(%s): "
-		 "pid=%u tgid=%u uid=%u euid=%u fsuid=%u "
-		 "in_group=%d in_egroup=%d\n",
-		 input, current->pid, current->tgid, current_uid(),
-		 current_euid(), current_fsuid(),
-		 in_group_p(proc_ctrl_write_gid),
-		 in_egroup_p(proc_ctrl_write_gid));
 	if (argc < 4) {
 		uid = current_fsuid();
 	} else if (!can_impersonate_uid(uid)) {
-		pr_info("qtaguid: ctrl_tag(%s): "
-			"insufficient priv from pid=%u tgid=%u uid=%u\n",
-			input, current->pid, current->tgid, current_fsuid());
 		res = -EPERM;
 		goto err_put;
 	}
@@ -2325,10 +1864,6 @@ static int ctrl_cmd_tag(const char *input)
 	if (sock_tag_entry) {
 		struct tag_ref *prev_tag_ref_entry;
 
-		CT_DEBUG("qtaguid: ctrl_tag(%s): retag for sk=%p "
-			 "st@%p ...->f_count=%ld\n",
-			 input, el_socket->sk, sock_tag_entry,
-			 atomic_long_read(&el_socket->file->f_count));
 		/*
 		 * This is a re-tagging, so release the sock_fd that was
 		 * locked at the time of the 1st tagging.
@@ -2343,14 +1878,10 @@ static int ctrl_cmd_tag(const char *input)
 		prev_tag_ref_entry->num_sock_tags--;
 		sock_tag_entry->tag = full_tag;
 	} else {
-		CT_DEBUG("qtaguid: ctrl_tag(%s): newtag for sk=%p\n",
-			 input, el_socket->sk);
 		sock_tag_entry = kzalloc(sizeof(*sock_tag_entry),
 					 GFP_ATOMIC);
 		if (!sock_tag_entry) {
-			pr_err("qtaguid: ctrl_tag(%s): "
-			       "socket tag alloc failed\n",
-			       input);
+			pr_err("qtaguid: ctrl_tag(%s): socket tag alloc failed\n", input);
 			spin_unlock_bh(&sock_tag_list_lock);
 			res = -ENOMEM;
 			goto err_tag_unref_put;
@@ -2385,9 +1916,6 @@ static int ctrl_cmd_tag(const char *input)
 	}
 	spin_unlock_bh(&sock_tag_list_lock);
 	/* We keep the ref to the socket (file) until it is untagged */
-	CT_DEBUG("qtaguid: ctrl_tag(%s): done st@%p ...->f_count=%ld\n",
-		 input, sock_tag_entry,
-		 atomic_long_read(&el_socket->file->f_count));
 	return 0;
 
 err_tag_unref_put:
@@ -2395,14 +1923,11 @@ err_tag_unref_put:
 	tag_ref_entry->num_sock_tags--;
 	free_tag_ref_from_utd_entry(tag_ref_entry, uid_tag_data_entry);
 err_put:
-	CT_DEBUG("qtaguid: ctrl_tag(%s): done. ...->f_count=%ld\n",
-		 input, atomic_long_read(&el_socket->file->f_count) - 1);
 	/* Release the sock_fd that was grabbed by sockfd_lookup(). */
 	sockfd_put(el_socket);
 	return res;
 
 err:
-	CT_DEBUG("qtaguid: ctrl_tag(%s): done.\n", input);
 	return res;
 }
 
@@ -2418,23 +1943,14 @@ static int ctrl_cmd_untag(const char *input)
 	struct proc_qtu_data *pqd_entry;
 
 	argc = sscanf(input, "%c %d", &cmd, &sock_fd);
-	CT_DEBUG("qtaguid: ctrl_untag(%s): argc=%d cmd=%c sock_fd=%d\n",
-		 input, argc, cmd, sock_fd);
 	if (argc < 2) {
 		res = -EINVAL;
 		goto err;
 	}
 	el_socket = sockfd_lookup(sock_fd, &res);  /* This locks the file */
 	if (!el_socket) {
-		pr_info("qtaguid: ctrl_untag(%s): failed to lookup"
-			" sock_fd=%d err=%d pid=%u tgid=%u uid=%u\n",
-			input, sock_fd, res, current->pid, current->tgid,
-			current_fsuid());
 		goto err;
 	}
-	CT_DEBUG("qtaguid: ctrl_untag(%s): socket->...->f_count=%ld ->sk=%p\n",
-		 input, atomic_long_read(&el_socket->file->f_count),
-		 el_socket->sk);
 	spin_lock_bh(&sock_tag_list_lock);
 	sock_tag_entry = get_sock_stat_nl(el_socket->sk);
 	if (!sock_tag_entry) {
@@ -2478,9 +1994,6 @@ static int ctrl_cmd_untag(const char *input)
 	 * and once more for the sockfd_lookup() here.
 	 */
 	sockfd_put(sock_tag_entry->socket);
-	CT_DEBUG("qtaguid: ctrl_untag(%s): done. st@%p ...->f_count=%ld\n",
-		 input, sock_tag_entry,
-		 atomic_long_read(&el_socket->file->f_count) - 1);
 	sockfd_put(el_socket);
 
 	kfree(sock_tag_entry);
@@ -2489,14 +2002,11 @@ static int ctrl_cmd_untag(const char *input)
 	return 0;
 
 err_put:
-	CT_DEBUG("qtaguid: ctrl_untag(%s): done. socket->...->f_count=%ld\n",
-		 input, atomic_long_read(&el_socket->file->f_count) - 1);
 	/* Release the sock_fd that was grabbed by sockfd_lookup(). */
 	sockfd_put(el_socket);
 	return res;
 
 err:
-	CT_DEBUG("qtaguid: ctrl_untag(%s): done.\n", input);
 	return res;
 }
 
@@ -2505,9 +2015,6 @@ static int qtaguid_ctrl_parse(const char *input, int count)
 	char cmd;
 	int res;
 
-	CT_DEBUG("qtaguid: ctrl(%s): pid=%u tgid=%u uid=%u\n",
-		 input, current->pid, current->tgid, current_fsuid());
-
 	cmd = input[0];
 	/* Collect params for commands */
 	switch (cmd) {
@@ -2534,7 +2041,6 @@ static int qtaguid_ctrl_parse(const char *input, int count)
 	if (!res)
 		res = count;
 err:
-	CT_DEBUG("qtaguid: ctrl(%s): res=%d\n", input, res);
 	return res;
 }
 
@@ -2590,12 +2096,6 @@ static int pp_stats_line(struct proc_print_info *ppi, int cnt_set)
 		uid_t stat_uid = get_uid_from_tag(tag);
 
 		if (!can_read_other_uid_stats(stat_uid)) {
-			CT_DEBUG("qtaguid: stats line: "
-				 "%s 0x%llx %u: insufficient priv "
-				 "from pid=%u tgid=%u uid=%u\n",
-				 ppi->iface_entry->ifname,
-				 get_atag_from_tag(tag), stat_uid,
-				 current->pid, current->tgid, current_fsuid());
 			return 0;
 		}
 		if (ppi->item_index++ < ppi->items_to_skip)
@@ -2684,13 +2184,6 @@ static int qtaguid_stats_proc_read(char *page, char **num_items_returned,
 		return len;
 	}
 
-	CT_DEBUG("qtaguid:proc stats pid=%u tgid=%u uid=%u "
-		 "page=%p *num_items_returned=%p off=%ld "
-		 "char_count=%d *eof=%d\n",
-		 current->pid, current->tgid, current_fsuid(),
-		 page, *num_items_returned,
-		 items_to_skip, char_count, *eof);
-
 	if (*eof)
 		return 0;
 
@@ -2742,9 +2235,6 @@ static int qtudev_open(struct inode *inode, struct file *file)
 	if (unlikely(qtu_proc_handling_passive))
 		return 0;
 
-	DR_DEBUG("qtaguid: qtudev_open(): pid=%u tgid=%u uid=%u\n",
-		 current->pid, current->tgid, current_fsuid());
-
 	spin_lock_bh(&uid_tag_data_tree_lock);
 
 	/* Look for existing uid data, or alloc one. */
@@ -2783,8 +2273,6 @@ static int qtudev_open(struct inode *inode, struct file *file)
 				  &proc_qtu_data_tree);
 
 	spin_unlock_bh(&uid_tag_data_tree_lock);
-	DR_DEBUG("qtaguid: tracking data for uid=%u in pqd=%p\n",
-		 current_fsuid(), new_pqd_entry);
 	file->private_data = new_pqd_entry;
 	return 0;
 
@@ -2814,32 +2302,16 @@ static int qtudev_release(struct inode *inode, struct file *file)
 	 * Do not trust the current->pid, it might just be a kworker cleaning
 	 * up after a dead proc.
 	 */
-	DR_DEBUG("qtaguid: qtudev_release(): "
-		 "pid=%u tgid=%u uid=%u "
-		 "pqd_entry=%p->pid=%u utd_entry=%p->active_tags=%d\n",
-		 current->pid, current->tgid, pqd_entry->parent_tag_data->uid,
-		 pqd_entry, pqd_entry->pid, utd_entry,
-		 utd_entry->num_active_tags);
-
 	spin_lock_bh(&sock_tag_list_lock);
 	spin_lock_bh(&uid_tag_data_tree_lock);
 
 	list_for_each_safe(entry, next, &pqd_entry->sock_tag_list) {
 		st_entry = list_entry(entry, struct sock_tag, list);
-		DR_DEBUG("qtaguid: %s(): "
-			 "erase sock_tag=%p->sk=%p pid=%u tgid=%u uid=%u\n",
-			 __func__,
-			 st_entry, st_entry->sk,
-			 current->pid, current->tgid,
-			 pqd_entry->parent_tag_data->uid);
 
 		utd_entry = uid_tag_data_tree_search(
 			&uid_tag_data_tree,
 			get_uid_from_tag(st_entry->tag));
 		BUG_ON(IS_ERR_OR_NULL(utd_entry));
-		DR_DEBUG("qtaguid: %s(): "
-			 "looking for tag=0x%llx in utd_entry=%p\n", __func__,
-			 st_entry->tag, utd_entry);
 		tr = tag_ref_tree_search(&utd_entry->tag_ref_tree,
 					 st_entry->tag);
 		BUG_ON(!tr);
@@ -2870,11 +2342,8 @@ static int qtudev_release(struct inode *inode, struct file *file)
 	spin_unlock_bh(&uid_tag_data_tree_lock);
 	spin_unlock_bh(&sock_tag_list_lock);
 
-
 	sock_tag_tree_erase(&st_to_free_tree);
 
-	prdebug_full_state(0, "%s(): pid=%u tgid=%u", __func__,
-			   current->pid, current->tgid);
 	return 0;
 }
 
@@ -2906,8 +2375,7 @@ static int __init qtaguid_proc_register(struct proc_dir_entry **res_procdir)
 	xt_qtaguid_ctrl_file = create_proc_entry("ctrl", proc_ctrl_perms,
 						*res_procdir);
 	if (!xt_qtaguid_ctrl_file) {
-		pr_err("qtaguid: failed to create xt_qtaguid/ctrl "
-			" file\n");
+		pr_err("qtaguid: failed to create xt_qtaguid/ctrl file\n");
 		ret = -ENOMEM;
 		goto no_ctrl_entry;
 	}
@@ -2917,8 +2385,7 @@ static int __init qtaguid_proc_register(struct proc_dir_entry **res_procdir)
 	xt_qtaguid_stats_file = create_proc_entry("stats", proc_stats_perms,
 						*res_procdir);
 	if (!xt_qtaguid_stats_file) {
-		pr_err("qtaguid: failed to create xt_qtaguid/stats "
-			"file\n");
+		pr_err("qtaguid: failed to create xt_qtaguid/stats file\n");
 		ret = -ENOMEM;
 		goto no_stats_entry;
 	}
diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c
index 874f8ff..c9b0bb2 100644
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@ -134,7 +134,6 @@ int genl_register_mc_group(struct genl_family *family,
 	int err = 0;
 
 	BUG_ON(grp->name[0] == '\0');
-	BUG_ON(memchr(grp->name, '\0', GENL_NAMSIZ) == NULL);
 
 	genl_lock();
 
@@ -145,7 +144,6 @@ int genl_register_mc_group(struct genl_family *family,
 		id = find_first_zero_bit(mc_groups,
 					 mc_groups_longs * BITS_PER_LONG);
 
-
 	if (id >= mc_groups_longs * BITS_PER_LONG) {
 		size_t nlen = (mc_groups_longs + 1) * sizeof(unsigned long);
 
diff --git a/net/rfkill/core.c b/net/rfkill/core.c
index df2dae6..f91362d 100644
--- a/net/rfkill/core.c
+++ b/net/rfkill/core.c
@@ -90,13 +90,11 @@ struct rfkill_data {
 	bool			input_handler;
 };
 
-
 MODULE_AUTHOR("Ivo van Doorn <IvDoorn@gmail.com>");
 MODULE_AUTHOR("Johannes Berg <johannes@sipsolutions.net>");
 MODULE_DESCRIPTION("RF switch support");
 MODULE_LICENSE("GPL");
 
-
 /*
  * The locking here should be made much smarter, we currently have
  * a bit of a stupid situation because drivers might want to register
@@ -123,7 +121,6 @@ static struct {
 
 static bool rfkill_epo_lock_active;
 
-
 #ifdef CONFIG_RFKILL_LEDS
 static void rfkill_led_trigger_event(struct rfkill *rfkill)
 {
@@ -226,8 +223,6 @@ static bool __rfkill_set_hw_state(struct rfkill *rfkill,
 	unsigned long flags;
 	bool prev, any;
 
-	BUG_ON(!rfkill);
-
 	spin_lock_irqsave(&rfkill->lock, flags);
 	prev = !!(rfkill->state & RFKILL_BLOCK_HW);
 	if (blocked)
@@ -450,7 +445,6 @@ bool rfkill_get_global_sw_state(const enum rfkill_type type)
 }
 #endif
 
-
 bool rfkill_set_hw_state(struct rfkill *rfkill, bool blocked)
 {
 	bool ret, change;
@@ -486,8 +480,6 @@ bool rfkill_set_sw_state(struct rfkill *rfkill, bool blocked)
 	unsigned long flags;
 	bool prev, hwblock;
 
-	BUG_ON(!rfkill);
-
 	spin_lock_irqsave(&rfkill->lock, flags);
 	prev = !!(rfkill->state & RFKILL_BLOCK_SW);
 	__rfkill_set_sw_state(rfkill, blocked);
@@ -511,9 +503,6 @@ void rfkill_init_sw_state(struct rfkill *rfkill, bool blocked)
 {
 	unsigned long flags;
 
-	BUG_ON(!rfkill);
-	BUG_ON(rfkill->registered);
-
 	spin_lock_irqsave(&rfkill->lock, flags);
 	__rfkill_set_sw_state(rfkill, blocked);
 	rfkill->persistent = true;
@@ -526,8 +515,6 @@ void rfkill_set_states(struct rfkill *rfkill, bool sw, bool hw)
 	unsigned long flags;
 	bool swprev, hwprev;
 
-	BUG_ON(!rfkill);
-
 	spin_lock_irqsave(&rfkill->lock, flags);
 
 	/*
@@ -830,7 +817,6 @@ bool rfkill_blocked(struct rfkill *rfkill)
 }
 EXPORT_SYMBOL(rfkill_blocked);
 
-
 struct rfkill * __must_check rfkill_alloc(const char *name,
 					  struct device *parent,
 					  const enum rfkill_type type,
diff --git a/net/sunrpc/xdr.c b/net/sunrpc/xdr.c
index 671e482..30fdbc1 100644
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@ -878,7 +878,7 @@ static void __read_bytes_from_xdr_buf(struct xdr_buf *subbuf, void *obj, unsigne
 /* obj is assumed to point to allocated memory of size at least len: */
 int read_bytes_from_xdr_buf(struct xdr_buf *buf, unsigned int base, void *obj, unsigned int len)
 {
-	struct xdr_buf subbuf;
+	struct xdr_buf subbuf = {.pages=NULL};
 	int status;
 
 	status = xdr_buf_subsegment(buf, &subbuf, base, len);
@@ -909,7 +909,7 @@ static void __write_bytes_to_xdr_buf(struct xdr_buf *subbuf, void *obj, unsigned
 /* obj is assumed to point to allocated memory of size at least len: */
 int write_bytes_to_xdr_buf(struct xdr_buf *buf, unsigned int base, void *obj, unsigned int len)
 {
-	struct xdr_buf subbuf;
+	struct xdr_buf subbuf = {.pages=NULL};
 	int status;
 
 	status = xdr_buf_subsegment(buf, &subbuf, base, len);
@@ -949,7 +949,7 @@ EXPORT_SYMBOL_GPL(xdr_encode_word);
  * set obj to point to it. */
 int xdr_buf_read_netobj(struct xdr_buf *buf, struct xdr_netobj *obj, unsigned int offset)
 {
-	struct xdr_buf subbuf;
+	struct xdr_buf subbuf = {.pages=NULL};
 
 	if (xdr_decode_word(buf, offset, &obj->len))
 		return -EFAULT;
@@ -1265,4 +1265,3 @@ out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(xdr_process_buf);
-
diff --git a/net/wanrouter/wanmain.c b/net/wanrouter/wanmain.c
index 2ab7850..a5109c8 100644
--- a/net/wanrouter/wanmain.c
+++ b/net/wanrouter/wanmain.c
@@ -91,8 +91,6 @@ static void lock_adapter_irq(spinlock_t *lock, unsigned long *smp_flags)
 static void unlock_adapter_irq(spinlock_t *lock, unsigned long *smp_flags)
 	__releases(lock);
 
-
-
 /*
  *	Global Data
  */
@@ -160,7 +158,6 @@ module_exit(wanrouter_cleanup);
  * 	Context:	process
  */
 
-
 int register_wan_device(struct wan_device *wandev)
 {
 	int err, namelen;
@@ -216,7 +213,6 @@ int register_wan_device(struct wan_device *wandev)
  *	Context:	process
  */
 
-
 int unregister_wan_device(char *name)
 {
 	struct wan_device *wandev, *prev;
@@ -260,7 +256,6 @@ int unregister_wan_device(char *name)
  *	1. This function may be called on interrupt context.
  */
 
-
 int wanrouter_encapsulate(struct sk_buff *skb, struct net_device *dev,
 			  unsigned short type)
 {
@@ -293,7 +288,6 @@ int wanrouter_encapsulate(struct sk_buff *skb, struct net_device *dev,
 	return hdr_len;
 }
 
-
 /*
  *	Decapsulate packet.
  *
@@ -304,7 +298,6 @@ int wanrouter_encapsulate(struct sk_buff *skb, struct net_device *dev,
  *	1. This function may be called on interrupt context.
  */
 
-
 __be16 wanrouter_type_trans(struct sk_buff *skb, struct net_device *dev)
 {
 	int cnt = skb->data[0] ? 0 : 1;	/* there may be a pad present */
@@ -602,11 +595,6 @@ static int wanrouter_device_new_if(struct wan_device *wandev,
 		 * successfully, add it to the interface list.
 		 */
 
-#ifdef WANDEBUG
-		printk(KERN_INFO "%s: registering interface %s...\n",
-		       wanrouter_modname, dev->name);
-#endif
-
 		err = register_netdev(dev);
 		if (!err) {
 			struct net_device *slave = NULL;
@@ -638,7 +626,6 @@ out:
 	return err;
 }
 
-
 /*
  *	Delete WAN logical channel.
  *	 o verify user address space
@@ -765,7 +752,6 @@ static void lock_adapter_irq(spinlock_t *lock, unsigned long *smp_flags)
 	spin_lock_irqsave(lock, *smp_flags);
 }
 
-
 static void unlock_adapter_irq(spinlock_t *lock, unsigned long *smp_flags)
 	__releases(lock)
 {
diff --git a/scripts/kconfig/lxdialog/textbox.c b/scripts/kconfig/lxdialog/textbox.c
index c704712..70aa180 100644
--- a/scripts/kconfig/lxdialog/textbox.c
+++ b/scripts/kconfig/lxdialog/textbox.c
@@ -44,7 +44,6 @@ static void refresh_text_box(WINDOW *dialog, WINDOW *box, int boxh, int boxw,
 	wrefresh(dialog);
 }
 
-
 /*
  * Display text from a file in a dialog box.
  */
@@ -320,9 +319,12 @@ static void print_page(WINDOW * win, int height, int width)
  */
 static void print_line(WINDOW * win, int row, int width)
 {
-	int y, x;
+	int y=0, x=0;
 	char *line;
 
+	y=x;
+	x=y;
+
 	line = get_line();
 	line += MIN(strlen(line), hscroll);	/* Scroll horizontally */
 	wmove(win, row, 0);	/* move cursor to correct line */
diff --git a/security/selinux/Kconfig b/security/selinux/Kconfig
index bca1b74..f55f6e1 100644
--- a/security/selinux/Kconfig
+++ b/security/selinux/Kconfig
@@ -130,4 +130,3 @@ config SECURITY_SELINUX_POLICYDB_VERSION_MAX_VALUE
 	  running 'checkpolicy -V'. Or look at what policy you have
 	  installed under /etc/selinux/$SELINUXTYPE/policy, where
 	  SELINUXTYPE is defined in your /etc/selinux/config.
-
diff --git a/security/selinux/avc.c b/security/selinux/avc.c
index d515b21..0f96793 100644
--- a/security/selinux/avc.c
+++ b/security/selinux/avc.c
@@ -552,7 +552,7 @@ int avc_audit(u32 ssid, u32 tsid,
  * @perms: permissions
  *
  * Register a callback function for events in the set @events
- * related to the SID pair (@ssid, @tsid) 
+ * related to the SID pair (@ssid, @tsid)
  * and the permissions @perms, interpreting
  * @perms based on @tclass.  Returns %0 on success or
  * -%ENOMEM if insufficient memory exists to add the callback.
diff --git a/sound/Kconfig b/sound/Kconfig
index 409d060..c6af2dc 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -75,12 +75,6 @@ source "sound/core/Kconfig"
 
 source "sound/drivers/Kconfig"
 
-source "sound/isa/Kconfig"
-
-source "sound/pci/Kconfig"
-
-source "sound/ppc/Kconfig"
-
 source "sound/aoa/Kconfig"
 
 source "sound/arm/Kconfig"
@@ -89,8 +83,6 @@ source "sound/atmel/Kconfig"
 
 source "sound/spi/Kconfig"
 
-source "sound/mips/Kconfig"
-
 source "sound/sh/Kconfig"
 
 # the following will depend on the order of config.
@@ -99,14 +91,6 @@ source "sound/usb/Kconfig"
 
 source "sound/firewire/Kconfig"
 
-# the following will depend on the order of config.
-# here assuming PCMCIA is defined before ALSA
-source "sound/pcmcia/Kconfig"
-
-source "sound/sparc/Kconfig"
-
-source "sound/parisc/Kconfig"
-
 source "sound/soc/Kconfig"
 
 endif # SND
diff --git a/sound/Makefile b/sound/Makefile
index ce9132b..1ebd865 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -5,8 +5,8 @@ obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_SOUND_PRIME) += sound_firmware.o
 obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
-obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
-	firewire/ sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/
+obj-$(CONFIG_SND) += core/ i2c/ drivers/  arm/ sh/ synth/ usb/ \
+	firewire/ spi/ soc/ atmel/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --git a/sound/core/device.c b/sound/core/device.c
index 2d1ad4b..8251d85 100644
--- a/sound/core/device.c
+++ b/sound/core/device.c
@@ -78,7 +78,7 @@ EXPORT_SYMBOL(snd_device_new);
 int snd_device_free(struct snd_card *card, void *device_data)
 {
 	struct snd_device *dev;
-	
+
 	if (snd_BUG_ON(!card || !device_data))
 		return -ENXIO;
 	list_for_each_entry(dev, &card->devices, list) {
@@ -98,8 +98,6 @@ int snd_device_free(struct snd_card *card, void *device_data)
 		kfree(dev);
 		return 0;
 	}
-	snd_printd("device free %p (from %pF), not found\n", device_data,
-		   __builtin_return_address(0));
 	return -ENXIO;
 }
 
@@ -135,8 +133,6 @@ int snd_device_disconnect(struct snd_card *card, void *device_data)
 		}
 		return 0;
 	}
-	snd_printd("device disconnect %p (from %pF), not found\n", device_data,
-		   __builtin_return_address(0));
 	return -ENXIO;
 }
 
@@ -169,7 +165,6 @@ int snd_device_register(struct snd_card *card, void *device_data)
 			dev->state = SNDRV_DEV_REGISTERED;
 			return 0;
 		}
-		snd_printd("snd_device_register busy\n");
 		return -EBUSY;
 	}
 	snd_BUG();
@@ -186,7 +181,7 @@ int snd_device_register_all(struct snd_card *card)
 {
 	struct snd_device *dev;
 	int err;
-	
+
 	if (snd_BUG_ON(!card))
 		return -ENXIO;
 	list_for_each_entry(dev, &card->devices, list) {
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 2eb4d3c..e18bdfb 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -321,10 +321,6 @@ static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,
 			char name[16];
 			pcm_debug_name(substream, name, sizeof(name));
 			xrun_log_show(substream);
-			snd_printd(KERN_ERR  "BUG: %s, pos = %ld, "
-				   "buffer size = %ld, period size = %ld\n",
-				   name, pos, runtime->buffer_size,
-				   runtime->period_size);
 		}
 		pos = 0;
 	}
diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c
index cd2c134..aab8a0c 100644
--- a/sound/core/rawmidi.c
+++ b/sound/core/rawmidi.c
@@ -373,7 +373,7 @@ static int snd_rawmidi_open(struct inode *inode, struct file *file)
 	wait_queue_t wait;
 	struct snd_ctl_file *kctl;
 
-	if ((file->f_flags & O_APPEND) && !(file->f_flags & O_NONBLOCK)) 
+	if ((file->f_flags & O_APPEND) && !(file->f_flags & O_NONBLOCK))
 		return -EINVAL;		/* invalid combination */
 
 	err = nonseekable_open(inode, file);
@@ -532,7 +532,7 @@ int snd_rawmidi_kernel_release(struct snd_rawmidi_file *rfile)
 
 	if (snd_BUG_ON(!rfile))
 		return -ENXIO;
-	
+
 	rmidi = rfile->rmidi;
 	rawmidi_release_priv(rfile);
 	module_put(rmidi->card->module);
@@ -559,7 +559,7 @@ static int snd_rawmidi_info(struct snd_rawmidi_substream *substream,
 			    struct snd_rawmidi_info *info)
 {
 	struct snd_rawmidi *rmidi;
-	
+
 	if (substream == NULL)
 		return -ENODEV;
 	rmidi = substream->rmidi;
@@ -638,7 +638,7 @@ int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,
 {
 	char *newbuf;
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
-	
+
 	if (substream->append && substream->use_count > 1)
 		return -EBUSY;
 	snd_rawmidi_drain_output(substream);
@@ -836,7 +836,7 @@ static int snd_rawmidi_control_ioctl(struct snd_card *card,
 	case SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE:
 	{
 		int device;
-		
+
 		if (get_user(device, (int __user *)argp))
 			return -EFAULT;
 		if (device >= SNDRV_RAWMIDI_DEVICES) /* next device is -1 */
@@ -858,7 +858,7 @@ static int snd_rawmidi_control_ioctl(struct snd_card *card,
 	case SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE:
 	{
 		int val;
-		
+
 		if (get_user(val, (int __user *)argp))
 			return -EFAULT;
 		control->prefer_rawmidi_subdevice = val;
@@ -890,7 +890,6 @@ int snd_rawmidi_receive(struct snd_rawmidi_substream *substream,
 	if (!substream->opened)
 		return -EBADFD;
 	if (runtime->buffer == NULL) {
-		snd_printd("snd_rawmidi_receive: input is not active!!!\n");
 		return -EINVAL;
 	}
 	spin_lock_irqsave(&runtime->lock, flags);
@@ -1039,7 +1038,7 @@ static ssize_t snd_rawmidi_read(struct file *file, char __user *buf, size_t coun
 /**
  * snd_rawmidi_transmit_empty - check whether the output buffer is empty
  * @substream: the rawmidi substream
- * 
+ *
  * Returns 1 if the internal output buffer is empty, 0 if not.
  */
 int snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream)
@@ -1049,13 +1048,12 @@ int snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream)
 	unsigned long flags;
 
 	if (runtime->buffer == NULL) {
-		snd_printd("snd_rawmidi_transmit_empty: output is not active!!!\n");
 		return 1;
 	}
 	spin_lock_irqsave(&runtime->lock, flags);
 	result = runtime->avail >= runtime->buffer_size;
 	spin_unlock_irqrestore(&runtime->lock, flags);
-	return result;		
+	return result;
 }
 
 /**
@@ -1080,7 +1078,6 @@ int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 
 	if (runtime->buffer == NULL) {
-		snd_printd("snd_rawmidi_transmit_peek: output is not active!!!\n");
 		return -EINVAL;
 	}
 	result = 0;
@@ -1130,7 +1127,6 @@ int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
 
 	if (runtime->buffer == NULL) {
-		snd_printd("snd_rawmidi_transmit_ack: output is not active!!!\n");
 		return -EINVAL;
 	}
 	spin_lock_irqsave(&runtime->lock, flags);
diff --git a/sound/core/sound.c b/sound/core/sound.c
index e9b79b5..2d99e1c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -473,9 +473,6 @@ static int __init alsa_sound_init(void)
 		return -ENOMEM;
 	}
 	snd_info_minor_register();
-#ifndef MODULE
-	printk(KERN_INFO "Advanced Linux Sound Architecture Driver Version " CONFIG_SND_VERSION CONFIG_SND_DATE ".\n");
-#endif
 	return 0;
 }
 
diff --git a/sound/core/timer.c b/sound/core/timer.c
index 950eed0..63dd56a 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -239,7 +239,6 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		/* open a slave instance */
 		if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||
 		    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {
-			snd_printd("invalid slave class %i\n", tid->dev_sclass);
 			return -EINVAL;
 		}
 		mutex_lock(&register_mutex);
diff --git a/sound/soc/codecs/omap-hdmi-codec.c b/sound/soc/codecs/omap-hdmi-codec.c
index 6d4a56f..e7c666a 100644
--- a/sound/soc/codecs/omap-hdmi-codec.c
+++ b/sound/soc/codecs/omap-hdmi-codec.c
@@ -16,7 +16,6 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
- *
  */
 
 #include <linux/module.h>
@@ -55,7 +54,6 @@ struct hdmi_params {
 	int channels_nr;
 };
 
-
 /* codec private data */
 struct hdmi_codec_data {
 	struct hdmi_audio_format audio_fmt;
@@ -72,7 +70,6 @@ struct hdmi_codec_data {
 	int active;
 } hdmi_data;
 
-
 static int hdmi_audio_set_configuration(struct hdmi_codec_data *priv)
 {
 	struct hdmi_audio_format *audio_format = &priv->audio_fmt;
@@ -118,7 +115,6 @@ static int hdmi_audio_set_configuration(struct hdmi_codec_data *priv)
 		return -EINVAL;
 	}
 
-
 	switch (priv->params.sample_freq) {
 	case 32000:
 		sample_freq = HDMI_AUDIO_FS_32000;
@@ -369,7 +365,6 @@ static int hdmi_probe(struct snd_soc_codec *codec)
 		goto res_err;
 	}
 
-
 	hdmi_data.oh = omap_hwmod_lookup("dss_hdmi");
 
 	if (!hdmi_data.oh) {
@@ -396,9 +391,10 @@ static int hdmi_probe(struct snd_soc_codec *codec)
 	hdmi_data.dssdev = omap_dss_find_device(NULL, hdmi_audio_match);
 
 	if (!hdmi_data.dssdev) {
-		dev_err(&pdev->dev, "can't find HDMI device\n");
 		ret = -ENODEV;
 		goto dssdev_err;
+	}else{
+		dev_err(&pdev->dev, "found HDMI device\n");
 	}
 
 	hdmi_data.notifier.notifier_call = hdmi_audio_notifier_callback;
@@ -429,7 +425,6 @@ static int hdmi_remove(struct snd_soc_codec *codec)
 	return 0;
 }
 
-
 static struct snd_soc_codec_driver hdmi_audio_codec_drv = {
 	.probe = hdmi_probe,
 	.remove = hdmi_remove,
@@ -475,7 +470,6 @@ static int __devexit hdmi_codec_remove(struct platform_device *pdev)
 	return 0;
 }
 
-
 static struct platform_driver hdmi_codec_driver = {
 	.probe          = hdmi_codec_probe,
 	.remove         = __devexit_p(hdmi_codec_remove),
@@ -485,7 +479,6 @@ static struct platform_driver hdmi_codec_driver = {
 	},
 };
 
-
 static int __init hdmi_codec_init(void)
 {
 	return platform_driver_register(&hdmi_codec_driver);
@@ -498,7 +491,6 @@ static void __exit hdmi_codec_exit(void)
 }
 module_exit(hdmi_codec_exit);
 
-
 MODULE_AUTHOR("Ricardo Neri <ricardo.neri@ti.com>");
 MODULE_DESCRIPTION("ASoC HDMI codec driver");
 MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/wm8958-dsp2.c b/sound/soc/codecs/wm8958-dsp2.c
index 0293763..5184e07 100644
--- a/sound/soc/codecs/wm8958-dsp2.c
+++ b/sound/soc/codecs/wm8958-dsp2.c
@@ -141,10 +141,6 @@ static int wm8958_dsp2_fw(struct snd_soc_codec *codec, const char *name,
 		case WM_FW_BLOCK_I:
 		case WM_FW_BLOCK_A:
 		case WM_FW_BLOCK_C:
-			dev_dbg(codec->dev, "%s: %zd bytes of %x@%x\n", name,
-				block_len, (data32 >> 24) & 0xff,
-				data32 & 0xffffff);
-
 			if (check)
 				break;
 
@@ -170,7 +166,6 @@ static int wm8958_dsp2_fw(struct snd_soc_codec *codec, const char *name,
 	}
 
 	if (!check) {
-		dev_dbg(codec->dev, "%s: download done\n", name);
 		wm8994->cur_fw = fw;
 	} else {
 		dev_info(codec->dev, "%s: got firmware\n", name);
@@ -358,9 +353,6 @@ static void wm8958_dsp_apply(struct snd_soc_codec *codec, int path, int start)
 
 	reg = snd_soc_read(codec, WM8958_DSP2_PROGRAM);
 
-	dev_dbg(codec->dev, "DSP path %d %d startup: %d, power: %x, DSP: %x\n",
-		path, wm8994->dsp_active, start, pwr_reg, reg);
-
 	if (start && ena) {
 		/* If the DSP is already running then noop */
 		if (reg & WM8958_DSP2_ENA)
@@ -389,7 +381,6 @@ static void wm8958_dsp_apply(struct snd_soc_codec *codec, int path, int start)
 
 		wm8994->dsp_active = path;
 
-		dev_dbg(codec->dev, "DSP running in path %d\n", path);
 	}
 
 	if (!start && wm8994->dsp_active == path) {
@@ -398,7 +389,7 @@ static void wm8958_dsp_apply(struct snd_soc_codec *codec, int path, int start)
 			return;
 
 		snd_soc_update_bits(codec, WM8958_DSP2_CONFIG,
-				    WM8958_MBC_ENA, 0);	
+				    WM8958_MBC_ENA, 0);
 		snd_soc_write(codec, WM8958_DSP2_EXECCONTROL,
 			      WM8958_DSP2_STOP);
 		snd_soc_update_bits(codec, WM8958_DSP2_PROGRAM,
@@ -407,8 +398,6 @@ static void wm8958_dsp_apply(struct snd_soc_codec *codec, int path, int start)
 				    WM8958_DSP2CLK_ENA, 0);
 
 		wm8994->dsp_active = -1;
-
-		dev_dbg(codec->dev, "DSP stopped\n");
 	}
 }
 
@@ -519,7 +508,6 @@ static int wm8958_mbc_put(struct snd_kcontrol *kcontrol,
 		return -EINVAL;
 
 	if (wm8958_dsp2_busy(wm8994, mbc)) {
-		dev_dbg(codec->dev, "DSP2 active on %d already\n", mbc);
 		return -EBUSY;
 	}
 
@@ -645,7 +633,6 @@ static int wm8958_vss_put(struct snd_kcontrol *kcontrol,
 		return -ENODEV;
 
 	if (wm8958_dsp2_busy(wm8994, vss)) {
-		dev_dbg(codec->dev, "DSP2 active on %d already\n", vss);
 		return -EBUSY;
 	}
 
@@ -659,7 +646,6 @@ static int wm8958_vss_put(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-
 #define WM8958_VSS_SWITCH(xname, xval) {\
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
 	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\
@@ -716,7 +702,6 @@ static int wm8958_hpf_put(struct snd_kcontrol *kcontrol,
 		return -ENODEV;
 
 	if (wm8958_dsp2_busy(wm8994, hpf % 3)) {
-		dev_dbg(codec->dev, "DSP2 active on %d already\n", hpf);
 		return -EBUSY;
 	}
 
@@ -812,7 +797,6 @@ static int wm8958_enh_eq_put(struct snd_kcontrol *kcontrol,
 		return -ENODEV;
 
 	if (wm8958_dsp2_busy(wm8994, eq)) {
-		dev_dbg(codec->dev, "DSP2 active on %d already\n", eq);
 		return -EBUSY;
 	}
 
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index 963ea4e..eeb5c4b 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -1,11 +1,7 @@
 /*
- * wm8994.c  --  WM8994 ALSA SoC Audio driver
- *
  * Copyright 2009 Wolfson Microelectronics plc
- *
  * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  *
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -152,10 +148,6 @@ static void wm8958_micd_set_rate(struct snd_soc_codec *codec)
 	val = rates[best].start << WM8958_MICD_BIAS_STARTTIME_SHIFT
 		| rates[best].rate << WM8958_MICD_RATE_SHIFT;
 
-	dev_dbg(codec->dev, "MICD rate %d,%d for %dHz %s\n",
-		rates[best].start, rates[best].rate, sysclk,
-		idle ? "idle" : "active");
-
 	snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
 			    WM8958_MICD_BIAS_STARTTIME_MASK |
 			    WM8958_MICD_RATE_MASK, val);
@@ -301,8 +293,6 @@ static int configure_aif_clock(struct snd_soc_codec *codec, int aif)
 		rate /= 2;
 		reg1 |= WM8994_AIF1CLK_DIV;
 
-		dev_dbg(codec->dev, "Dividing AIF%d clock to %dHz\n",
-			aif + 1, rate);
 	}
 
 	wm8994->aifclk[aif] = rate;
@@ -529,12 +519,6 @@ static void wm8994_set_retune_mobile(struct snd_soc_codec *codec, int block)
 		}
 	}
 
-	dev_dbg(codec->dev, "ReTune Mobile %d %s/%dHz for %dHz sample rate\n",
-		block,
-		pdata->retune_mobile_cfgs[best].name,
-		pdata->retune_mobile_cfgs[best].rate,
-		wm8994->dac_rates[iface]);
-
 	/* The EQ will be disabled while reconfiguring it, remember the
 	 * current configuration.
 	 */
@@ -851,9 +835,6 @@ static void active_reference(struct snd_soc_codec *codec)
 
 	wm8994->active_refcount++;
 
-	dev_dbg(codec->dev, "Active refcount incremented, now %d\n",
-		wm8994->active_refcount);
-
 	/* If we're using jack detection go into audio mode */
 	wm1811_jackdet_set_mode(codec, WM1811_JACKDET_MODE_AUDIO);
 
@@ -869,9 +850,6 @@ static void active_dereference(struct snd_soc_codec *codec)
 
 	wm8994->active_refcount--;
 
-	dev_dbg(codec->dev, "Active refcount decremented, now %d\n",
-		wm8994->active_refcount);
-
 	if (wm8994->active_refcount == 0) {
 		/* Go into appropriate detection only mode */
 		if (wm8994->jack_mic || wm8994->mic_detecting)
@@ -910,9 +888,6 @@ static void vmid_reference(struct snd_soc_codec *codec)
 
 	wm8994->vmid_refcount++;
 
-	dev_dbg(codec->dev, "Referencing VMID, refcount is now %d\n",
-		wm8994->vmid_refcount);
-
 	if (wm8994->vmid_refcount == 1) {
 		snd_soc_update_bits(codec, WM8994_ANTIPOP_1,
 				    WM8994_LINEOUT1_DISCH |
@@ -986,9 +961,6 @@ static void vmid_dereference(struct snd_soc_codec *codec)
 
 	wm8994->vmid_refcount--;
 
-	dev_dbg(codec->dev, "Dereferencing VMID, refcount is now %d\n",
-		wm8994->vmid_refcount);
-
 	if (wm8994->vmid_refcount == 0) {
 		if (wm8994->hubs.lineout1_se)
 			snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_3,
@@ -1227,7 +1199,6 @@ static int aif2clk_ev(struct snd_soc_dapm_widget *w,
 		else
 			adc = WM8994_AIF2ADCL_ENA | WM8994_AIF2ADCR_ENA;
 
-
 		val = snd_soc_read(codec, WM8994_AIF2_CONTROL_2);
 		if ((val & WM8994_AIF2DACL_SRC) &&
 		    (val & WM8994_AIF2DACR_SRC))
@@ -1447,10 +1418,6 @@ SOC_DAPM_SINGLE("DAC1 Switch", WM8994_SPEAKER_MIXER, 0, 1, 0),
 static int post_ev(struct snd_soc_dapm_widget *w,
 	    struct snd_kcontrol *kcontrol, int event)
 {
-	struct snd_soc_codec *codec = w->codec;
-	dev_dbg(codec->dev, "SRC status: %x\n",
-		snd_soc_read(codec,
-			     WM8994_RATE_STATUS));
 	return 0;
 }
 
@@ -2088,8 +2055,6 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 	u64 Kpart;
 	unsigned int K, Ndiv, Nmod;
 
-	pr_debug("FLL input=%dHz, output=%dHz\n", freq_in, freq_out);
-
 	/* Scale the input frequency down to <= 13.5MHz */
 	fll->clk_ref_div = 0;
 	while (freq_in > 13500000) {
@@ -2099,8 +2064,6 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 		if (fll->clk_ref_div > 3)
 			return -EINVAL;
 	}
-	pr_debug("CLK_REF_DIV=%d, Fref=%dHz\n", fll->clk_ref_div, freq_in);
-
 	/* Scale the output to give 90MHz<=Fvco<=100MHz */
 	fll->outdiv = 3;
 	while (freq_out * (fll->outdiv + 1) < 90000000) {
@@ -2109,7 +2072,6 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 			return -EINVAL;
 	}
 	freq_out *= fll->outdiv + 1;
-	pr_debug("OUTDIV=%d, Fvco=%dHz\n", fll->outdiv, freq_out);
 
 	if (freq_in > 1000000) {
 		fll->fll_fratio = 0;
@@ -2126,14 +2088,12 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 		fll->fll_fratio = 4;
 		freq_in *= 16;
 	}
-	pr_debug("FLL_FRATIO=%d, Fref=%dHz\n", fll->fll_fratio, freq_in);
 
 	/* Now, calculate N.K */
 	Ndiv = freq_out / freq_in;
 
 	fll->n = Ndiv;
 	Nmod = freq_out % freq_in;
-	pr_debug("Nmod=%d\n", Nmod);
 
 	/* Calculate fractional part - scale up so we can round. */
 	Kpart = FIXED_FLL_SIZE * (long long)Nmod;
@@ -2148,8 +2108,6 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 	/* Move down to proper range now rounding is done */
 	fll->k = K / 10;
 
-	pr_debug("N=%x K=%x\n", fll->n, fll->k);
-
 	return 0;
 }
 
@@ -2163,7 +2121,6 @@ static int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,
 	u16 reg, clk1, aif_reg, aif_src;
 	unsigned long timeout;
 	bool was_enabled;
-	dev_dbg(codec->dev, "%s ++\n", __func__);
 
 	switch (id) {
 	case WM8994_FLL1:
@@ -2231,14 +2188,12 @@ static int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,
 		return -EBUSY;
 	}
 
-
 	/* We always need to disable the FLL while reconfiguring */
 	snd_soc_update_bits(codec, WM8994_FLL1_CONTROL_1 + reg_offset,
 			    WM8994_FLL1_ENA, 0);
 
 	if (wm8994->fll_byp && src == WM8994_FLL_SRC_BCLK &&
 	    freq_in == freq_out && freq_out) {
-		dev_dbg(codec->dev, "Bypassing FLL%d\n", id + 1);
 		snd_soc_update_bits(codec, WM8994_FLL1_CONTROL_5 + reg_offset,
 				    WM8958_FLL1_BYP, WM8958_FLL1_BYP);
 		goto out;
@@ -2297,9 +2252,6 @@ static int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,
 		if (wm8994->fll_locked_irq) {
 			timeout = wait_for_completion_timeout(&wm8994->fll_locked[id],
 							      msecs_to_jiffies(10));
-			if (timeout == 0)
-				dev_warn(codec->dev,
-					 "Timed out waiting for FLL lock\n");
 		} else {
 			msleep(5);
 		}
@@ -2327,7 +2279,6 @@ out:
 	wm8994->fll[id].src = src;
 
 	configure_clock(codec);
-	dev_dbg(codec->dev, "%s --\n", __func__);
 	return 0;
 }
 
@@ -2371,26 +2322,19 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 	case WM8994_SYSCLK_MCLK1:
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK1;
 		wm8994->mclk[0] = freq;
-		dev_dbg(dai->dev, "AIF%d using MCLK1 at %uHz\n",
-			dai->id, freq);
 		break;
 
 	case WM8994_SYSCLK_MCLK2:
-		/* TODO: Set GPIO AF */
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK2;
 		wm8994->mclk[1] = freq;
-		dev_dbg(dai->dev, "AIF%d using MCLK2 at %uHz\n",
-			dai->id, freq);
 		break;
 
 	case WM8994_SYSCLK_FLL1:
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_FLL1;
-		dev_dbg(dai->dev, "AIF%d using FLL1\n", dai->id);
 		break;
 
 	case WM8994_SYSCLK_FLL2:
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_FLL2;
-		dev_dbg(dai->dev, "AIF%d using FLL2\n", dai->id);
 		break;
 
 	case WM8994_SYSCLK_OPCLK:
@@ -2754,7 +2698,6 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 			lrclk_reg = WM8994_AIF1DAC_LRCLK;
 		} else {
 			lrclk_reg = WM8994_AIF1ADC_LRCLK;
-			dev_dbg(codec->dev, "AIF1 using split LRCLK\n");
 		}
 		break;
 	case 2:
@@ -2767,7 +2710,6 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 			lrclk_reg = WM8994_AIF2DAC_LRCLK;
 		} else {
 			lrclk_reg = WM8994_AIF2ADC_LRCLK;
-			dev_dbg(codec->dev, "AIF2 using split LRCLK\n");
 		}
 		break;
 	case 3:
@@ -2812,10 +2754,6 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	rate_val |= srs[i].val << WM8994_AIF1_SR_SHIFT;
 
-	dev_dbg(dai->dev, "Sample rate is %dHz\n", srs[i].rate);
-	dev_dbg(dai->dev, "AIF%dCLK is %dHz, target BCLK %dHz\n",
-		dai->id, wm8994->aifclk[id], bclk_rate);
-
 	if (params_channels(params) == 1 &&
 	    (snd_soc_read(codec, aif1_reg) & 0x18) == 0x18)
 		aif2 |= WM8994_AIF1_MONO;
@@ -2837,8 +2775,6 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		best = i;
 		best_val = cur_val;
 	}
-	dev_dbg(dai->dev, "Selected AIF%dCLK/fs = %d\n",
-		dai->id, fs_ratios[best]);
 	rate_val |= best;
 
 	/* We may not get quite the right frequency if using
@@ -2854,14 +2790,9 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		best = i;
 	}
 	bclk_rate = wm8994->aifclk[id] * 10 / bclk_divs[best];
-	dev_dbg(dai->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",
-		bclk_divs[best], bclk_rate);
 	bclk |= best << WM8994_AIF1_BCLK_DIV_SHIFT;
 
 	lrclk = bclk_rate / params_rate(params);
-	dev_dbg(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",
-		lrclk, bclk_rate / lrclk);
-
 	snd_soc_update_bits(codec, aif1_reg, WM8994_AIF1_WL_MASK, aif1);
 	snd_soc_update_bits(codec, aif2_reg, WM8994_AIF1_MONO, aif2);
 	snd_soc_update_bits(codec, bclk_reg, WM8994_AIF1_BCLK_DIV_MASK, bclk);
@@ -3197,7 +3128,6 @@ static int wm8994_codec_resume(struct snd_soc_codec *codec)
 
 static void wm8994_handle_retune_mobile_pdata(struct wm8994_priv *wm8994)
 {
-	struct snd_soc_codec *codec = wm8994->codec;
 	struct wm8994_pdata *pdata = wm8994->pdata;
 	struct snd_kcontrol_new controls[] = {
 		SOC_ENUM_EXT("AIF1.1 EQ Mode",
@@ -3249,9 +3179,6 @@ static void wm8994_handle_retune_mobile_pdata(struct wm8994_priv *wm8994)
 		wm8994->retune_mobile_texts = t;
 	}
 
-	dev_dbg(codec->dev, "Allocated %d unique ReTune Mobile names\n",
-		wm8994->num_retune_mobile_texts);
-
 	wm8994->retune_mobile_enum.max = wm8994->num_retune_mobile_texts;
 	wm8994->retune_mobile_enum.texts = wm8994->retune_mobile_texts;
 
@@ -3280,8 +3207,6 @@ static void wm8994_handle_pdata(struct wm8994_priv *wm8994)
 				      pdata->micbias1_lvl,
 				      pdata->micbias2_lvl);
 
-	dev_dbg(codec->dev, "%d DRC configurations\n", pdata->num_drc_cfgs);
-
 	if (pdata->num_drc_cfgs) {
 		struct snd_kcontrol_new controls[] = {
 			SOC_ENUM_EXT("AIF1DRC1 Mode", wm8994->drc_enum,
@@ -3318,9 +3243,6 @@ static void wm8994_handle_pdata(struct wm8994_priv *wm8994)
 			wm8994_set_drc(codec, i);
 	}
 
-	dev_dbg(codec->dev, "%d ReTune Mobile configurations\n",
-		pdata->num_retune_mobile_cfgs);
-
 	if (pdata->num_retune_mobile_cfgs)
 		wm8994_handle_retune_mobile_pdata(wm8994);
 	else
@@ -3374,9 +3296,6 @@ int wm8994_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 		return -EINVAL;
 	}
 
-	dev_dbg(codec->dev, "Configuring microphone detection on %d: %x %x\n",
-		micbias, det, shrt);
-
 	/* Store the configuration */
 	micdet->jack = jack;
 	micdet->det = det;
@@ -3401,9 +3320,11 @@ static irqreturn_t wm8994_mic_irq(int irq, void *data)
 	int reg;
 	int report;
 
+#if 0
 #ifndef CONFIG_SND_SOC_WM8994_MODULE
 	trace_snd_soc_jack_irq(dev_name(codec->dev));
 #endif
+#endif
 
 	reg = snd_soc_read(codec, WM8994_INTERRUPT_RAW_STATUS_2);
 	if (reg < 0) {
@@ -3412,8 +3333,6 @@ static irqreturn_t wm8994_mic_irq(int irq, void *data)
 		return IRQ_HANDLED;
 	}
 
-	dev_dbg(codec->dev, "Microphone status: %x\n", reg);
-
 	report = 0;
 	if (reg & WM8994_MIC1_DET_STS)
 		report |= priv->micdet[0].det;
@@ -3446,7 +3365,6 @@ static void wm8958_default_micdet(u16 status, void *data)
 	if (!(status & WM8958_MICD_STS)) {
 		if (!wm8994->jackdet) {
 			/* If nothing present then clear our statuses */
-			dev_dbg(codec->dev, "Detected open circuit\n");
 			wm8994->jack_mic = false;
 			wm8994->mic_detecting = true;
 
@@ -3463,24 +3381,16 @@ static void wm8958_default_micdet(u16 status, void *data)
 	 * microphone.
 	 */
 	if (wm8994->mic_detecting && (status & 0x600)) {
-		dev_dbg(codec->dev, "Detected microphone\n");
-
 		wm8994->mic_detecting = false;
 		wm8994->jack_mic = true;
-
 		wm8958_micd_set_rate(codec);
-
 		snd_soc_jack_report(wm8994->micdet[0].jack, SND_JACK_HEADSET,
 				    SND_JACK_HEADSET);
 	}
 
-
 	if (wm8994->mic_detecting && status & 0x4) {
-		dev_dbg(codec->dev, "Detected headphone\n");
 		wm8994->mic_detecting = false;
-
 		wm8958_micd_set_rate(codec);
-
 		snd_soc_jack_report(wm8994->micdet[0].jack, SND_JACK_HEADPHONE,
 				    SND_JACK_HEADSET);
 
@@ -3548,13 +3458,9 @@ static irqreturn_t wm1811_jackdet_irq(int irq, void *data)
 		return IRQ_NONE;
 	}
 
-	dev_dbg(codec->dev, "JACKDET %x\n", reg);
-
 	present = reg & WM1811_JACKDET_LVL;
 
 	if (present) {
-		dev_dbg(codec->dev, "Jack detected\n");
-
 		wm8958_micd_set_rate(codec);
 
 		snd_soc_update_bits(codec, WM8958_MICBIAS2,
@@ -3574,8 +3480,6 @@ static irqreturn_t wm1811_jackdet_irq(int irq, void *data)
 		snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
 				    WM8958_MICD_ENA, WM8958_MICD_ENA);
 	} else {
-		dev_dbg(codec->dev, "Jack not detected\n");
-
 		snd_soc_update_bits(codec, WM8958_MICBIAS2,
 				    WM8958_MICB2_DISCH, WM8958_MICB2_DISCH);
 
@@ -3650,7 +3554,6 @@ int wm8958_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 
 	if (jack) {
 		if (!cb) {
-			dev_dbg(codec->dev, "Using default micdet callback\n");
 			cb = wm8958_default_micdet;
 			cb_data = codec;
 		}
@@ -3739,7 +3642,6 @@ static irqreturn_t wm8958_mic_irq(int irq, void *data)
 		}
 
 		if (!(reg & WM8958_MICD_VALID)) {
-			dev_dbg(codec->dev, "Mic detect data not valid\n");
 			goto out;
 		}
 
@@ -3752,10 +3654,11 @@ static irqreturn_t wm8958_mic_irq(int irq, void *data)
 	if (count == 0)
 		dev_warn(codec->dev, "No impedence range reported for jack\n");
 
+#if 0
 #ifndef CONFIG_SND_SOC_WM8994_MODULE
 	trace_snd_soc_jack_irq(dev_name(codec->dev));
 #endif
-
+#endif
 	if (wm8994->jack_cb)
 		wm8994->jack_cb(reg, wm8994->jack_cb_data);
 	else
@@ -3994,10 +3897,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 						 wm8994);
 			if (ret == 0) {
 				wm8994->jackdet = true;
-			} else {
-				dev_warn(codec->dev,
-					 "Failed to request Jack detect IRQ: %d\n",
-					 ret);
 			}
 		}
 		break;
@@ -4157,7 +4056,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 		break;
 	}
 
-
 	wm_hubs_add_analogue_routes(codec, 0, 0);
 	snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
 
@@ -4363,7 +4261,6 @@ static __exit void wm8994_exit(void)
 }
 module_exit(wm8994_exit);
 
-
 MODULE_DESCRIPTION("ASoC WM8994 driver");
 MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfsonmicro.com>");
 MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/wm8995.c b/sound/soc/codecs/wm8995.c
index 5ad873f..e98024f 100644
--- a/sound/soc/codecs/wm8995.c
+++ b/sound/soc/codecs/wm8995.c
@@ -251,37 +251,30 @@ static void wm8995_update_class_w(struct snd_soc_codec *codec)
 	reg = snd_soc_read(codec, WM8995_DAC1_LEFT_MIXER_ROUTING);
 	switch (reg) {
 	case WM8995_AIF2DACL_TO_DAC1L:
-		dev_dbg(codec->dev, "Class W source AIF2DAC\n");
 		source = 2 << WM8995_CP_DYN_SRC_SEL_SHIFT;
 		break;
 	case WM8995_AIF1DAC2L_TO_DAC1L:
-		dev_dbg(codec->dev, "Class W source AIF1DAC2\n");
 		source = 1 << WM8995_CP_DYN_SRC_SEL_SHIFT;
 		break;
 	case WM8995_AIF1DAC1L_TO_DAC1L:
-		dev_dbg(codec->dev, "Class W source AIF1DAC1\n");
 		source = 0 << WM8995_CP_DYN_SRC_SEL_SHIFT;
 		break;
 	default:
-		dev_dbg(codec->dev, "DAC mixer setting: %x\n", reg);
 		enable = 0;
 		break;
 	}
 
 	reg_r = snd_soc_read(codec, WM8995_DAC1_RIGHT_MIXER_ROUTING);
 	if (reg_r != reg) {
-		dev_dbg(codec->dev, "Left and right DAC mixers different\n");
 		enable = 0;
 	}
 
 	if (enable) {
-		dev_dbg(codec->dev, "Class W enabled\n");
 		snd_soc_update_bits(codec, WM8995_CLASS_W_1,
 				    WM8995_CP_DYN_PWR_MASK |
 				    WM8995_CP_DYN_SRC_SEL_MASK,
 				    source | WM8995_CP_DYN_PWR);
 	} else {
-		dev_dbg(codec->dev, "Class W disabled\n");
 		snd_soc_update_bits(codec, WM8995_CLASS_W_1,
 				    WM8995_CP_DYN_PWR_MASK, 0);
 	}
@@ -355,9 +348,6 @@ static void dc_servo_cmd(struct snd_soc_codec *codec,
 {
 	int timeout = 10;
 
-	dev_dbg(codec->dev, "%s: reg = %#x, val = %#x, mask = %#x\n",
-		__func__, reg, val, mask);
-
 	snd_soc_write(codec, reg, val);
 	while (timeout--) {
 		msleep(10);
@@ -470,8 +460,6 @@ static int configure_aif_clock(struct snd_soc_codec *codec, int aif)
 		rate /= 2;
 		reg1 |= WM8995_AIF1CLK_DIV;
 
-		dev_dbg(codec->dev, "Dividing AIF%d clock to %dHz\n",
-			aif + 1, rate);
 	}
 
 	wm8995->aifclk[aif] = rate;
@@ -1128,7 +1116,6 @@ static int wm8995_hw_params(struct snd_pcm_substream *substream,
 			lrclk_reg = WM8995_AIF1DAC_LRCLK;
 		} else {
 			lrclk_reg = WM8995_AIF1ADC_LRCLK;
-			dev_dbg(codec->dev, "AIF1 using split LRCLK\n");
 		}
 		break;
 	case 1:
@@ -1140,7 +1127,6 @@ static int wm8995_hw_params(struct snd_pcm_substream *substream,
 			lrclk_reg = WM8995_AIF2DAC_LRCLK;
 		} else {
 			lrclk_reg = WM8995_AIF2ADC_LRCLK;
-			dev_dbg(codec->dev, "AIF2 using split LRCLK\n");
 		}
 		break;
 	default:
@@ -1181,10 +1167,6 @@ static int wm8995_hw_params(struct snd_pcm_substream *substream,
 	}
 	rate_val = i << WM8995_AIF1_SR_SHIFT;
 
-	dev_dbg(dai->dev, "Sample rate is %dHz\n", srs[i]);
-	dev_dbg(dai->dev, "AIF%dCLK is %dHz, target BCLK %dHz\n",
-		dai->id + 1, wm8995->aifclk[dai->id], bclk_rate);
-
 	/* AIFCLK/fs ratio; look for a close match in either direction */
 	best = 1;
 	best_val = abs((fs_ratios[1] * params_rate(params))
@@ -1199,9 +1181,6 @@ static int wm8995_hw_params(struct snd_pcm_substream *substream,
 	}
 	rate_val |= best;
 
-	dev_dbg(dai->dev, "Selected AIF%dCLK/fs = %d\n",
-		dai->id + 1, fs_ratios[best]);
-
 	/*
 	 * We may not get quite the right frequency if using
 	 * approximate clocks so look for the closest match that is
@@ -1219,12 +1198,8 @@ static int wm8995_hw_params(struct snd_pcm_substream *substream,
 	bclk |= best << WM8995_AIF1_BCLK_DIV_SHIFT;
 
 	bclk_rate = wm8995->aifclk[dai->id] * 10 / bclk_divs[best];
-	dev_dbg(dai->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",
-		bclk_divs[best], bclk_rate);
 
 	lrclk = bclk_rate / params_rate(params);
-	dev_dbg(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",
-		lrclk, bclk_rate / lrclk);
 
 	snd_soc_update_bits(codec, aif1_reg,
 			    WM8995_AIF1_WL_MASK, aif1);
@@ -1484,22 +1459,16 @@ static int wm8995_set_dai_sysclk(struct snd_soc_dai *dai,
 	case WM8995_SYSCLK_MCLK1:
 		wm8995->sysclk[dai->id] = WM8995_SYSCLK_MCLK1;
 		wm8995->mclk[0] = freq;
-		dev_dbg(dai->dev, "AIF%d using MCLK1 at %uHz\n",
-			dai->id + 1, freq);
 		break;
 	case WM8995_SYSCLK_MCLK2:
 		wm8995->sysclk[dai->id] = WM8995_SYSCLK_MCLK1;
 		wm8995->mclk[1] = freq;
-		dev_dbg(dai->dev, "AIF%d using MCLK2 at %uHz\n",
-			dai->id + 1, freq);
 		break;
 	case WM8995_SYSCLK_FLL1:
 		wm8995->sysclk[dai->id] = WM8995_SYSCLK_FLL1;
-		dev_dbg(dai->dev, "AIF%d using FLL1\n", dai->id + 1);
 		break;
 	case WM8995_SYSCLK_FLL2:
 		wm8995->sysclk[dai->id] = WM8995_SYSCLK_FLL2;
-		dev_dbg(dai->dev, "AIF%d using FLL2\n", dai->id + 1);
 		break;
 	case WM8995_SYSCLK_OPCLK:
 	default:
diff --git a/sound/soc/codecs/wm_hubs.c b/sound/soc/codecs/wm_hubs.c
index 7669ebd..ded74ea 100644
--- a/sound/soc/codecs/wm_hubs.c
+++ b/sound/soc/codecs/wm_hubs.c
@@ -118,27 +118,15 @@ static bool wm_hubs_dac_hp_direct(struct snd_soc_codec *codec)
 	reg = snd_soc_read(codec, WM8993_OUTPUT_MIXER1);
 	if (!(reg & WM8993_DACL_TO_HPOUT1L)) {
 		if (reg & ~WM8993_DACL_TO_MIXOUTL) {
-			dev_vdbg(codec->dev, "Analogue paths connected: %x\n",
-				 reg & ~WM8993_DACL_TO_HPOUT1L);
 			return false;
-		} else {
-			dev_vdbg(codec->dev, "HPL connected to mixer\n");
 		}
-	} else {
-		dev_vdbg(codec->dev, "HPL connected to DAC\n");
 	}
 
 	reg = snd_soc_read(codec, WM8993_OUTPUT_MIXER2);
 	if (!(reg & WM8993_DACR_TO_HPOUT1R)) {
 		if (reg & ~WM8993_DACR_TO_MIXOUTR) {
-			dev_vdbg(codec->dev, "Analogue paths connected: %x\n",
-				 reg & ~WM8993_DACR_TO_HPOUT1R);
 			return false;
-		} else {
-			dev_vdbg(codec->dev, "HPR connected to mixer\n");
 		}
-	} else {
-		dev_vdbg(codec->dev, "HPR connected to DAC\n");
 	}
 
 	return true;
@@ -345,7 +333,6 @@ SOC_SINGLE_TLV("IN1R Volume", WM8993_RIGHT_LINE_INPUT_1_2_VOLUME, 0, 31, 0,
 SOC_SINGLE("IN1R Switch", WM8993_RIGHT_LINE_INPUT_1_2_VOLUME, 7, 1, 1),
 SOC_SINGLE("IN1R ZC Switch", WM8993_RIGHT_LINE_INPUT_1_2_VOLUME, 6, 1, 0),
 
-
 SOC_SINGLE_TLV("IN2L Volume", WM8993_LEFT_LINE_INPUT_3_4_VOLUME, 0, 31, 0,
 	       inpga_tlv),
 SOC_SINGLE("IN2L Switch", WM8993_LEFT_LINE_INPUT_3_4_VOLUME, 7, 1, 1),
@@ -639,8 +626,6 @@ void wm_hubs_update_class_w(struct snd_soc_codec *codec)
 	if (hubs->check_class_w_digital && !hubs->check_class_w_digital(codec))
 		enable = false;
 
-	dev_vdbg(codec->dev, "Class W %s\n", enable ? "enabled" : "disabled");
-
 	snd_soc_update_bits(codec, WM8993_CLASS_W_0,
 			    WM8993_CP_DYN_V | WM8993_CP_DYN_FREQ, enable);
 }
diff --git a/sound/soc/omap/mid_omap_wm8994.c b/sound/soc/omap/mid_omap_wm8994.c
index c884c04..83dc3b6 100644
--- a/sound/soc/omap/mid_omap_wm8994.c
+++ b/sound/soc/omap/mid_omap_wm8994.c
@@ -558,8 +558,6 @@ static void omap4_micd_set_rate(struct snd_soc_codec *codec)
 
 	idle = !wm8994->jack_mic;
 
-	dev_info(codec->dev, "omap4_micd_set_rate\n");
-
 	sysclk = snd_soc_read(codec, WM8994_CLOCKING_1);
 	if (sysclk & WM8994_SYSCLK_SRC)
 		sysclk = wm8994->aifclk[1];
@@ -619,7 +617,6 @@ static void omap4_jackdet(void *data)
 #endif
 
 	earAdc = wm8994->pdata->get_earjack_adc();
-	dev_info(wm1811->codec->dev, "!!earAdc : %d\n", earAdc);
 
 	/*
 	 * If the measurement is showing a high impedence we've got a
@@ -693,8 +690,6 @@ static void omap4_wm8994_start_fll1(struct snd_soc_dai *aif1_dai)
 {
 	int ret;
 
-	dev_info(aif1_dai->dev, "Moving to audio clocking settings\n");
-
 	/* Switch the FLL */
 	ret = snd_soc_dai_set_pll(aif1_dai,
 				  WM8994_FLL1,
@@ -763,8 +758,6 @@ static int omap4_wm8994_aif2_hw_params(struct snd_pcm_substream *substream,
 	/* The source of fll is actually the mclk. */
 	int mclk;
 
-	pr_info("%s: enter\n", __func__);
-
 	prate = params_rate(params);
 	switch (prate) {
 	/* FM use the 44.1KHz sync clk. */
@@ -1001,8 +994,6 @@ static ssize_t reselect_jack_store(struct device *dev,
 
 	reg = snd_soc_read(codec, WM8958_MIC_DETECT_3);
 	if (reg == 0x402) {
-		dev_info(codec->dev, "Detected open circuit\n");
-
 		snd_soc_update_bits(codec, WM8958_MICBIAS2,
 				    WM8958_MICB2_DISCH, WM8958_MICB2_DISCH);
 		/* Enable debounce while removed */
diff --git a/sound/soc/omap/omap_wm8994.c b/sound/soc/omap/omap_wm8994.c
index 4ee4590..2624ea3 100644
--- a/sound/soc/omap/omap_wm8994.c
+++ b/sound/soc/omap/omap_wm8994.c
@@ -256,8 +256,6 @@ static int set_lineout_mode(struct snd_kcontrol *kcontrol,
 
 	gpio_set_value(lineout_select.gpio, lineout_mode);
 
-	dev_dbg(codec->dev, "set lineout mode : %s\n",
-		lineout_mode_text[lineout_mode]);
 	return 0;
 
 }
@@ -267,8 +265,6 @@ static int omap_lineout_switch(struct snd_soc_dapm_widget *w,
 {
 	struct snd_soc_codec *codec = w->codec;
 
-	dev_dbg(codec->dev, "%s event is %02X", w->name, event);
-
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
 		gpio_set_value(lineout_select.gpio, 1);
@@ -378,7 +374,6 @@ static const struct soc_enum sub_bias_mode_enum[] = {
 	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(mic_bias_mode_text), mic_bias_mode_text),
 };
 
-
 static int get_aif2_mute_status(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
@@ -406,9 +401,6 @@ static int set_aif2_mute_status(struct snd_kcontrol *kcontrol,
 	snd_soc_update_bits(codec, WM8994_AIF2_DAC_FILTERS_1,
 				WM8994_AIF2DAC_MUTE, reg);
 
-	pr_info("set aif2_digital_mute : %s\n",
-			switch_mode_text[aif2_digital_mute]);
-
 	return 0;
 }
 
@@ -446,17 +438,11 @@ static int set_sub_mic_bias_mode(struct snd_kcontrol *kcontrol,
 	case MIC_DISABLE:
 		if (sub_mic_bias_mode != MIC_FORCE_ENABLE)
 			gpio_set_value(sub_mic_bias.gpio, 0);
-		else
-			dev_info(codec->dev,
-				"SKIP submic disable=%d\n", status);
 		break;
 	default:
 		break;
 	}
 
-	dev_info(codec->dev, "sub_mic_bias_mod=%d: status=%d\n",
-				sub_mic_bias_mode, status);
-
 	return 0;
 
 }
@@ -495,17 +481,11 @@ static int set_main_mic_bias_mode(struct snd_kcontrol *kcontrol,
 	case MIC_DISABLE:
 		if (main_mic_bias_mode != MIC_FORCE_ENABLE)
 			gpio_set_value(main_mic_bias.gpio, 0);
-		else
-			dev_info(codec->dev,
-				"SKIP mainmic disable=%d\n", status);
 		break;
 	default:
 		break;
 	}
 
-	dev_info(codec->dev, "main_mic_bias_mod=%d: status=%d\n",
-				main_mic_bias_mode, status);
-
 	return 0;
 
 }
@@ -592,7 +572,6 @@ static void wm1811_micdet(u16 status, void *data)
 	if (!(status & WM8958_MICD_STS)) {
 		if (!wm8994->jackdet) {
 			/* If nothing present then clear our statuses */
-			dev_dbg(wm1811->codec->dev, "Detected open circuit\n");
 			wm8994->jack_mic = false;
 			wm8994->mic_detecting = true;
 
@@ -668,9 +647,6 @@ static void wm1811_micdet(u16 status, void *data)
 		if (status & WM8994_JACKDET_BTN2)
 			report |= SND_JACK_BTN_2;
 
-		dev_info(wm1811->codec->dev, "Detected Button: %08x (%08X)\n",
-			report, status);
-
 		snd_soc_jack_report(wm8994->micdet[0].jack, report,
 				    wm8994->btn_mask);
 	}
@@ -681,8 +657,6 @@ static int omap4_wm8994_start_fll1(struct snd_soc_dai *aif1_dai)
 {
 	int ret;
 
-	dev_dbg(aif1_dai->dev, "Moving to audio clocking settings\n");
-
 	/* Switch the FLL */
 	ret = snd_soc_dai_set_pll(aif1_dai,
 				  WM8994_FLL1,
diff --git a/sound/soc/soc-core-open.c b/sound/soc/soc-core-open.c
index d044f2c..3557cf8 100644
--- a/sound/soc/soc-core-open.c
+++ b/sound/soc/soc-core-open.c
@@ -1903,8 +1903,6 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 	for (i = 0; i < card->num_links; i++) {
 		ret = soc_probe_dai_link(card, i);
 		if (ret < 0) {
-			pr_err("asoc: failed to instantiate card %s: %d\n",
-			       card->name, ret);
 			goto probe_dai_err;
 		}
 	}
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c171182..250b690 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1696,9 +1696,6 @@ static int soc_probe_codec(struct snd_soc_card *card,
 	if (driver->probe) {
 		ret = driver->probe(codec);
 		if (ret < 0) {
-			dev_err(codec->dev,
-				"asoc: failed to probe CODEC %s: %d\n",
-				codec->name, ret);
 			goto err_probe;
 		}
 	}
@@ -1819,9 +1816,6 @@ static int soc_probe_dai_link(struct snd_soc_card *card, int num, int order)
 	struct snd_soc_dai *codec_dai = rtd->codec_dai, *cpu_dai = rtd->cpu_dai;
 	int ret;
 
-	dev_dbg(card->dev, "probe %s dai link %d late %d\n",
-			card->name, num, order);
-
 	/* config components */
 	codec_dai->codec = codec;
 	cpu_dai->platform = platform;
@@ -2129,8 +2123,6 @@ static void snd_soc_instantiate_card(struct snd_soc_card *card)
 		for (i = 0; i < card->num_links; i++) {
 			ret = soc_probe_dai_link(card, i, order);
 			if (ret < 0) {
-				pr_err("asoc: failed to instantiate card %s: %d\n",
-			       card->name, ret);
 				goto probe_dai_err;
 			}
 		}
diff --git a/sound/soc/soc-jack.c b/sound/soc/soc-jack.c
index ef3903c..c316991 100644
--- a/sound/soc/soc-jack.c
+++ b/sound/soc/soc-jack.c
@@ -86,10 +86,8 @@ void snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)
 			switch_set_state(&android_switch, SEC_HEADSET_4POLE);
 		else if (status & SND_JACK_HEADPHONE)
 			switch_set_state(&android_switch, SEC_HEADSET_3POLE);
-		else {
-			printk(KERN_INFO "=%s= EAR JACK removed =\n", __func__);
+		else
 			switch_set_state(&android_switch, SEC_JACK_NO_DEVICE);
-		}
 	}
 #endif /* not CONFIG_SAMSUNG_JACK */
 
diff --git a/sound/usb/endpoint.c b/sound/usb/endpoint.c
index 05842c8..0472b4f 100644
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@ -52,7 +52,6 @@ static void free_substream(struct snd_usb_substream *subs)
 	kfree(subs->rate_list.list);
 }
 
-
 /*
  * free a usb stream instance
  */
@@ -73,7 +72,6 @@ static void snd_usb_audio_pcm_free(struct snd_pcm *pcm)
 	}
 }
 
-
 /*
  * add this endpoint to the chip instance.
  * if a stream with the same endpoint already exists, append to it.
@@ -168,10 +166,6 @@ static int parse_uac_endpoint_attributes(struct snd_usb_audio *chip,
 
 	if (!csep || csep->bLength < 7 ||
 	    csep->bDescriptorSubtype != UAC_EP_GENERAL) {
-		snd_printk(KERN_WARNING "%d:%u:%d : no or invalid"
-			   " class specific endpoint descriptor\n",
-			   chip->dev->devnum, iface_no,
-			   altsd->bAlternateSetting);
 		return 0;
 	}
 
@@ -431,7 +425,6 @@ int snd_usb_parse_audio_endpoints(struct snd_usb_audio *chip, int iface_no)
 			continue;
 		}
 
-		snd_printdd(KERN_INFO "%d:%u:%d: add audio endpoint %#x\n", dev->devnum, iface_no, altno, fp->endpoint);
 		err = snd_usb_add_audio_endpoint(chip, stream, fp);
 		if (err < 0) {
 			kfree(fp->rate_table);
diff --git a/sound/usb/format.c b/sound/usb/format.c
index b30fcd0..e8d07a6 100644
--- a/sound/usb/format.c
+++ b/sound/usb/format.c
@@ -72,19 +72,12 @@ static u64 parse_audio_format_i_type(struct snd_usb_audio *chip,
 
 	if (format == 0 || format == (1 << UAC_FORMAT_TYPE_I_UNDEFINED)) {
 		/* some devices don't define this correctly... */
-		snd_printdd(KERN_INFO "%d:%u:%d : format type 0 is detected, processed as PCM\n",
-			    chip->dev->devnum, fp->iface, fp->altsetting);
 		format = 1 << UAC_FORMAT_TYPE_I_PCM;
 	}
 	if (format & (1 << UAC_FORMAT_TYPE_I_PCM)) {
 		if (chip->usb_id == USB_ID(0x0582, 0x0016) /* Edirol SD-90 */ &&
 		    sample_width == 24 && sample_bytes == 2)
 			sample_bytes = 3;
-		else if (sample_width > sample_bytes * 8) {
-			snd_printk(KERN_INFO "%d:%u:%d : sample bitwidth %d in over sample bytes %d\n",
-				   chip->dev->devnum, fp->iface, fp->altsetting,
-				   sample_width, sample_bytes);
-		}
 		/* check the format byte size */
 		switch (sample_bytes) {
 		case 1:
@@ -106,9 +99,6 @@ static u64 parse_audio_format_i_type(struct snd_usb_audio *chip,
 			pcm_formats |= SNDRV_PCM_FMTBIT_S32_LE;
 			break;
 		default:
-			snd_printk(KERN_INFO "%d:%u:%d : unsupported sample bitwidth %d in %d bytes\n",
-				   chip->dev->devnum, fp->iface, fp->altsetting,
-				   sample_width, sample_bytes);
 			break;
 		}
 	}
@@ -129,14 +119,9 @@ static u64 parse_audio_format_i_type(struct snd_usb_audio *chip,
 	if (format & (1 << UAC_FORMAT_TYPE_I_MULAW)) {
 		pcm_formats |= SNDRV_PCM_FMTBIT_MU_LAW;
 	}
-	if (format & ~0x3f) {
-		snd_printk(KERN_INFO "%d:%u:%d : unsupported format bits %#x\n",
-			   chip->dev->devnum, fp->iface, fp->altsetting, format);
-	}
 	return pcm_formats;
 }
 
-
 /*
  * parse the format descriptor and stores the possible sample rates
  * on the audioformat table (audio class v1).
@@ -254,7 +239,6 @@ static int parse_uac2_sample_rate_range(struct audioformat *fp, int nr_triplets,
 
 			nr_rates++;
 			if (nr_rates >= MAX_NR_RATES) {
-				snd_printk(KERN_ERR "invalid uac2 rates\n");
 				break;
 			}
 
@@ -369,7 +353,7 @@ static int parse_audio_format_i(struct snd_usb_audio *chip,
 		switch (chip->usb_id) {
 
 		case USB_ID(0x0763, 0x2003): /* M-Audio Audiophile USB */
-			if (chip->setup == 0x00 && 
+			if (chip->setup == 0x00 &&
 			    fp->altsetting == 6)
 				pcm_format = SNDRV_PCM_FORMAT_S16_BE;
 			else
@@ -393,8 +377,6 @@ static int parse_audio_format_i(struct snd_usb_audio *chip,
 	 */
 	switch (protocol) {
 	default:
-		snd_printdd(KERN_WARNING "%d:%u:%d : invalid protocol version %d, assuming v1\n",
-			   chip->dev->devnum, fp->iface, fp->altsetting, protocol);
 		/* fall through */
 	case UAC_VERSION_1:
 		fp->channels = fmt->bNrChannels;
@@ -437,8 +419,6 @@ static int parse_audio_format_ii(struct snd_usb_audio *chip,
 		fp->formats = SNDRV_PCM_FMTBIT_MPEG;
 		break;
 	default:
-		snd_printd(KERN_INFO "%d:%u:%d : unknown format tag %#x is detected.  processed as MPEG.\n",
-			   chip->dev->devnum, fp->iface, fp->altsetting, format);
 		fp->formats = SNDRV_PCM_FMTBIT_MPEG;
 		break;
 	}
@@ -447,14 +427,11 @@ static int parse_audio_format_ii(struct snd_usb_audio *chip,
 
 	switch (protocol) {
 	default:
-		snd_printdd(KERN_WARNING "%d:%u:%d : invalid protocol version %d, assuming v1\n",
-			   chip->dev->devnum, fp->iface, fp->altsetting, protocol);
 		/* fall through */
 	case UAC_VERSION_1: {
 		struct uac_format_type_ii_discrete_descriptor *fmt = _fmt;
 		brate = le16_to_cpu(fmt->wMaxBitRate);
 		framesize = le16_to_cpu(fmt->wSamplesPerFrame);
-		snd_printd(KERN_INFO "found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);
 		fp->frame_size = framesize;
 		ret = parse_audio_format_rates_v1(chip, fp, _fmt, 8); /* fmt[8..] sample rates */
 		break;
@@ -463,7 +440,6 @@ static int parse_audio_format_ii(struct snd_usb_audio *chip,
 		struct uac_format_type_ii_ext_descriptor *fmt = _fmt;
 		brate = le16_to_cpu(fmt->wMaxBitRate);
 		framesize = le16_to_cpu(fmt->wSamplesPerFrame);
-		snd_printd(KERN_INFO "found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);
 		fp->frame_size = framesize;
 		ret = parse_audio_format_rates_v2(chip, fp);
 		break;
@@ -488,9 +464,6 @@ int snd_usb_parse_audio_format(struct snd_usb_audio *chip, struct audioformat *f
 		err = parse_audio_format_ii(chip, fp, format, fmt, iface);
 		break;
 	default:
-		snd_printd(KERN_INFO "%d:%u:%d : format type %d is not supported yet\n",
-			   chip->dev->devnum, fp->iface, fp->altsetting,
-			   fmt->bFormatType);
 		return -ENOTSUPP;
 	}
 	fp->fmt_type = fmt->bFormatType;
diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index c635a2d..256063f 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -71,12 +71,10 @@
 #define OUTPUT_URBS 7
 #define INPUT_URBS 7
 
-
 MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_DESCRIPTION("USB Audio/MIDI helper module");
 MODULE_LICENSE("Dual BSD/GPL");
 
-
 struct usb_ms_header_descriptor {
 	__u8  bLength;
 	__u8  bDescriptorType;
@@ -226,7 +224,6 @@ static void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint* ep, int port
 	struct usbmidi_in_port* port = &ep->ports[portidx];
 
 	if (!port->substream) {
-		snd_printd("unexpected port %d!\n", portidx);
 		return;
 	}
 	if (!test_bit(port->substream->number, &ep->umidi->input_triggered))
@@ -997,7 +994,6 @@ static struct usb_protocol_ops snd_usbmidi_emagic_ops = {
 	.finish_out_endpoint = snd_usbmidi_emagic_finish_out,
 };
 
-
 static void update_roland_altsetting(struct snd_usb_midi* umidi)
 {
 	struct usb_interface *intf;
@@ -1618,7 +1614,6 @@ static void snd_usbmidi_init_substream(struct snd_usb_midi* umidi,
 
 	struct snd_rawmidi_substream *substream = snd_usbmidi_find_substream(umidi, stream, number);
 	if (!substream) {
-		snd_printd(KERN_ERR "substream %d:%d not found\n", stream, number);
 		return;
 	}
 
@@ -1667,8 +1662,6 @@ static int snd_usbmidi_create_endpoints(struct snd_usb_midi* umidi,
 			}
 		}
 	}
-	snd_printdd(KERN_INFO "created %d output and %d input ports\n",
-		    out_ports, in_ports);
 	return 0;
 }
 
@@ -1697,8 +1690,8 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 	    ms_header->bLength >= 7 &&
 	    ms_header->bDescriptorType == USB_DT_CS_INTERFACE &&
 	    ms_header->bDescriptorSubtype == UAC_HEADER)
-		snd_printdd(KERN_INFO "MIDIStreaming version %02x.%02x\n",
-			    ms_header->bcdMSC[1], ms_header->bcdMSC[0]);
+			snd_printdd(KERN_INFO "MIDIStreaming version %02x.%02x\n",
+					ms_header->bcdMSC[1], ms_header->bcdMSC[0]);
 	else
 		snd_printk(KERN_WARNING "MIDIStreaming interface descriptor not found\n");
 
@@ -1717,7 +1710,6 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 		if (usb_endpoint_dir_out(ep)) {
 			if (endpoints[epidx].out_ep) {
 				if (++epidx >= MIDI_MAX_ENDPOINTS) {
-					snd_printk(KERN_WARNING "too many endpoints\n");
 					break;
 				}
 			}
@@ -1732,12 +1724,9 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 				 */
 				endpoints[epidx].out_interval = 1;
 			endpoints[epidx].out_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
-			snd_printdd(KERN_INFO "EP %02X: %d jack(s)\n",
-				    ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
 		} else {
 			if (endpoints[epidx].in_ep) {
 				if (++epidx >= MIDI_MAX_ENDPOINTS) {
-					snd_printk(KERN_WARNING "too many endpoints\n");
 					break;
 				}
 			}
@@ -1747,8 +1736,6 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 			else if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)
 				endpoints[epidx].in_interval = 1;
 			endpoints[epidx].in_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
-			snd_printdd(KERN_INFO "EP %02X: %d jack(s)\n",
-				    ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
 		}
 	}
 	return 0;
@@ -1815,8 +1802,6 @@ static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi* umidi)
 	    (get_endpoint(hostif, 1)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT)
 		return;
 
-	snd_printdd(KERN_INFO "switching to altsetting %d with int ep\n",
-		    intfd->bAlternateSetting);
 	usb_set_interface(umidi->dev, intfd->bInterfaceNumber,
 			  intfd->bAlternateSetting);
 
@@ -1959,25 +1944,21 @@ static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi* umidi,
 	 * input bulk endpoints (at indices 1 and 3) which aren't used.
 	 */
 	if (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {
-		snd_printdd(KERN_ERR "not enough endpoints\n");
 		return -ENOENT;
 	}
 
 	epd = get_endpoint(hostif, 0);
 	if (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {
-		snd_printdd(KERN_ERR "endpoint[0] isn't interrupt\n");
 		return -ENXIO;
 	}
 	epd = get_endpoint(hostif, 2);
 	if (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {
-		snd_printdd(KERN_ERR "endpoint[2] isn't bulk output\n");
 		return -ENXIO;
 	}
 	if (endpoint->out_cables > 0x0001) {
 		epd = get_endpoint(hostif, 4);
 		if (!usb_endpoint_dir_out(epd) ||
 		    !usb_endpoint_xfer_bulk(epd)) {
-			snd_printdd(KERN_ERR "endpoint[4] isn't bulk output\n");
 			return -ENXIO;
 		}
 	}
@@ -2185,7 +2166,6 @@ int snd_usbmidi_create(struct snd_card *card,
 		endpoints[1].out_cables = 0;
 		break;
 	default:
-		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
 		err = -ENXIO;
 		break;
 	}
diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index 0957e1c..1840797 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -276,7 +276,6 @@ static int get_abs_value(struct usb_mixer_elem_info *cval, int val)
 	return val;
 }
 
-
 /*
  * retrieve a mixer value
  */
@@ -420,7 +419,6 @@ static int get_cur_mix_value(struct usb_mixer_elem_info *cval,
 	return 0;
 }
 
-
 /*
  * set a mixer value
  */
@@ -438,9 +436,7 @@ int snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,
 		/* audio class v2 controls are always 2 bytes in size */
 		val_len = sizeof(__u16);
 
-		/* FIXME */
 		if (request != UAC_SET_CUR) {
-			snd_printdd(KERN_WARNING "RANGE setting not yet supported\n");
 			return -EINVAL;
 		}
 
@@ -490,8 +486,6 @@ static int set_cur_mix_value(struct usb_mixer_elem_info *cval, int channel,
 		cval->ch_readonly & (1 << (channel - 1));
 
 	if (read_only) {
-		snd_printdd(KERN_INFO "%s(): channel %d of control %d is read_only\n",
-			    __func__, channel, cval->control);
 		return 0;
 	}
 
@@ -528,7 +522,6 @@ static int mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,
 
 static int parse_audio_unit(struct mixer_build *state, int unitid);
 
-
 /*
  * check if the input/output channel routing is enabled on the given bitmap.
  * used for mixer unit parser
@@ -539,7 +532,6 @@ static int check_matrix_bitmap(unsigned char *bmap, int ich, int och, int num_ou
 	return bmap[idx >> 3] & (0x80 >> (idx & 7));
 }
 
-
 /*
  * add an alsa control element
  * search and increment the index until an empty slot is found.
@@ -565,7 +557,6 @@ int snd_usb_mixer_add_control(struct usb_mixer_interface *mixer,
 	return 0;
 }
 
-
 /*
  * get a terminal name string
  */
@@ -658,7 +649,6 @@ static int get_term_name(struct mixer_build *state, struct usb_audio_term *iterm
 	return 0;
 }
 
-
 /*
  * parse the source unit recursively until it reaches to a terminal
  * or a branched unit.
@@ -746,7 +736,6 @@ static int check_input_term(struct mixer_build *state, int id, struct usb_audio_
 	return -ENODEV;
 }
 
-
 /*
  * Feature Unit
  */
@@ -774,7 +763,6 @@ static struct usb_feature_control_info audio_feature_info[] = {
 	{ "Phase Inverter Control",	USB_MIXER_BOOLEAN },
 };
 
-
 /* private_free callback */
 static void usb_mixer_elem_free(struct snd_kcontrol *kctl)
 {
@@ -782,7 +770,6 @@ static void usb_mixer_elem_free(struct snd_kcontrol *kctl)
 	kctl->private_data = NULL;
 }
 
-
 /*
  * interface to ALSA control for feature/mixer units
  */
@@ -803,16 +790,12 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
 	 */
 		if (!strcmp(kctl->id.name, "PCM Playback Volume") &&
 		    cval->min == -15616) {
-			snd_printk(KERN_INFO
-				 "set volume quirk for UDA1321/N101 chip\n");
 			cval->max = -256;
 		}
 		break;
 
 	case USB_ID(0x046d, 0x09a4):
 		if (!strcmp(kctl->id.name, "Mic Capture Volume")) {
-			snd_printk(KERN_INFO
-				"set volume quirk for QuickCam E3500\n");
 			cval->min = 6080;
 			cval->max = 8768;
 			cval->res = 192;
@@ -827,8 +810,6 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
 	 * Proboly there is some logitech magic behind this number --fishor
 	 */
 		if (!strcmp(kctl->id.name, "Mic Capture Volume")) {
-			snd_printk(KERN_INFO
-				"set resolution quirk: cval->res = 384\n");
 			cval->res = 384;
 		}
 		break;
@@ -1180,7 +1161,7 @@ static void build_feature_ctl(struct mixer_build *state, void *raw_desc,
 			check_mapped_dB(map, cval);
 			if (cval->dBmin < cval->dBmax || !cval->initialized) {
 				kctl->tlv.c = mixer_vol_tlv;
-				kctl->vd[0].access |= 
+				kctl->vd[0].access |=
 					SNDRV_CTL_ELEM_ACCESS_TLV_READ |
 					SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;
 			}
@@ -1199,23 +1180,9 @@ static void build_feature_ctl(struct mixer_build *state, void *raw_desc,
 	 * to be sure. 384 is a resolution magic number found on Logitech
 	 * devices. It will definitively catch all buggy Logitech devices.
 	 */
-	if (range > 384) {
-		snd_printk(KERN_WARNING "usb_audio: Warning! Unlikely big "
-			   "volume range (=%u), cval->res is probably wrong.",
-			   range);
-		snd_printk(KERN_WARNING "usb_audio: [%d] FU [%s] ch = %d, "
-			   "val = %d/%d/%d", cval->id,
-			   kctl->id.name, cval->channels,
-			   cval->min, cval->max, cval->res);
-	}
-
-	snd_printdd(KERN_INFO "[%d] FU [%s] ch = %d, val = %d/%d/%d\n",
-		    cval->id, kctl->id.name, cval->channels, cval->min, cval->max, cval->res);
 	snd_usb_mixer_add_control(state->mixer, kctl);
 }
 
-
-
 /*
  * parse a feature unit
  *
@@ -1240,9 +1207,6 @@ static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void
 		channels = (hdr->bLength - 7) / csize - 1;
 		bmaControls = hdr->bmaControls;
 		if (hdr->bLength < 7 + csize) {
-			snd_printk(KERN_ERR "usbaudio: unit %u: "
-				   "invalid UAC_FEATURE_UNIT descriptor\n",
-				   unitid);
 			return -EINVAL;
 		}
 	} else {
@@ -1251,9 +1215,6 @@ static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void
 		channels = (hdr->bLength - 6) / 4 - 1;
 		bmaControls = ftr->bmaControls;
 		if (hdr->bLength < 6 + csize) {
-			snd_printk(KERN_ERR "usbaudio: unit %u: "
-				   "invalid UAC_FEATURE_UNIT descriptor\n",
-				   unitid);
 			return -EINVAL;
 		}
 	}
@@ -1271,14 +1232,10 @@ static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void
 	/* master configuration quirks */
 	switch (state->chip->usb_id) {
 	case USB_ID(0x08bb, 0x2702):
-		snd_printk(KERN_INFO
-			   "usbmixer: master volume quirk for PCM2702 chip\n");
 		/* disable non-functional volume control */
 		master_bits &= ~UAC_CONTROL_BIT(UAC_FU_VOLUME);
 		break;
 	case USB_ID(0x1130, 0xf211):
-		snd_printk(KERN_INFO
-			   "usbmixer: volume control quirk for Tenx TP6911 Audio Headset\n");
 		/* disable non-functional volume control */
 		channels = 0;
 		break;
@@ -1333,7 +1290,6 @@ static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void
 	return 0;
 }
 
-
 /*
  * Mixer Unit
  */
@@ -1393,12 +1349,9 @@ static void build_mixer_unit_ctl(struct mixer_build *state,
 		len = sprintf(kctl->id.name, "Mixer Source %d", in_ch + 1);
 	append_ctl_name(kctl, " Volume");
 
-	snd_printdd(KERN_INFO "[%d] MU [%s] ch = %d, val = %d/%d\n",
-		    cval->id, kctl->id.name, cval->channels, cval->min, cval->max);
 	snd_usb_mixer_add_control(state->mixer, kctl);
 }
 
-
 /*
  * parse a mixer unit
  */
@@ -1415,7 +1368,6 @@ static int parse_audio_mixer_unit(struct mixer_build *state, int unitid, void *r
 	}
 	/* no bmControls field (e.g. Maya44) -> ignore */
 	if (desc->bLength <= 10 + input_pins) {
-		snd_printdd(KERN_INFO "MU %d has no bmControls field\n", unitid);
 		return 0;
 	}
 
@@ -1447,7 +1399,6 @@ static int parse_audio_mixer_unit(struct mixer_build *state, int unitid, void *r
 	return 0;
 }
 
-
 /*
  * Processing Unit / Extension Unit
  */
@@ -1500,7 +1451,6 @@ static struct snd_kcontrol_new mixer_procunit_ctl = {
 	.put = mixer_ctl_procunit_put,
 };
 
-
 /*
  * predefined data for processing units
  */
@@ -1694,15 +1644,12 @@ static int build_audio_procunit(struct mixer_build *state, int unitid, void *raw
 		append_ctl_name(kctl, " ");
 		append_ctl_name(kctl, valinfo->suffix);
 
-		snd_printdd(KERN_INFO "[%d] PU [%s] ch = %d, val = %d/%d\n",
-			    cval->id, kctl->id.name, cval->channels, cval->min, cval->max);
 		if ((err = snd_usb_mixer_add_control(state->mixer, kctl)) < 0)
 			return err;
 	}
 	return 0;
 }
 
-
 static int parse_audio_processing_unit(struct mixer_build *state, int unitid, void *raw_desc)
 {
 	return build_audio_procunit(state, unitid, raw_desc, procunits, "Processing Unit");
@@ -1715,7 +1662,6 @@ static int parse_audio_extension_unit(struct mixer_build *state, int unitid, voi
 	return build_audio_procunit(state, unitid, raw_desc, extunits, "Extension Unit");
 }
 
-
 /*
  * Selector Unit
  */
@@ -1782,7 +1728,6 @@ static struct snd_kcontrol_new mixer_selectunit_ctl = {
 	.put = mixer_ctl_selector_put,
 };
 
-
 /* private free callback.
  * free both private_data and private_value
  */
@@ -1911,15 +1856,12 @@ static int parse_audio_selector_unit(struct mixer_build *state, int unitid, void
 			append_ctl_name(kctl, " Playback Source");
 	}
 
-	snd_printdd(KERN_INFO "[%d] SU [%s] items = %d\n",
-		    cval->id, kctl->id.name, desc->bNrInPins);
 	if ((err = snd_usb_mixer_add_control(state->mixer, kctl)) < 0)
 		return err;
 
 	return 0;
 }
 
-
 /*
  * parse an audio unit recursively
  */
@@ -2109,8 +2051,6 @@ static void snd_usb_mixer_interrupt_v2(struct usb_mixer_interface *mixer,
 	__u8 channel = value & 0xff;
 
 	if (channel >= MAX_CHANNELS) {
-		snd_printk(KERN_DEBUG "%s(): bogus channel number %d\n",
-				__func__, channel);
 		return;
 	}
 
@@ -2139,8 +2079,6 @@ static void snd_usb_mixer_interrupt_v2(struct usb_mixer_interface *mixer,
 			break;
 
 		default:
-			snd_printk(KERN_DEBUG "unknown attribute %d in interrupt\n",
-						attribute);
 			break;
 		} /* switch */
 	}
@@ -2161,10 +2099,6 @@ static void snd_usb_mixer_interrupt(struct urb *urb)
 		for (status = urb->transfer_buffer;
 		     len >= sizeof(*status);
 		     len -= sizeof(*status), status++) {
-			snd_printd(KERN_DEBUG "status interrupt: %02x %02x\n",
-						status->bStatusType,
-						status->bOriginator);
-
 			/* ignore any notifications not from the control interface */
 			if ((status->bStatusType & UAC1_STATUS_TYPE_ORIG_MASK) !=
 				UAC1_STATUS_TYPE_ORIG_AUDIO_CONTROL_IF)
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index e9c47a4..cb1440c 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -301,15 +301,6 @@ static int set_format(struct snd_usb_substream *subs, struct audioformat *fmt)
 
 	snd_usb_set_format_quirk(subs, fmt);
 
-#if 0
-	printk(KERN_DEBUG
-	       "setting done: format = %d, rate = %d..%d, channels = %d\n",
-	       fmt->format, fmt->rate_min, fmt->rate_max, fmt->channels);
-	printk(KERN_DEBUG
-	       "  datapipe = 0x%0x, syncpipe = 0x%0x\n",
-	       subs->datapipe, subs->syncpipe);
-#endif
-
 	return 0;
 }
 
@@ -341,8 +332,6 @@ static int snd_usb_hw_params(struct snd_pcm_substream *substream,
 	channels = params_channels(hw_params);
 	fmt = find_format(subs, format, rate, channels);
 	if (!fmt) {
-		snd_printd(KERN_DEBUG "cannot set format: format = %#x, rate = %d, channels = %d\n",
-			   format, rate, channels);
 		return -EINVAL;
 	}
 
@@ -471,28 +460,23 @@ static int hw_check_valid_format(struct snd_usb_substream *subs,
 	check_fmts.bits[1] = (u32)(fp->formats >> 32);
 	snd_mask_intersect(&check_fmts, fmts);
 	if (snd_mask_empty(&check_fmts)) {
-		hwc_debug("   > check: no supported format %d\n", fp->format);
 		return 0;
 	}
 	/* check the channels */
 	if (fp->channels < ct->min || fp->channels > ct->max) {
-		hwc_debug("   > check: no valid channels %d (%d/%d)\n", fp->channels, ct->min, ct->max);
 		return 0;
 	}
 	/* check the rate is within the range */
 	if (fp->rate_min > it->max || (fp->rate_min == it->max && it->openmax)) {
-		hwc_debug("   > check: rate_min %d > max %d\n", fp->rate_min, it->max);
 		return 0;
 	}
 	if (fp->rate_max < it->min || (fp->rate_max == it->min && it->openmin)) {
-		hwc_debug("   > check: rate_max %d < min %d\n", fp->rate_max, it->min);
 		return 0;
 	}
 	/* check whether the period time is >= the data packet interval */
 	if (subs->speed != USB_SPEED_FULL) {
 		ptime = 125 * (1 << fp->datainterval);
 		if (ptime > pt->max || (ptime == pt->max && pt->openmax)) {
-			hwc_debug("   > check: ptime %u > max %u\n", ptime, pt->max);
 			return 0;
 		}
 	}
@@ -508,7 +492,6 @@ static int hw_rule_rate(struct snd_pcm_hw_params *params,
 	unsigned int rmin, rmax;
 	int changed;
 
-	hwc_debug("hw_rule_rate: (%d,%d)\n", it->min, it->max);
 	changed = 0;
 	rmin = rmax = 0;
 	list_for_each(p, &subs->fmt_list) {
@@ -528,7 +511,6 @@ static int hw_rule_rate(struct snd_pcm_hw_params *params,
 	}
 
 	if (!changed) {
-		hwc_debug("  --> get empty\n");
 		it->empty = 1;
 		return -EINVAL;
 	}
@@ -548,11 +530,9 @@ static int hw_rule_rate(struct snd_pcm_hw_params *params,
 		it->empty = 1;
 		return -EINVAL;
 	}
-	hwc_debug("  --> (%d, %d) (changed = %d)\n", it->min, it->max, changed);
 	return changed;
 }
 
-
 static int hw_rule_channels(struct snd_pcm_hw_params *params,
 			    struct snd_pcm_hw_rule *rule)
 {
@@ -562,7 +542,6 @@ static int hw_rule_channels(struct snd_pcm_hw_params *params,
 	unsigned int rmin, rmax;
 	int changed;
 
-	hwc_debug("hw_rule_channels: (%d,%d)\n", it->min, it->max);
 	changed = 0;
 	rmin = rmax = 0;
 	list_for_each(p, &subs->fmt_list) {
@@ -582,7 +561,6 @@ static int hw_rule_channels(struct snd_pcm_hw_params *params,
 	}
 
 	if (!changed) {
-		hwc_debug("  --> get empty\n");
 		it->empty = 1;
 		return -EINVAL;
 	}
@@ -602,7 +580,6 @@ static int hw_rule_channels(struct snd_pcm_hw_params *params,
 		it->empty = 1;
 		return -EINVAL;
 	}
-	hwc_debug("  --> (%d, %d) (changed = %d)\n", it->min, it->max, changed);
 	return changed;
 }
 
@@ -616,7 +593,6 @@ static int hw_rule_format(struct snd_pcm_hw_params *params,
 	u32 oldbits[2];
 	int changed;
 
-	hwc_debug("hw_rule_format: %x:%x\n", fmt->bits[0], fmt->bits[1]);
 	fbits = 0;
 	list_for_each(p, &subs->fmt_list) {
 		struct audioformat *fp;
@@ -631,11 +607,9 @@ static int hw_rule_format(struct snd_pcm_hw_params *params,
 	fmt->bits[0] &= (u32)fbits;
 	fmt->bits[1] &= (u32)(fbits >> 32);
 	if (!fmt->bits[0] && !fmt->bits[1]) {
-		hwc_debug("  --> get empty\n");
 		return -EINVAL;
 	}
 	changed = (oldbits[0] != fmt->bits[0] || oldbits[1] != fmt->bits[1]);
-	hwc_debug("  --> %x:%x (changed = %d)\n", fmt->bits[0], fmt->bits[1], changed);
 	return changed;
 }
 
@@ -650,7 +624,6 @@ static int hw_rule_period_time(struct snd_pcm_hw_params *params,
 	int changed;
 
 	it = hw_param_interval(params, SNDRV_PCM_HW_PARAM_PERIOD_TIME);
-	hwc_debug("hw_rule_period_time: (%u,%u)\n", it->min, it->max);
 	min_datainterval = 0xff;
 	list_for_each_entry(fp, &subs->fmt_list, list) {
 		if (!hw_check_valid_format(subs, params, fp))
@@ -658,7 +631,6 @@ static int hw_rule_period_time(struct snd_pcm_hw_params *params,
 		min_datainterval = min(min_datainterval, fp->datainterval);
 	}
 	if (min_datainterval == 0xff) {
-		hwc_debug("  --> get empty\n");
 		it->empty = 1;
 		return -EINVAL;
 	}
@@ -673,7 +645,6 @@ static int hw_rule_period_time(struct snd_pcm_hw_params *params,
 		it->empty = 1;
 		return -EINVAL;
 	}
-	hwc_debug("  --> (%u,%u) (changed = %d)\n", it->min, it->max, changed);
 	return changed;
 }
 
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 4a650ab..b306b56 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -70,7 +70,6 @@ static int ignore_interface_quirk(struct snd_usb_audio *chip,
 	return 0;
 }
 
-
 /*
  * Allow alignment on audio sub-slot (channel samples) rather than
  * on audio slots (audio frames)
@@ -173,7 +172,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 }
 
 /*
- * Create a stream for an Edirol UA-700/UA-25/UA-4FX interface.  
+ * Create a stream for an Edirol UA-700/UA-25/UA-4FX interface.
  * The only way to detect the sample rate is by looking at wMaxPacketSize.
  */
 static int create_uaxx_quirk(struct snd_usb_audio *chip,
@@ -350,8 +349,6 @@ static int snd_usb_extigy_boot_quirk(struct usb_device *dev, struct usb_interfac
 		if (err < 0) snd_printdd("error usb_get_descriptor: %d\n", err);
 		err = usb_reset_configuration(dev);
 		if (err < 0) snd_printdd("error usb_reset_configuration: %d\n", err);
-		snd_printdd("extigy_boot: new boot length = %d\n",
-			    le16_to_cpu(get_cfg_desc(config)->wTotalLength));
 		return -ENODEV; /* quit this anyway */
 	}
 	return 0;
